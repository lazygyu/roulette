{"mappings":"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EAAE,CAAC,EAAE,CAAC,MAAM,CAAG,CAAW,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,EAG/C,EAAE,EACH,CAGH,EAAS,UAAU,CAAG,KACxB,CCpba,IAAA,GAAW,CAAA,CAGxB,CAAA,GAAS,eAAe,CAAG,GAE3B,GAAS,QAAQ,CAAG,EAEpB,GAAS,KAAK,CAAG,EAEjB,GAAS,QAAQ,CAAG,EAEpB,GAAS,QAAQ,CAAG,GAEpB,GAAS,YAAY,CAAG,GAExB,GAAS,WAAW,CAAG,EAEvB,GAAS,KAAK,CAAG,EAGjB,GAAO,QAAQ,CAAG,GAGlB,GAAS,WAAW,CAAG,GAEvB,GAAS,KAAK,CAAG,GAEjB,GAAS,MAAM,CAAG,GAElB,GAAS,KAAK,CAAG,GAEjB,GAAS,KAAK,CAAG,GAGjB,GAAa,KAAK,CAAG,GAErB,GAAa,MAAM,CAAG,G,E,I,C,E,E,I,C,E,E,G,C,G,E,K,C,G,E,M,C,G,E,c,C,G,E,iB,C,G,E,kB,C,G,E,oB,C,G,E,e,C,G,E,O,C,G,E,Q,C,G,E,a,C,G,E,W,C,E,E,I,C,G,E,O,C,E,E,a,C,G,E,S,C,G,E,K,C,G,E,Q,C,E,E,K,C,E,E,K,C,G,E,I,C,E,E,U,C,G,E,U,C,G,E,O,C,G,E,c,C,G,E,W,C,G,E,a,C,G,E,S,C,G,E,G,C,E,E,U,C,G,E,Q,C,E,E,K,C,E,E,K,C,E,E,Y,C,G,E,S,C,E,E,I,C,E,E,I,C,G,E,S,C,G,E,U,C,G,E,K,C,G,E,Q,C,G,O,c,C,E,a,C,M,C,C,E,E,G,CEjGV,EAAA,GAAA,CAAA,EAAA,CAAA,CAAA,E,C,E,I,C,E,C,O,C,C,E,M,C,E,C,SEAZ,MAAM,EAAU,IANhB,M,a,CACI,IAAA,CAAA,SAAA,CAAqB,CAAA,EACrB,IAAA,CAAA,WAAA,CAAsB,EACtB,IAAA,CAAA,aAAA,CAAyB,CAAA,C,CAC7B,CHEO,OAAM,EAgBT,IAAI,UAAW,CACX,OAAO,IAAI,CAAC,IAAI,CAAC,WAAW,EAChC,CAEA,IAAI,GAAI,CACJ,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,AAC1B,CAEA,IAAI,EAAE,CAAS,CAAE,CACb,IAAI,C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","sources":["<anon>","src/index.ts","src/roulette.ts","node_modules/tslib/tslib.es6.js","node_modules/planck/dist/planck.js","node_modules/planck/node_modules/tslib/tslib.es6.js","node_modules/planck/src/util/options.ts","node_modules/planck/src/util/common.ts","node_modules/planck/src/common/Math.ts","node_modules/planck/src/common/Vec2.ts","node_modules/planck/src/collision/AABB.ts","node_modules/planck/src/Settings.ts","node_modules/planck/src/util/Pool.ts","node_modules/planck/src/collision/DynamicTree.ts","node_modules/planck/src/collision/BroadPhase.ts","node_modules/planck/src/common/Rot.ts","node_modules/planck/src/common/Transform.ts","node_modules/planck/src/common/Sweep.ts","node_modules/planck/src/dynamics/Velocity.ts","node_modules/planck/src/dynamics/Position.ts","node_modules/planck/src/collision/Shape.ts","node_modules/planck/src/dynamics/Fixture.ts","node_modules/planck/src/dynamics/Body.ts","node_modules/planck/src/common/Mat22.ts","node_modules/planck/src/collision/Manifold.ts","node_modules/planck/src/util/stats.ts","node_modules/planck/src/collision/Distance.ts","node_modules/planck/src/dynamics/Contact.ts","node_modules/planck/src/dynamics/Joint.ts","node_modules/planck/src/util/Timer.ts","node_modules/planck/src/collision/TimeOfImpact.ts","node_modules/planck/src/dynamics/Solver.ts","node_modules/planck/src/dynamics/World.ts","node_modules/planck/src/common/Vec3.ts","node_modules/planck/src/collision/shape/EdgeShape.ts","node_modules/planck/src/collision/shape/ChainShape.ts","node_modules/planck/src/collision/shape/PolygonShape.ts","node_modules/planck/src/collision/shape/BoxShape.ts","node_modules/planck/src/collision/shape/CircleShape.ts","node_modules/planck/src/dynamics/joint/DistanceJoint.ts","node_modules/planck/src/dynamics/joint/FrictionJoint.ts","node_modules/planck/src/common/Mat33.ts","node_modules/planck/src/dynamics/joint/RevoluteJoint.ts","node_modules/planck/src/dynamics/joint/PrismaticJoint.ts","node_modules/planck/src/dynamics/joint/GearJoint.ts","node_modules/planck/src/dynamics/joint/MotorJoint.ts","node_modules/planck/src/dynamics/joint/MouseJoint.ts","node_modules/planck/src/dynamics/joint/PulleyJoint.ts","node_modules/planck/src/dynamics/joint/RopeJoint.ts","node_modules/planck/src/dynamics/joint/WeldJoint.ts","node_modules/planck/src/dynamics/joint/WheelJoint.ts","node_modules/planck/src/serializer/index.ts","node_modules/planck/src/collision/shape/CollideCircle.ts","node_modules/planck/src/collision/shape/CollideEdgeCircle.ts","node_modules/planck/src/collision/shape/CollidePolygon.ts","node_modules/planck/src/collision/shape/CollideCirclePolygone.ts","node_modules/planck/src/collision/shape/CollideEdgePolygon.ts","node_modules/planck/src/index.ts","src/marble.ts","src/data/constants.ts","src/utils/utils.ts","src/options.ts","src/particleManager.ts","src/particle.ts","src/data/maps.ts","src/camera.ts","src/rouletteRenderer.ts","src/skillEffect.ts","src/utils/bound.decorator.ts","src/rankRenderer.ts","src/minimap.ts","src/utils/videoRecorder.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var $5c96a02c592fcff1$var$extendStatics = function(d, b) {\n    $5c96a02c592fcff1$var$extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return $5c96a02c592fcff1$var$extendStatics(d, b);\n};\nfunction $5c96a02c592fcff1$export$a8ba968b8961cb8a(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    $5c96a02c592fcff1$var$extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar $5c96a02c592fcff1$export$18ce0697a983be9b = function() {\n    $5c96a02c592fcff1$export$18ce0697a983be9b = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return $5c96a02c592fcff1$export$18ce0697a983be9b.apply(this, arguments);\n};\nfunction $5c96a02c592fcff1$export$3c9a16f847548506(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") {\n        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction $5c96a02c592fcff1$export$29e00dfd3077644b(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction $5c96a02c592fcff1$export$d5ad3fd78186038f(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}\nfunction $5c96a02c592fcff1$export$f1db080c865becb9(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction $5c96a02c592fcff1$export$1050f835b63b671e(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction $5c96a02c592fcff1$export$67ebef60e6f28a6(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar $5c96a02c592fcff1$export$45d3717a4c69092e = Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    };\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n};\nfunction $5c96a02c592fcff1$export$f33643c0debef087(m, o) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) $5c96a02c592fcff1$export$45d3717a4c69092e(o, m, p);\n}\nfunction $5c96a02c592fcff1$export$19a8beecd37a4c45(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction $5c96a02c592fcff1$export$8d051b38c9118094(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nfunction $5c96a02c592fcff1$export$afc72e2116322959() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat($5c96a02c592fcff1$export$8d051b38c9118094(arguments[i]));\n    return ar;\n}\nfunction $5c96a02c592fcff1$export$6388937ca91ccae8() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction $5c96a02c592fcff1$export$1216008129fb82ed(to, from, pack) {\n    if (pack || arguments.length === 2) {\n        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction $5c96a02c592fcff1$export$10c90e4f7922046c(v) {\n    return this instanceof $5c96a02c592fcff1$export$10c90e4f7922046c ? (this.v = v, this) : new $5c96a02c592fcff1$export$10c90e4f7922046c(v);\n}\nfunction $5c96a02c592fcff1$export$e427f37a30a4de9b(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof $5c96a02c592fcff1$export$10c90e4f7922046c ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction $5c96a02c592fcff1$export$bbd80228419bb833(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: $5c96a02c592fcff1$export$10c90e4f7922046c(o[n](v)),\n                done: n === \"return\"\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction $5c96a02c592fcff1$export$e3b29a3d6162315f(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof $5c96a02c592fcff1$export$19a8beecd37a4c45 === \"function\" ? $5c96a02c592fcff1$export$19a8beecd37a4c45(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nfunction $5c96a02c592fcff1$export$4fb47efe1390b86f(cooked, raw) {\n    if (Object.defineProperty) Object.defineProperty(cooked, \"raw\", {\n        value: raw\n    });\n    else cooked.raw = raw;\n    return cooked;\n}\nvar $5c96a02c592fcff1$var$__setModuleDefault = Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n};\nfunction $5c96a02c592fcff1$export$c21735bcef00d192(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) $5c96a02c592fcff1$export$45d3717a4c69092e(result, mod, k);\n    }\n    $5c96a02c592fcff1$var$__setModuleDefault(result, mod);\n    return result;\n}\nfunction $5c96a02c592fcff1$export$da59b14a69baef04(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n}\nfunction $5c96a02c592fcff1$export$d5dcaf168c640c35(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction $5c96a02c592fcff1$export$d40a35129aaff81f(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction $5c96a02c592fcff1$export$81fdc39f203e4e04(state, receiver) {\n    if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\") throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\n\nvar $6f94c7a48e8964a6$exports = {};\n/**\n * Planck.js v1.0.0-alpha.4\n * @license The MIT license\n * @copyright Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ (function(global, factory) {\n    factory($6f94c7a48e8964a6$exports);\n})($6f94c7a48e8964a6$exports, function(exports1) {\n    \"use strict\";\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    function __extends(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n    var __assign = function() {\n        __assign = Object.assign || function __assign(t) {\n            for(var s, i = 1, n = arguments.length; i < n; i++){\n                s = arguments[i];\n                for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n            }\n            return t;\n        };\n        return __assign.apply(this, arguments);\n    };\n    function options(input, defaults) {\n        if (input === null || typeof input === \"undefined\") // tslint:disable-next-line:no-object-literal-type-assertion\n        input = {};\n        var output = __assign({}, input);\n        // tslint:disable-next-line:no-for-in\n        for(var key in defaults)if (defaults.hasOwnProperty(key) && typeof input[key] === \"undefined\") output[key] = defaults[key];\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            var symbols = Object.getOwnPropertySymbols(defaults);\n            for(var i = 0; i < symbols.length; i++){\n                var symbol = symbols[i];\n                if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === \"undefined\") output[symbol] = defaults[symbol];\n            }\n        }\n        return output;\n    }\n    var debug = function() {\n        var rest = [];\n        for(var _i = 0; _i < arguments.length; _i++)rest[_i] = arguments[_i];\n        return;\n    };\n    var assert = function(statement, err, log) {\n        return;\n    };\n    var common = {\n        assert: assert,\n        debug: debug\n    };\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var math = Object.create(Math);\n    // @ts-ignore\n    // noinspection JSConstantReassignment\n    math.EPSILON = 1e-9; // TODO\n    math.isFinite = function(x) {\n        return typeof x === \"number\" && isFinite(x) && !isNaN(x);\n    };\n    math.assert = function(x) {\n        return;\n    };\n    math.invSqrt = function(x) {\n        // TODO:\n        return 1 / Math.sqrt(x);\n    };\n    math.nextPowerOfTwo = function(x) {\n        // TODO\n        x |= x >> 1;\n        x |= x >> 2;\n        x |= x >> 4;\n        x |= x >> 8;\n        x |= x >> 16;\n        return x + 1;\n    };\n    math.isPowerOfTwo = function(x) {\n        return x > 0 && (x & x - 1) === 0;\n    };\n    math.mod = function(num, min, max) {\n        if (typeof min === \"undefined\") {\n            max = 1;\n            min = 0;\n        } else if (typeof max === \"undefined\") {\n            max = min;\n            min = 0;\n        }\n        if (max > min) {\n            num = (num - min) % (max - min);\n            return num + (num < 0 ? max : min);\n        } else {\n            num = (num - max) % (min - max);\n            return num + (num <= 0 ? min : max);\n        }\n    };\n    math.clamp = function(num, min, max) {\n        if (num < min) return min;\n        else if (num > max) return max;\n        else return num;\n    };\n    math.random = function(min, max) {\n        if (typeof min === \"undefined\") {\n            max = 1;\n            min = 0;\n        } else if (typeof max === \"undefined\") {\n            max = min;\n            min = 0;\n        }\n        return min === max ? min : Math.random() * (max - min) + min;\n    };\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var Vec2 = /** @class */ function() {\n        // tslint:disable-next-line:typedef\n        function Vec2(x, y) {\n            if (!(this instanceof Vec2)) return new Vec2(x, y);\n            if (typeof x === \"undefined\") {\n                this.x = 0;\n                this.y = 0;\n            } else if (typeof x === \"object\") {\n                this.x = x.x;\n                this.y = x.y;\n            } else {\n                this.x = x;\n                this.y = y;\n            }\n        }\n        /** @internal */ Vec2.prototype._serialize = function() {\n            return {\n                x: this.x,\n                y: this.y\n            };\n        };\n        /** @internal */ Vec2._deserialize = function(data) {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = data.x;\n            obj.y = data.y;\n            return obj;\n        };\n        Vec2.zero = function() {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = 0;\n            obj.y = 0;\n            return obj;\n        };\n        /** @internal */ Vec2.neo = function(x, y) {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = x;\n            obj.y = y;\n            return obj;\n        };\n        Vec2.clone = function(v) {\n            return Vec2.neo(v.x, v.y);\n        };\n        /** @internal */ Vec2.prototype.toString = function() {\n            return JSON.stringify(this);\n        };\n        /**\n         * Does this vector contain finite coordinates?\n         */ Vec2.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return math.isFinite(obj.x) && math.isFinite(obj.y);\n        };\n        Vec2.assert = function(o) {\n            return;\n        };\n        Vec2.prototype.clone = function() {\n            return Vec2.clone(this);\n        };\n        /**\n         * Set this vector to all zeros.\n         *\n         * @returns this\n         */ Vec2.prototype.setZero = function() {\n            this.x = 0.0;\n            this.y = 0.0;\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */ // tslint:disable-next-line:typedef\n        Vec2.prototype.set = function(x, y) {\n            if (typeof x === \"object\") {\n                this.x = x.x;\n                this.y = x.y;\n            } else {\n                this.x = x;\n                this.y = y;\n            }\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */ Vec2.prototype.setNum = function(x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */ Vec2.prototype.setVec2 = function(value) {\n            this.x = value.x;\n            this.y = value.y;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Use setCombine or setMul\n         */ Vec2.prototype.wSet = function(a, v, b, w) {\n            if (typeof b !== \"undefined\" || typeof w !== \"undefined\") return this.setCombine(a, v, b, w);\n            else return this.setMul(a, v);\n        };\n        /**\n         * Set linear combination of v and w: `a * v + b * w`\n         */ Vec2.prototype.setCombine = function(a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        Vec2.prototype.setMul = function(a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        /**\n         * Add a vector to this vector.\n         *\n         * @returns this\n         */ Vec2.prototype.add = function(w) {\n            this.x += w.x;\n            this.y += w.y;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Use addCombine or addMul\n         */ Vec2.prototype.wAdd = function(a, v, b, w) {\n            if (typeof b !== \"undefined\" || typeof w !== \"undefined\") return this.addCombine(a, v, b, w);\n            else return this.addMul(a, v);\n        };\n        /**\n         * Add linear combination of v and w: `a * v + b * w`\n         */ Vec2.prototype.addCombine = function(a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x += x;\n            this.y += y;\n            return this;\n        };\n        Vec2.prototype.addMul = function(a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x += x;\n            this.y += y;\n            return this;\n        };\n        /**\n         * @deprecated Use subCombine or subMul\n         */ Vec2.prototype.wSub = function(a, v, b, w) {\n            if (typeof b !== \"undefined\" || typeof w !== \"undefined\") return this.subCombine(a, v, b, w);\n            else return this.subMul(a, v);\n        };\n        /**\n         * Subtract linear combination of v and w: `a * v + b * w`\n         */ Vec2.prototype.subCombine = function(a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x -= x;\n            this.y -= y;\n            return this;\n        };\n        Vec2.prototype.subMul = function(a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x -= x;\n            this.y -= y;\n            return this;\n        };\n        /**\n         * Subtract a vector from this vector\n         *\n         * @returns this\n         */ Vec2.prototype.sub = function(w) {\n            this.x -= w.x;\n            this.y -= w.y;\n            return this;\n        };\n        /**\n         * Multiply this vector by a scalar.\n         *\n         * @returns this\n         */ Vec2.prototype.mul = function(m) {\n            this.x *= m;\n            this.y *= m;\n            return this;\n        };\n        /**\n         * Get the length of this vector (the norm).\n         *\n         * For performance, use this instead of lengthSquared (if possible).\n         */ Vec2.prototype.length = function() {\n            return Vec2.lengthOf(this);\n        };\n        /**\n         * Get the length squared.\n         */ Vec2.prototype.lengthSquared = function() {\n            return Vec2.lengthSquared(this);\n        };\n        /**\n         * Convert this vector into a unit vector.\n         *\n         * @returns old length\n         */ Vec2.prototype.normalize = function() {\n            var length = this.length();\n            if (length < math.EPSILON) return 0.0;\n            var invLength = 1.0 / length;\n            this.x *= invLength;\n            this.y *= invLength;\n            return length;\n        };\n        /**\n         * Get the length of this vector (the norm).\n         *\n         * For performance, use this instead of lengthSquared (if possible).\n         */ Vec2.lengthOf = function(v) {\n            return math.sqrt(v.x * v.x + v.y * v.y);\n        };\n        /**\n         * Get the length squared.\n         */ Vec2.lengthSquared = function(v) {\n            return v.x * v.x + v.y * v.y;\n        };\n        Vec2.distance = function(v, w) {\n            var dx = v.x - w.x;\n            var dy = v.y - w.y;\n            return math.sqrt(dx * dx + dy * dy);\n        };\n        Vec2.distanceSquared = function(v, w) {\n            var dx = v.x - w.x;\n            var dy = v.y - w.y;\n            return dx * dx + dy * dy;\n        };\n        Vec2.areEqual = function(v, w) {\n            return v === w || typeof w === \"object\" && w !== null && v.x === w.x && v.y === w.y;\n        };\n        /**\n         * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n         */ Vec2.skew = function(v) {\n            return Vec2.neo(-v.y, v.x);\n        };\n        /**\n         * Perform the dot product on two vectors.\n         */ Vec2.dot = function(v, w) {\n            return v.x * w.x + v.y * w.y;\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         *\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */ // tslint:disable-next-line:typedef\n        Vec2.cross = function(v, w) {\n            if (typeof w === \"number\") return Vec2.neo(w * v.y, -w * v.x);\n            else if (typeof v === \"number\") return Vec2.neo(-v * w.y, v * w.x);\n            else return v.x * w.y - v.y * w.x;\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         */ Vec2.crossVec2Vec2 = function(v, w) {\n            return v.x * w.y - v.y * w.x;\n        };\n        /**\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */ Vec2.crossVec2Num = function(v, w) {\n            return Vec2.neo(w * v.y, -w * v.x);\n        };\n        /**\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */ Vec2.crossNumVec2 = function(v, w) {\n            return Vec2.neo(-v * w.y, v * w.x);\n        };\n        /**\n         * Returns `a + (v x w)`\n         */ // tslint:disable-next-line:typedef\n        Vec2.addCross = function(a, v, w) {\n            if (typeof w === \"number\") return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n            else if (typeof v === \"number\") return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n        };\n        /**\n         * Returns `a + (v x w)`\n         */ Vec2.addCrossVec2Num = function(a, v, w) {\n            return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n        };\n        /**\n         * Returns `a + (v x w)`\n         */ Vec2.addCrossNumVec2 = function(a, v, w) {\n            return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n        };\n        Vec2.add = function(v, w) {\n            return Vec2.neo(v.x + w.x, v.y + w.y);\n        };\n        /** @internal @deprecated */ Vec2.wAdd = function(a, v, b, w) {\n            if (typeof b !== \"undefined\" || typeof w !== \"undefined\") return Vec2.combine(a, v, b, w);\n            else return Vec2.mulNumVec2(a, v);\n        };\n        Vec2.combine = function(a, v, b, w) {\n            return Vec2.zero().setCombine(a, v, b, w);\n        };\n        Vec2.sub = function(v, w) {\n            return Vec2.neo(v.x - w.x, v.y - w.y);\n        };\n        // tslint:disable-next-line:typedef\n        Vec2.mul = function(a, b) {\n            if (typeof a === \"object\") return Vec2.neo(a.x * b, a.y * b);\n            else if (typeof b === \"object\") return Vec2.neo(a * b.x, a * b.y);\n        };\n        Vec2.mulVec2Num = function(a, b) {\n            return Vec2.neo(a.x * b, a.y * b);\n        };\n        Vec2.mulNumVec2 = function(a, b) {\n            return Vec2.neo(a * b.x, a * b.y);\n        };\n        Vec2.prototype.neg = function() {\n            this.x = -this.x;\n            this.y = -this.y;\n            return this;\n        };\n        Vec2.neg = function(v) {\n            return Vec2.neo(-v.x, -v.y);\n        };\n        Vec2.abs = function(v) {\n            return Vec2.neo(math.abs(v.x), math.abs(v.y));\n        };\n        Vec2.mid = function(v, w) {\n            return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n        };\n        Vec2.upper = function(v, w) {\n            return Vec2.neo(math.max(v.x, w.x), math.max(v.y, w.y));\n        };\n        Vec2.lower = function(v, w) {\n            return Vec2.neo(math.min(v.x, w.x), math.min(v.y, w.y));\n        };\n        Vec2.prototype.clamp = function(max) {\n            var lengthSqr = this.x * this.x + this.y * this.y;\n            if (lengthSqr > max * max) {\n                var invLength = math.invSqrt(lengthSqr);\n                this.x *= invLength * max;\n                this.y *= invLength * max;\n            }\n            return this;\n        };\n        Vec2.clamp = function(v, max) {\n            v = Vec2.neo(v.x, v.y);\n            v.clamp(max);\n            return v;\n        };\n        /**  @internal @deprecated */ // tslint:disable-next-line:typedef\n        Vec2.scaleFn = function(x, y) {\n            return function(v) {\n                return Vec2.neo(v.x * x, v.y * y);\n            };\n        };\n        /**  @internal @deprecated */ // tslint:disable-next-line:typedef\n        Vec2.translateFn = function(x, y) {\n            return function(v) {\n                return Vec2.neo(v.x + x, v.y + y);\n            };\n        };\n        return Vec2;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var AABB = /** @class */ function() {\n        function AABB(lower, upper) {\n            if (!(this instanceof AABB)) return new AABB(lower, upper);\n            this.lowerBound = Vec2.zero();\n            this.upperBound = Vec2.zero();\n            if (typeof lower === \"object\") this.lowerBound.setVec2(lower);\n            if (typeof upper === \"object\") this.upperBound.setVec2(upper);\n            else if (typeof lower === \"object\") this.upperBound.setVec2(lower);\n        }\n        /**\n         * Verify that the bounds are sorted.\n         */ AABB.prototype.isValid = function() {\n            return AABB.isValid(this);\n        };\n        AABB.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n        };\n        AABB.assert = function(o) {\n            return;\n        };\n        /**\n         * Get the center of the AABB.\n         */ AABB.prototype.getCenter = function() {\n            return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n        };\n        /**\n         * Get the extents of the AABB (half-widths).\n         */ AABB.prototype.getExtents = function() {\n            return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n        };\n        /**\n         * Get the perimeter length.\n         */ AABB.prototype.getPerimeter = function() {\n            return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n        };\n        /**\n         * Combine one or two AABB into this one.\n         */ AABB.prototype.combine = function(a, b) {\n            b = b || this;\n            var lowerA = a.lowerBound;\n            var upperA = a.upperBound;\n            var lowerB = b.lowerBound;\n            var upperB = b.upperBound;\n            var lowerX = math.min(lowerA.x, lowerB.x);\n            var lowerY = math.min(lowerA.y, lowerB.y);\n            var upperX = math.max(upperB.x, upperA.x);\n            var upperY = math.max(upperB.y, upperA.y);\n            this.lowerBound.setNum(lowerX, lowerY);\n            this.upperBound.setNum(upperX, upperY);\n        };\n        AABB.prototype.combinePoints = function(a, b) {\n            this.lowerBound.setNum(math.min(a.x, b.x), math.min(a.y, b.y));\n            this.upperBound.setNum(math.max(a.x, b.x), math.max(a.y, b.y));\n        };\n        AABB.prototype.set = function(aabb) {\n            this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n            this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n        };\n        AABB.prototype.contains = function(aabb) {\n            var result = true;\n            result = result && this.lowerBound.x <= aabb.lowerBound.x;\n            result = result && this.lowerBound.y <= aabb.lowerBound.y;\n            result = result && aabb.upperBound.x <= this.upperBound.x;\n            result = result && aabb.upperBound.y <= this.upperBound.y;\n            return result;\n        };\n        AABB.prototype.extend = function(value) {\n            AABB.extend(this, value);\n            return this;\n        };\n        AABB.extend = function(aabb, value) {\n            aabb.lowerBound.x -= value;\n            aabb.lowerBound.y -= value;\n            aabb.upperBound.x += value;\n            aabb.upperBound.y += value;\n        };\n        AABB.testOverlap = function(a, b) {\n            var d1x = b.lowerBound.x - a.upperBound.x;\n            var d2x = a.lowerBound.x - b.upperBound.x;\n            var d1y = b.lowerBound.y - a.upperBound.y;\n            var d2y = a.lowerBound.y - b.upperBound.y;\n            if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) return false;\n            return true;\n        };\n        AABB.areEqual = function(a, b) {\n            return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n        };\n        AABB.diff = function(a, b) {\n            var wD = math.max(0, math.min(a.upperBound.x, b.upperBound.x) - math.max(b.lowerBound.x, a.lowerBound.x));\n            var hD = math.max(0, math.min(a.upperBound.y, b.upperBound.y) - math.max(b.lowerBound.y, a.lowerBound.y));\n            var wA = a.upperBound.x - a.lowerBound.x;\n            var hA = a.upperBound.y - a.lowerBound.y;\n            var wB = b.upperBound.x - b.lowerBound.x;\n            var hB = b.upperBound.y - b.lowerBound.y;\n            return wA * hA + wB * hB - wD * hD;\n        };\n        AABB.prototype.rayCast = function(output, input) {\n            // From Real-time Collision Detection, p179.\n            var tmin = -Infinity;\n            var tmax = Infinity;\n            var p = input.p1;\n            var d = Vec2.sub(input.p2, input.p1);\n            var absD = Vec2.abs(d);\n            var normal = Vec2.zero();\n            for(var f = \"x\"; f !== null; f = f === \"x\" ? \"y\" : null)if (absD.x < math.EPSILON) {\n                // Parallel.\n                if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) return false;\n            } else {\n                var inv_d = 1.0 / d[f];\n                var t1 = (this.lowerBound[f] - p[f]) * inv_d;\n                var t2 = (this.upperBound[f] - p[f]) * inv_d;\n                // Sign of the normal vector.\n                var s = -1;\n                if (t1 > t2) {\n                    var temp = t1;\n                    t1 = t2;\n                    t2 = temp;\n                    s = 1.0;\n                }\n                // Push the min up\n                if (t1 > tmin) {\n                    normal.setZero();\n                    normal[f] = s;\n                    tmin = t1;\n                }\n                // Pull the max down\n                tmax = math.min(tmax, t2);\n                if (tmin > tmax) return false;\n            }\n            // Does the ray start inside the box?\n            // Does the ray intersect beyond the max fraction?\n            if (tmin < 0.0 || input.maxFraction < tmin) return false;\n            // Intersection.\n            output.fraction = tmin;\n            output.normal = normal;\n            return true;\n        };\n        /** @internal */ AABB.prototype.toString = function() {\n            return JSON.stringify(this);\n        };\n        return AABB;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ // TODO merge with World options?\n    /**\n     * Tuning constants based on meters-kilograms-seconds (MKS) units.\n     */ // tslint:disable-next-line:no-unnecessary-class\n    var Settings = /** @class */ function() {\n        function Settings() {}\n        Object.defineProperty(Settings, \"linearSlopSquared\", {\n            get: function() {\n                return Settings.linearSlop * Settings.linearSlop;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"polygonRadius\", {\n            /**\n             * The radius of the polygon/edge shape skin. This should not be modified.\n             * Making this smaller means polygons will have an insufficient buffer for\n             * continuous collision. Making it larger may create artifacts for vertex\n             * collision.\n             */ get: function() {\n                return 2.0 * Settings.linearSlop;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"maxTranslationSquared\", {\n            get: function() {\n                return Settings.maxTranslation * Settings.maxTranslation;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"maxRotationSquared\", {\n            get: function() {\n                return Settings.maxRotation * Settings.maxRotation;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"linearSleepToleranceSqr\", {\n            get: function() {\n                return Math.pow(Settings.linearSleepTolerance, 2);\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"angularSleepToleranceSqr\", {\n            get: function() {\n                return Math.pow(Settings.angularSleepTolerance, 2);\n            },\n            enumerable: false,\n            configurable: true\n        });\n        // Collision\n        /**\n         * The maximum number of contact points between two convex shapes. Do not change\n         * this value.\n         */ Settings.maxManifoldPoints = 2;\n        /**\n         * The maximum number of vertices on a convex polygon. You cannot increase this\n         * too much because BlockAllocator has a maximum object size.\n         */ Settings.maxPolygonVertices = 12;\n        /**\n         * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n         * by a small amount without triggering a tree adjustment. This is in meters.\n         */ Settings.aabbExtension = 0.1;\n        /**\n         * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n         * future position based on the current displacement. This is a dimensionless\n         * multiplier.\n         */ Settings.aabbMultiplier = 2.0;\n        /**\n         * A small length used as a collision and constraint tolerance. Usually it is\n         * chosen to be numerically significant, but visually insignificant.\n         */ Settings.linearSlop = 0.005;\n        /**\n         * A small angle used as a collision and constraint tolerance. Usually it is\n         * chosen to be numerically significant, but visually insignificant.\n         */ Settings.angularSlop = 2.0 / 180.0 * Math.PI;\n        /**\n         * Maximum number of sub-steps per contact in continuous physics simulation.\n         */ Settings.maxSubSteps = 8;\n        // Dynamics\n        /**\n         * Maximum number of contacts to be handled to solve a TOI impact.\n         */ Settings.maxTOIContacts = 32;\n        /**\n         * Maximum iterations to solve a TOI.\n         */ Settings.maxTOIIterations = 20;\n        /**\n         * Maximum iterations to find Distance.\n         */ Settings.maxDistnceIterations = 20;\n        /**\n         * A velocity threshold for elastic collisions. Any collision with a relative\n         * linear velocity below this threshold will be treated as inelastic.\n         */ Settings.velocityThreshold = 1.0;\n        /**\n         * The maximum linear position correction used when solving constraints. This\n         * helps to prevent overshoot.\n         */ Settings.maxLinearCorrection = 0.2;\n        /**\n         * The maximum angular position correction used when solving constraints. This\n         * helps to prevent overshoot.\n         */ Settings.maxAngularCorrection = 8.0 / 180.0 * Math.PI;\n        /**\n         * The maximum linear velocity of a body. This limit is very large and is used\n         * to prevent numerical problems. You shouldn't need to adjust Settings.\n         */ Settings.maxTranslation = 2.0;\n        /**\n         * The maximum angular velocity of a body. This limit is very large and is used\n         * to prevent numerical problems. You shouldn't need to adjust Settings.\n         */ Settings.maxRotation = 0.5 * Math.PI;\n        /**\n         * This scale factor controls how fast overlap is resolved. Ideally this would\n         * be 1 so that overlap is removed in one time step. However using values close\n         * to 1 often lead to overshoot.\n         */ Settings.baumgarte = 0.2;\n        Settings.toiBaugarte = 0.75;\n        // Sleep\n        /**\n         * The time that a body must be still before it will go to sleep.\n         */ Settings.timeToSleep = 0.5;\n        /**\n         * A body cannot sleep if its linear velocity is above this tolerance.\n         */ Settings.linearSleepTolerance = 0.01;\n        /**\n         * A body cannot sleep if its angular velocity is above this tolerance.\n         */ Settings.angularSleepTolerance = 2.0 / 180.0 * Math.PI;\n        return Settings;\n    }();\n    /*\n     * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n     *\n     * This software is provided 'as-is', without any express or implied\n     * warranty.  In no event will the authors be held liable for any damages\n     * arising from the use of this software.\n     * Permission is granted to anyone to use this software for any purpose,\n     * including commercial applications, and to alter it and redistribute it\n     * freely, subject to the following restrictions:\n     * 1. The origin of this software must not be misrepresented; you must not\n     * claim that you wrote the original software. If you use this software\n     * in a product, an acknowledgment in the product documentation would be\n     * appreciated but is not required.\n     * 2. Altered source versions must be plainly marked as such, and must not be\n     * misrepresented as being the original software.\n     * 3. This notice may not be removed or altered from any source distribution.\n     */ var Pool = /** @class */ function() {\n        function Pool(opts) {\n            this._list = [];\n            this._max = Infinity;\n            this._createCount = 0;\n            this._outCount = 0;\n            this._inCount = 0;\n            this._discardCount = 0;\n            this._list = [];\n            this._max = opts.max || this._max;\n            this._createFn = opts.create;\n            this._outFn = opts.allocate;\n            this._inFn = opts.release;\n            this._discardFn = opts.discard;\n        }\n        Pool.prototype.max = function(n) {\n            if (typeof n === \"number\") {\n                this._max = n;\n                return this;\n            }\n            return this._max;\n        };\n        Pool.prototype.size = function() {\n            return this._list.length;\n        };\n        Pool.prototype.allocate = function() {\n            var item;\n            if (this._list.length > 0) item = this._list.shift();\n            else {\n                this._createCount++;\n                if (typeof this._createFn === \"function\") item = this._createFn();\n                else // tslint:disable-next-line:no-object-literal-type-assertion\n                item = {};\n            }\n            this._outCount++;\n            if (typeof this._outFn === \"function\") this._outFn(item);\n            return item;\n        };\n        Pool.prototype.release = function(item) {\n            if (this._list.length < this._max) {\n                this._inCount++;\n                if (typeof this._inFn === \"function\") this._inFn(item);\n                this._list.push(item);\n            } else {\n                this._discardCount++;\n                if (typeof this._discardFn === \"function\") item = this._discardFn(item);\n            }\n        };\n        /** @internal */ Pool.prototype.toString = function() {\n            return \" +\" + this._createCount + \" >\" + this._outCount + \" <\" + this._inCount + \" -\" + this._discardCount + \" =\" + this._list.length + \"/\" + this._max;\n        };\n        return Pool;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A node in the dynamic tree. The client does not interact with this directly.\n     */ var TreeNode = /** @class */ function() {\n        function TreeNode(id) {\n            /** Enlarged AABB */ this.aabb = new AABB();\n            this.userData = null;\n            this.parent = null;\n            this.child1 = null;\n            this.child2 = null;\n            /** 0: leaf, -1: free node */ this.height = -1;\n            this.id = id;\n        }\n        /** @internal */ TreeNode.prototype.toString = function() {\n            return this.id + \": \" + this.userData;\n        };\n        TreeNode.prototype.isLeaf = function() {\n            return this.child1 == null;\n        };\n        return TreeNode;\n    }();\n    /**\n     * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n     * dynamic tree arranges data in a binary tree to accelerate queries such as\n     * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n     * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n     * than the client object. This allows the client object to move by small\n     * amounts without triggering a tree update.\n     *\n     * Nodes are pooled and relocatable, so we use node indices rather than\n     * pointers.\n     */ var DynamicTree = /** @class */ function() {\n        function DynamicTree() {\n            this.inputPool = new Pool({\n                create: function() {\n                    // tslint:disable-next-line:no-object-literal-type-assertion\n                    return {};\n                },\n                release: function(stack) {}\n            });\n            this.stackPool = new Pool({\n                create: function() {\n                    return [];\n                },\n                release: function(stack) {\n                    stack.length = 0;\n                }\n            });\n            this.iteratorPool = new Pool({\n                create: function() {\n                    return new Iterator();\n                },\n                release: function(iterator) {\n                    iterator.close();\n                }\n            });\n            this.m_root = null;\n            this.m_nodes = {};\n            this.m_lastProxyId = 0;\n            this.m_pool = new Pool({\n                create: function() {\n                    return new TreeNode();\n                }\n            });\n        }\n        /**\n         * Get proxy user data.\n         *\n         * @return the proxy user data or 0 if the id is invalid.\n         */ DynamicTree.prototype.getUserData = function(id) {\n            var node = this.m_nodes[id];\n            return node.userData;\n        };\n        /**\n         * Get the fat AABB for a node id.\n         *\n         * @return the proxy user data or 0 if the id is invalid.\n         */ DynamicTree.prototype.getFatAABB = function(id) {\n            var node = this.m_nodes[id];\n            return node.aabb;\n        };\n        DynamicTree.prototype.allocateNode = function() {\n            var node = this.m_pool.allocate();\n            node.id = ++this.m_lastProxyId;\n            node.userData = null;\n            node.parent = null;\n            node.child1 = null;\n            node.child2 = null;\n            node.height = -1;\n            this.m_nodes[node.id] = node;\n            return node;\n        };\n        DynamicTree.prototype.freeNode = function(node) {\n            this.m_pool.release(node);\n            node.height = -1;\n            // tslint:disable-next-line:no-dynamic-delete\n            delete this.m_nodes[node.id];\n        };\n        /**\n         * Create a proxy in the tree as a leaf node. We return the index of the node\n         * instead of a pointer so that we can grow the node pool.\n         *\n         * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n         */ DynamicTree.prototype.createProxy = function(aabb, userData) {\n            var node = this.allocateNode();\n            node.aabb.set(aabb);\n            // Fatten the aabb.\n            AABB.extend(node.aabb, Settings.aabbExtension);\n            node.userData = userData;\n            node.height = 0;\n            this.insertLeaf(node);\n            return node.id;\n        };\n        /**\n         * Destroy a proxy. This asserts if the id is invalid.\n         */ DynamicTree.prototype.destroyProxy = function(id) {\n            var node = this.m_nodes[id];\n            this.removeLeaf(node);\n            this.freeNode(node);\n        };\n        /**\n         * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n         * fattened AABB, then the proxy is removed from the tree and re-inserted.\n         * Otherwise the function returns immediately.\n         *\n         * @param d Displacement\n         *\n         * @return true if the proxy was re-inserted.\n         */ DynamicTree.prototype.moveProxy = function(id, aabb, d) {\n            var node = this.m_nodes[id];\n            if (node.aabb.contains(aabb)) return false;\n            this.removeLeaf(node);\n            node.aabb.set(aabb);\n            // Extend AABB.\n            aabb = node.aabb;\n            AABB.extend(aabb, Settings.aabbExtension);\n            // Predict AABB displacement.\n            // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n            if (d.x < 0.0) aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n            else aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n            if (d.y < 0.0) aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n            else aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n            this.insertLeaf(node);\n            return true;\n        };\n        DynamicTree.prototype.insertLeaf = function(leaf) {\n            if (this.m_root == null) {\n                this.m_root = leaf;\n                this.m_root.parent = null;\n                return;\n            }\n            // Find the best sibling for this node\n            var leafAABB = leaf.aabb;\n            var index = this.m_root;\n            while(!index.isLeaf()){\n                var child1 = index.child1;\n                var child2 = index.child2;\n                var area = index.aabb.getPerimeter();\n                var combinedAABB = new AABB();\n                combinedAABB.combine(index.aabb, leafAABB);\n                var combinedArea = combinedAABB.getPerimeter();\n                // Cost of creating a new parent for this node and the new leaf\n                var cost = 2.0 * combinedArea;\n                // Minimum cost of pushing the leaf further down the tree\n                var inheritanceCost = 2.0 * (combinedArea - area);\n                // Cost of descending into child1\n                var cost1 = void 0;\n                if (child1.isLeaf()) {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child1.aabb);\n                    cost1 = aabb.getPerimeter() + inheritanceCost;\n                } else {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child1.aabb);\n                    var oldArea = child1.aabb.getPerimeter();\n                    var newArea = aabb.getPerimeter();\n                    cost1 = newArea - oldArea + inheritanceCost;\n                }\n                // Cost of descending into child2\n                var cost2 = void 0;\n                if (child2.isLeaf()) {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child2.aabb);\n                    cost2 = aabb.getPerimeter() + inheritanceCost;\n                } else {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child2.aabb);\n                    var oldArea = child2.aabb.getPerimeter();\n                    var newArea = aabb.getPerimeter();\n                    cost2 = newArea - oldArea + inheritanceCost;\n                }\n                // Descend according to the minimum cost.\n                if (cost < cost1 && cost < cost2) break;\n                // Descend\n                if (cost1 < cost2) index = child1;\n                else index = child2;\n            }\n            var sibling = index;\n            // Create a new parent.\n            var oldParent = sibling.parent;\n            var newParent = this.allocateNode();\n            newParent.parent = oldParent;\n            newParent.userData = null;\n            newParent.aabb.combine(leafAABB, sibling.aabb);\n            newParent.height = sibling.height + 1;\n            if (oldParent != null) {\n                // The sibling was not the root.\n                if (oldParent.child1 === sibling) oldParent.child1 = newParent;\n                else oldParent.child2 = newParent;\n                newParent.child1 = sibling;\n                newParent.child2 = leaf;\n                sibling.parent = newParent;\n                leaf.parent = newParent;\n            } else {\n                // The sibling was the root.\n                newParent.child1 = sibling;\n                newParent.child2 = leaf;\n                sibling.parent = newParent;\n                leaf.parent = newParent;\n                this.m_root = newParent;\n            }\n            // Walk back up the tree fixing heights and AABBs\n            index = leaf.parent;\n            while(index != null){\n                index = this.balance(index);\n                var child1 = index.child1;\n                var child2 = index.child2;\n                index.height = 1 + math.max(child1.height, child2.height);\n                index.aabb.combine(child1.aabb, child2.aabb);\n                index = index.parent;\n            }\n        // validate();\n        };\n        DynamicTree.prototype.removeLeaf = function(leaf) {\n            if (leaf === this.m_root) {\n                this.m_root = null;\n                return;\n            }\n            var parent = leaf.parent;\n            var grandParent = parent.parent;\n            var sibling;\n            if (parent.child1 === leaf) sibling = parent.child2;\n            else sibling = parent.child1;\n            if (grandParent != null) {\n                // Destroy parent and connect sibling to grandParent.\n                if (grandParent.child1 === parent) grandParent.child1 = sibling;\n                else grandParent.child2 = sibling;\n                sibling.parent = grandParent;\n                this.freeNode(parent);\n                // Adjust ancestor bounds.\n                var index = grandParent;\n                while(index != null){\n                    index = this.balance(index);\n                    var child1 = index.child1;\n                    var child2 = index.child2;\n                    index.aabb.combine(child1.aabb, child2.aabb);\n                    index.height = 1 + math.max(child1.height, child2.height);\n                    index = index.parent;\n                }\n            } else {\n                this.m_root = sibling;\n                sibling.parent = null;\n                this.freeNode(parent);\n            }\n        // validate();\n        };\n        /**\n         * Perform a left or right rotation if node A is imbalanced. Returns the new\n         * root index.\n         */ DynamicTree.prototype.balance = function(iA) {\n            var A = iA;\n            if (A.isLeaf() || A.height < 2) return iA;\n            var B = A.child1;\n            var C = A.child2;\n            var balance = C.height - B.height;\n            // Rotate C up\n            if (balance > 1) {\n                var F = C.child1;\n                var G = C.child2;\n                // Swap A and C\n                C.child1 = A;\n                C.parent = A.parent;\n                A.parent = C;\n                // A's old parent should point to C\n                if (C.parent != null) {\n                    if (C.parent.child1 === iA) C.parent.child1 = C;\n                    else C.parent.child2 = C;\n                } else this.m_root = C;\n                // Rotate\n                if (F.height > G.height) {\n                    C.child2 = F;\n                    A.child2 = G;\n                    G.parent = A;\n                    A.aabb.combine(B.aabb, G.aabb);\n                    C.aabb.combine(A.aabb, F.aabb);\n                    A.height = 1 + math.max(B.height, G.height);\n                    C.height = 1 + math.max(A.height, F.height);\n                } else {\n                    C.child2 = G;\n                    A.child2 = F;\n                    F.parent = A;\n                    A.aabb.combine(B.aabb, F.aabb);\n                    C.aabb.combine(A.aabb, G.aabb);\n                    A.height = 1 + math.max(B.height, F.height);\n                    C.height = 1 + math.max(A.height, G.height);\n                }\n                return C;\n            }\n            // Rotate B up\n            if (balance < -1) {\n                var D = B.child1;\n                var E = B.child2;\n                // Swap A and B\n                B.child1 = A;\n                B.parent = A.parent;\n                A.parent = B;\n                // A's old parent should point to B\n                if (B.parent != null) {\n                    if (B.parent.child1 === A) B.parent.child1 = B;\n                    else B.parent.child2 = B;\n                } else this.m_root = B;\n                // Rotate\n                if (D.height > E.height) {\n                    B.child2 = D;\n                    A.child1 = E;\n                    E.parent = A;\n                    A.aabb.combine(C.aabb, E.aabb);\n                    B.aabb.combine(A.aabb, D.aabb);\n                    A.height = 1 + math.max(C.height, E.height);\n                    B.height = 1 + math.max(A.height, D.height);\n                } else {\n                    B.child2 = E;\n                    A.child1 = D;\n                    D.parent = A;\n                    A.aabb.combine(C.aabb, D.aabb);\n                    B.aabb.combine(A.aabb, E.aabb);\n                    A.height = 1 + math.max(C.height, D.height);\n                    B.height = 1 + math.max(A.height, E.height);\n                }\n                return B;\n            }\n            return A;\n        };\n        /**\n         * Compute the height of the binary tree in O(N) time. Should not be called\n         * often.\n         */ DynamicTree.prototype.getHeight = function() {\n            if (this.m_root == null) return 0;\n            return this.m_root.height;\n        };\n        /**\n         * Get the ratio of the sum of the node areas to the root area.\n         */ DynamicTree.prototype.getAreaRatio = function() {\n            if (this.m_root == null) return 0.0;\n            var root = this.m_root;\n            var rootArea = root.aabb.getPerimeter();\n            var totalArea = 0.0;\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while(node = it.next()){\n                if (node.height < 0) continue;\n                totalArea += node.aabb.getPerimeter();\n            }\n            this.iteratorPool.release(it);\n            return totalArea / rootArea;\n        };\n        /**\n         * Compute the height of a sub-tree.\n         */ DynamicTree.prototype.computeHeight = function(id) {\n            var node;\n            if (typeof id !== \"undefined\") node = this.m_nodes[id];\n            else node = this.m_root;\n            // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);\n            if (node.isLeaf()) return 0;\n            var height1 = this.computeHeight(node.child1.id);\n            var height2 = this.computeHeight(node.child2.id);\n            return 1 + math.max(height1, height2);\n        };\n        DynamicTree.prototype.validateStructure = function(node) {\n            if (node == null) return;\n            this.m_root;\n            var child1 = node.child1;\n            var child2 = node.child2;\n            if (node.isLeaf()) return;\n            this.validateStructure(child1);\n            this.validateStructure(child2);\n        };\n        DynamicTree.prototype.validateMetrics = function(node) {\n            if (node == null) return;\n            var child1 = node.child1;\n            var child2 = node.child2;\n            if (node.isLeaf()) return;\n            // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n            // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n            var height1 = child1.height;\n            var height2 = child2.height;\n            math.max(height1, height2);\n            var aabb = new AABB();\n            aabb.combine(child1.aabb, child2.aabb);\n            this.validateMetrics(child1);\n            this.validateMetrics(child2);\n        };\n        /**\n         * Validate this tree. For testing.\n         */ DynamicTree.prototype.validate = function() {\n            this.validateStructure(this.m_root);\n            this.validateMetrics(this.m_root);\n        };\n        /**\n         * Get the maximum balance of an node in the tree. The balance is the difference\n         * in height of the two children of a node.\n         */ DynamicTree.prototype.getMaxBalance = function() {\n            var maxBalance = 0;\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while(node = it.next()){\n                if (node.height <= 1) continue;\n                var balance = math.abs(node.child2.height - node.child1.height);\n                maxBalance = math.max(maxBalance, balance);\n            }\n            this.iteratorPool.release(it);\n            return maxBalance;\n        };\n        /**\n         * Build an optimal tree. Very expensive. For testing.\n         */ DynamicTree.prototype.rebuildBottomUp = function() {\n            var nodes = [];\n            var count = 0;\n            // Build array of leaves. Free the rest.\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while(node = it.next()){\n                if (node.height < 0) continue;\n                if (node.isLeaf()) {\n                    node.parent = null;\n                    nodes[count] = node;\n                    ++count;\n                } else this.freeNode(node);\n            }\n            this.iteratorPool.release(it);\n            while(count > 1){\n                var minCost = Infinity;\n                var iMin = -1;\n                var jMin = -1;\n                for(var i = 0; i < count; ++i){\n                    var aabbi = nodes[i].aabb;\n                    for(var j = i + 1; j < count; ++j){\n                        var aabbj = nodes[j].aabb;\n                        var b = new AABB();\n                        b.combine(aabbi, aabbj);\n                        var cost = b.getPerimeter();\n                        if (cost < minCost) {\n                            iMin = i;\n                            jMin = j;\n                            minCost = cost;\n                        }\n                    }\n                }\n                var child1 = nodes[iMin];\n                var child2 = nodes[jMin];\n                var parent_1 = this.allocateNode();\n                parent_1.child1 = child1;\n                parent_1.child2 = child2;\n                parent_1.height = 1 + math.max(child1.height, child2.height);\n                parent_1.aabb.combine(child1.aabb, child2.aabb);\n                parent_1.parent = null;\n                child1.parent = parent_1;\n                child2.parent = parent_1;\n                nodes[jMin] = nodes[count - 1];\n                nodes[iMin] = parent_1;\n                --count;\n            }\n            this.m_root = nodes[0];\n            this.validate();\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */ DynamicTree.prototype.shiftOrigin = function(newOrigin) {\n            // Build array of leaves. Free the rest.\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while(node = it.next()){\n                var aabb = node.aabb;\n                aabb.lowerBound.x -= newOrigin.x;\n                aabb.lowerBound.y -= newOrigin.y;\n                aabb.upperBound.x -= newOrigin.x;\n                aabb.upperBound.y -= newOrigin.y;\n            }\n            this.iteratorPool.release(it);\n        };\n        /**\n         * Query an AABB for overlapping proxies. The callback class is called for each\n         * proxy that overlaps the supplied AABB.\n         */ DynamicTree.prototype.query = function(aabb, queryCallback) {\n            var stack = this.stackPool.allocate();\n            stack.push(this.m_root);\n            while(stack.length > 0){\n                var node = stack.pop();\n                if (node == null) continue;\n                if (AABB.testOverlap(node.aabb, aabb)) {\n                    if (node.isLeaf()) {\n                        var proceed = queryCallback(node.id);\n                        if (proceed === false) return;\n                    } else {\n                        stack.push(node.child1);\n                        stack.push(node.child2);\n                    }\n                }\n            }\n            this.stackPool.release(stack);\n        };\n        /**\n         * Ray-cast against the proxies in the tree. This relies on the callback to\n         * perform a exact ray-cast in the case were the proxy contains a shape. The\n         * callback also performs the any collision filtering. This has performance\n         * roughly equal to k * log(n), where k is the number of collisions and n is the\n         * number of proxies in the tree.\n         *\n         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n         */ DynamicTree.prototype.rayCast = function(input, rayCastCallback) {\n            var p1 = input.p1;\n            var p2 = input.p2;\n            var r = Vec2.sub(p2, p1);\n            r.normalize();\n            // v is perpendicular to the segment.\n            var v = Vec2.crossNumVec2(1.0, r);\n            var abs_v = Vec2.abs(v);\n            // Separating axis for segment (Gino, p80).\n            // |dot(v, p1 - c)| > dot(|v|, h)\n            var maxFraction = input.maxFraction;\n            // Build a bounding box for the segment.\n            var segmentAABB = new AABB();\n            var t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);\n            segmentAABB.combinePoints(p1, t);\n            var stack = this.stackPool.allocate();\n            var subInput = this.inputPool.allocate();\n            stack.push(this.m_root);\n            while(stack.length > 0){\n                var node = stack.pop();\n                if (node == null) continue;\n                if (AABB.testOverlap(node.aabb, segmentAABB) === false) continue;\n                // Separating axis for segment (Gino, p80).\n                // |dot(v, p1 - c)| > dot(|v|, h)\n                var c = node.aabb.getCenter();\n                var h = node.aabb.getExtents();\n                var separation = math.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n                if (separation > 0.0) continue;\n                if (node.isLeaf()) {\n                    subInput.p1 = Vec2.clone(input.p1);\n                    subInput.p2 = Vec2.clone(input.p2);\n                    subInput.maxFraction = maxFraction;\n                    var value = rayCastCallback(subInput, node.id);\n                    if (value === 0.0) // The client has terminated the ray cast.\n                    return;\n                    if (value > 0.0) {\n                        // update segment bounding box.\n                        maxFraction = value;\n                        t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);\n                        segmentAABB.combinePoints(p1, t);\n                    }\n                } else {\n                    stack.push(node.child1);\n                    stack.push(node.child2);\n                }\n            }\n            this.stackPool.release(stack);\n            this.inputPool.release(subInput);\n        };\n        return DynamicTree;\n    }();\n    var Iterator = /** @class */ function() {\n        function Iterator() {\n            this.parents = [];\n            this.states = [];\n        }\n        Iterator.prototype.preorder = function(root) {\n            this.parents.length = 0;\n            this.parents.push(root);\n            this.states.length = 0;\n            this.states.push(0);\n            return this;\n        };\n        Iterator.prototype.next = function() {\n            while(this.parents.length > 0){\n                var i = this.parents.length - 1;\n                var node = this.parents[i];\n                if (this.states[i] === 0) {\n                    this.states[i] = 1;\n                    return node;\n                }\n                if (this.states[i] === 1) {\n                    this.states[i] = 2;\n                    if (node.child1) {\n                        this.parents.push(node.child1);\n                        this.states.push(1);\n                        return node.child1;\n                    }\n                }\n                if (this.states[i] === 2) {\n                    this.states[i] = 3;\n                    if (node.child2) {\n                        this.parents.push(node.child2);\n                        this.states.push(1);\n                        return node.child2;\n                    }\n                }\n                this.parents.pop();\n                this.states.pop();\n            }\n        };\n        Iterator.prototype.close = function() {\n            this.parents.length = 0;\n        };\n        return Iterator;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n     * objects and query them on update.\n     */ var BroadPhase = /** @class */ function() {\n        function BroadPhase() {\n            var _this = this;\n            this.m_tree = new DynamicTree();\n            this.m_proxyCount = 0;\n            this.m_moveBuffer = [];\n            /**\n             * Query an AABB for overlapping proxies. The callback class is called for each\n             * proxy that overlaps the supplied AABB.\n             */ this.query = function(aabb, queryCallback) {\n                _this.m_tree.query(aabb, queryCallback);\n            };\n            this.queryCallback = function(proxyId) {\n                // A proxy cannot form a pair with itself.\n                if (proxyId === _this.m_queryProxyId) return true;\n                var proxyIdA = math.min(proxyId, _this.m_queryProxyId);\n                var proxyIdB = math.max(proxyId, _this.m_queryProxyId);\n                // TODO: Skip any duplicate pairs.\n                var userDataA = _this.m_tree.getUserData(proxyIdA);\n                var userDataB = _this.m_tree.getUserData(proxyIdB);\n                // Send the pairs back to the client.\n                _this.m_callback(userDataA, userDataB);\n                return true;\n            };\n        }\n        /**\n         * Get user data from a proxy. Returns null if the id is invalid.\n         */ BroadPhase.prototype.getUserData = function(proxyId) {\n            return this.m_tree.getUserData(proxyId);\n        };\n        /**\n         * Test overlap of fat AABBs.\n         */ BroadPhase.prototype.testOverlap = function(proxyIdA, proxyIdB) {\n            var aabbA = this.m_tree.getFatAABB(proxyIdA);\n            var aabbB = this.m_tree.getFatAABB(proxyIdB);\n            return AABB.testOverlap(aabbA, aabbB);\n        };\n        /**\n         * Get the fat AABB for a proxy.\n         */ BroadPhase.prototype.getFatAABB = function(proxyId) {\n            return this.m_tree.getFatAABB(proxyId);\n        };\n        /**\n         * Get the number of proxies.\n         */ BroadPhase.prototype.getProxyCount = function() {\n            return this.m_proxyCount;\n        };\n        /**\n         * Get the height of the embedded tree.\n         */ BroadPhase.prototype.getTreeHeight = function() {\n            return this.m_tree.getHeight();\n        };\n        /**\n         * Get the balance (integer) of the embedded tree.\n         */ BroadPhase.prototype.getTreeBalance = function() {\n            return this.m_tree.getMaxBalance();\n        };\n        /**\n         * Get the quality metric of the embedded tree.\n         */ BroadPhase.prototype.getTreeQuality = function() {\n            return this.m_tree.getAreaRatio();\n        };\n        /**\n         * Ray-cast against the proxies in the tree. This relies on the callback to\n         * perform a exact ray-cast in the case were the proxy contains a shape. The\n         * callback also performs the any collision filtering. This has performance\n         * roughly equal to k * log(n), where k is the number of collisions and n is the\n         * number of proxies in the tree.\n         *\n         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n         */ BroadPhase.prototype.rayCast = function(input, rayCastCallback) {\n            this.m_tree.rayCast(input, rayCastCallback);\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */ BroadPhase.prototype.shiftOrigin = function(newOrigin) {\n            this.m_tree.shiftOrigin(newOrigin);\n        };\n        /**\n         * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n         * is called.\n         */ BroadPhase.prototype.createProxy = function(aabb, userData) {\n            var proxyId = this.m_tree.createProxy(aabb, userData);\n            this.m_proxyCount++;\n            this.bufferMove(proxyId);\n            return proxyId;\n        };\n        /**\n         * Destroy a proxy. It is up to the client to remove any pairs.\n         */ BroadPhase.prototype.destroyProxy = function(proxyId) {\n            this.unbufferMove(proxyId);\n            this.m_proxyCount--;\n            this.m_tree.destroyProxy(proxyId);\n        };\n        /**\n         * Call moveProxy as many times as you like, then when you are done call\n         * UpdatePairs to finalized the proxy pairs (for your time step).\n         */ BroadPhase.prototype.moveProxy = function(proxyId, aabb, displacement) {\n            var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n            if (changed) this.bufferMove(proxyId);\n        };\n        /**\n         * Call to trigger a re-processing of it's pairs on the next call to\n         * UpdatePairs.\n         */ BroadPhase.prototype.touchProxy = function(proxyId) {\n            this.bufferMove(proxyId);\n        };\n        BroadPhase.prototype.bufferMove = function(proxyId) {\n            this.m_moveBuffer.push(proxyId);\n        };\n        BroadPhase.prototype.unbufferMove = function(proxyId) {\n            for(var i = 0; i < this.m_moveBuffer.length; ++i)if (this.m_moveBuffer[i] === proxyId) this.m_moveBuffer[i] = null;\n        };\n        /**\n         * Update the pairs. This results in pair callbacks. This can only add pairs.\n         */ BroadPhase.prototype.updatePairs = function(addPairCallback) {\n            this.m_callback = addPairCallback;\n            // Perform tree queries for all moving proxies.\n            while(this.m_moveBuffer.length > 0){\n                this.m_queryProxyId = this.m_moveBuffer.pop();\n                if (this.m_queryProxyId === null) continue;\n                // We have to query the tree with the fat AABB so that\n                // we don't fail to create a pair that may touch later.\n                var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n                // Query tree, create pairs and add them pair buffer.\n                this.m_tree.query(fatAABB, this.queryCallback);\n            }\n        // Try to keep the tree balanced.\n        // this.m_tree.rebalance(4);\n        };\n        return BroadPhase;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var Rot = /** @class */ function() {\n        /** Initialize from an angle in radians. */ function Rot(angle) {\n            if (!(this instanceof Rot)) return new Rot(angle);\n            if (typeof angle === \"number\") this.setAngle(angle);\n            else if (typeof angle === \"object\") this.setRot(angle);\n            else this.setIdentity();\n        }\n        /** @internal */ Rot.neo = function(angle) {\n            var obj = Object.create(Rot.prototype);\n            obj.setAngle(angle);\n            return obj;\n        };\n        Rot.clone = function(rot) {\n            var obj = Object.create(Rot.prototype);\n            obj.s = rot.s;\n            obj.c = rot.c;\n            return obj;\n        };\n        Rot.identity = function() {\n            var obj = Object.create(Rot.prototype);\n            obj.s = 0.0;\n            obj.c = 1.0;\n            return obj;\n        };\n        Rot.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return math.isFinite(obj.s) && math.isFinite(obj.c);\n        };\n        Rot.assert = function(o) {\n            return;\n        };\n        /** Set to the identity rotation. */ Rot.prototype.setIdentity = function() {\n            this.s = 0.0;\n            this.c = 1.0;\n        };\n        Rot.prototype.set = function(angle) {\n            if (typeof angle === \"object\") {\n                this.s = angle.s;\n                this.c = angle.c;\n            } else {\n                // TODO_ERIN optimize\n                this.s = math.sin(angle);\n                this.c = math.cos(angle);\n            }\n        };\n        Rot.prototype.setRot = function(angle) {\n            this.s = angle.s;\n            this.c = angle.c;\n        };\n        /** Set using an angle in radians. */ Rot.prototype.setAngle = function(angle) {\n            // TODO_ERIN optimize\n            this.s = math.sin(angle);\n            this.c = math.cos(angle);\n        };\n        /** Get the angle in radians. */ Rot.prototype.getAngle = function() {\n            return math.atan2(this.s, this.c);\n        };\n        /** Get the x-axis. */ Rot.prototype.getXAxis = function() {\n            return Vec2.neo(this.c, this.s);\n        };\n        /** Get the u-axis. */ Rot.prototype.getYAxis = function() {\n            return Vec2.neo(-this.s, this.c);\n        };\n        // tslint:disable-next-line:typedef\n        Rot.mul = function(rot, m) {\n            if (\"c\" in m && \"s\" in m) {\n                // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n                // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n                // s = qs * rc + qc * rs\n                // c = qc * rc - qs * rs\n                var qr = Rot.identity();\n                qr.s = rot.s * m.c + rot.c * m.s;\n                qr.c = rot.c * m.c - rot.s * m.s;\n                return qr;\n            } else if (\"x\" in m && \"y\" in m) return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n        };\n        /** Multiply two rotations: q * r */ Rot.mulRot = function(rot, m) {\n            // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n            // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n            // s = qs * rc + qc * rs\n            // c = qc * rc - qs * rs\n            var qr = Rot.identity();\n            qr.s = rot.s * m.c + rot.c * m.s;\n            qr.c = rot.c * m.c - rot.s * m.s;\n            return qr;\n        };\n        /** Rotate a vector */ Rot.mulVec2 = function(rot, m) {\n            return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n        };\n        Rot.mulSub = function(rot, v, w) {\n            var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n            var y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n            return Vec2.neo(x, y);\n        };\n        // tslint:disable-next-line:typedef\n        Rot.mulT = function(rot, m) {\n            if (\"c\" in m && \"s\" in m) {\n                // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n                // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n                // s = qc * rs - qs * rc\n                // c = qc * rc + qs * rs\n                var qr = Rot.identity();\n                qr.s = rot.c * m.s - rot.s * m.c;\n                qr.c = rot.c * m.c + rot.s * m.s;\n                return qr;\n            } else if (\"x\" in m && \"y\" in m) return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n        };\n        /** Transpose multiply two rotations: qT * r */ Rot.mulTRot = function(rot, m) {\n            // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n            // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n            // s = qc * rs - qs * rc\n            // c = qc * rc + qs * rs\n            var qr = Rot.identity();\n            qr.s = rot.c * m.s - rot.s * m.c;\n            qr.c = rot.c * m.c + rot.s * m.s;\n            return qr;\n        };\n        /** Inverse rotate a vector */ Rot.mulTVec2 = function(rot, m) {\n            return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n        };\n        return Rot;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A transform contains translation and rotation. It is used to represent the\n     * position and orientation of rigid frames. Initialize using a position vector\n     * and a rotation.\n     */ var Transform = /** @class */ function() {\n        function Transform(position, rotation) {\n            if (!(this instanceof Transform)) return new Transform(position, rotation);\n            this.p = Vec2.zero();\n            this.q = Rot.identity();\n            if (typeof position !== \"undefined\") this.p.setVec2(position);\n            if (typeof rotation !== \"undefined\") this.q.setAngle(rotation);\n        }\n        Transform.clone = function(xf) {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.clone(xf.p);\n            obj.q = Rot.clone(xf.q);\n            return obj;\n        };\n        /** @internal */ Transform.neo = function(position, rotation) {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.clone(position);\n            obj.q = Rot.clone(rotation);\n            return obj;\n        };\n        Transform.identity = function() {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.zero();\n            obj.q = Rot.identity();\n            return obj;\n        };\n        /**\n         * Set this to the identity transform.\n         */ Transform.prototype.setIdentity = function() {\n            this.p.setZero();\n            this.q.setIdentity();\n        };\n        /**\n         * Set this based on the position and angle.\n         */ // tslint:disable-next-line:typedef\n        Transform.prototype.set = function(a, b) {\n            if (typeof b === \"undefined\") {\n                this.p.set(a.p);\n                this.q.set(a.q);\n            } else {\n                this.p.set(a);\n                this.q.set(b);\n            }\n        };\n        /**\n         * Set this based on the position and angle.\n         */ Transform.prototype.setNum = function(position, rotation) {\n            this.p.setVec2(position);\n            this.q.setAngle(rotation);\n        };\n        Transform.prototype.setTransform = function(xf) {\n            this.p.setVec2(xf.p);\n            this.q.setRot(xf.q);\n        };\n        Transform.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n        };\n        Transform.assert = function(o) {\n            return;\n        };\n        // static mul(a: Transform, b: Vec2[]): Vec2[];\n        // static mul(a: Transform, b: Transform[]): Transform[];\n        // tslint:disable-next-line:typedef\n        Transform.mul = function(a, b) {\n            if (Array.isArray(b)) {\n                var arr = [];\n                for(var i = 0; i < b.length; i++)arr[i] = Transform.mul(a, b[i]);\n                return arr;\n            } else if (\"x\" in b && \"y\" in b) return Transform.mulVec2(a, b);\n            else if (\"p\" in b && \"q\" in b) return Transform.mulXf(a, b);\n        };\n        // tslint:disable-next-line:typedef\n        Transform.mulAll = function(a, b) {\n            var arr = [];\n            for(var i = 0; i < b.length; i++)arr[i] = Transform.mul(a, b[i]);\n            return arr;\n        };\n        /** @internal @deprecated */ // tslint:disable-next-line:typedef\n        Transform.mulFn = function(a) {\n            return function(b) {\n                return Transform.mul(a, b);\n            };\n        };\n        Transform.mulVec2 = function(a, b) {\n            var x = a.q.c * b.x - a.q.s * b.y + a.p.x;\n            var y = a.q.s * b.x + a.q.c * b.y + a.p.y;\n            return Vec2.neo(x, y);\n        };\n        Transform.mulXf = function(a, b) {\n            // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n            // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n            var xf = Transform.identity();\n            xf.q = Rot.mulRot(a.q, b.q);\n            xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n            return xf;\n        };\n        // tslint:disable-next-line:typedef\n        Transform.mulT = function(a, b) {\n            if (\"x\" in b && \"y\" in b) return Transform.mulTVec2(a, b);\n            else if (\"p\" in b && \"q\" in b) return Transform.mulTXf(a, b);\n        };\n        Transform.mulTVec2 = function(a, b) {\n            var px = b.x - a.p.x;\n            var py = b.y - a.p.y;\n            var x = a.q.c * px + a.q.s * py;\n            var y = -a.q.s * px + a.q.c * py;\n            return Vec2.neo(x, y);\n        };\n        Transform.mulTXf = function(a, b) {\n            // v2 = A.q' * (B.q * v1 + B.p - A.p)\n            // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n            var xf = Transform.identity();\n            xf.q.setRot(Rot.mulTRot(a.q, b.q));\n            xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n            return xf;\n        };\n        return Transform;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * This describes the motion of a body/shape for TOI computation. Shapes are\n     * defined with respect to the body origin, which may not coincide with the\n     * center of mass. However, to support dynamics we must interpolate the center\n     * of mass position.\n     */ var Sweep = /** @class */ function() {\n        function Sweep(c, a) {\n            this.localCenter = Vec2.zero();\n            this.c = Vec2.zero();\n            this.a = 0;\n            this.alpha0 = 0;\n            this.c0 = Vec2.zero();\n            this.a0 = 0;\n        }\n        Sweep.prototype.setTransform = function(xf) {\n            var c = Transform.mulVec2(xf, this.localCenter);\n            this.c.setVec2(c);\n            this.c0.setVec2(c);\n            this.a = xf.q.getAngle();\n            this.a0 = xf.q.getAngle();\n        };\n        Sweep.prototype.setLocalCenter = function(localCenter, xf) {\n            this.localCenter.setVec2(localCenter);\n            var c = Transform.mulVec2(xf, this.localCenter);\n            this.c.setVec2(c);\n            this.c0.setVec2(c);\n        };\n        /**\n         * Get the interpolated transform at a specific time.\n         *\n         * @param xf\n         * @param beta A factor in [0,1], where 0 indicates alpha0\n         */ Sweep.prototype.getTransform = function(xf, beta) {\n            if (beta === void 0) beta = 0;\n            xf.q.setAngle((1.0 - beta) * this.a0 + beta * this.a);\n            xf.p.setCombine(1.0 - beta, this.c0, beta, this.c);\n            // shift to origin\n            xf.p.sub(Rot.mulVec2(xf.q, this.localCenter));\n        };\n        /**\n         * Advance the sweep forward, yielding a new initial state.\n         *\n         * @param alpha The new initial time\n         */ Sweep.prototype.advance = function(alpha) {\n            var beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n            this.c0.setCombine(beta, this.c, 1 - beta, this.c0);\n            this.a0 = beta * this.a + (1 - beta) * this.a0;\n            this.alpha0 = alpha;\n        };\n        Sweep.prototype.forward = function() {\n            this.a0 = this.a;\n            this.c0.setVec2(this.c);\n        };\n        /**\n         * normalize the angles in radians to be between -pi and pi.\n         */ Sweep.prototype.normalize = function() {\n            var a0 = math.mod(this.a0, -math.PI, +math.PI);\n            this.a -= this.a0 - a0;\n            this.a0 = a0;\n        };\n        Sweep.prototype.clone = function() {\n            var clone = new Sweep();\n            clone.localCenter.setVec2(this.localCenter);\n            clone.alpha0 = this.alpha0;\n            clone.a0 = this.a0;\n            clone.a = this.a;\n            clone.c0.setVec2(this.c0);\n            clone.c.setVec2(this.c);\n            return clone;\n        };\n        Sweep.prototype.set = function(that) {\n            this.localCenter.setVec2(that.localCenter);\n            this.alpha0 = that.alpha0;\n            this.a0 = that.a0;\n            this.a = that.a;\n            this.c0.setVec2(that.c0);\n            this.c.setVec2(that.c);\n        };\n        return Sweep;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var Velocity = /** @class */ function() {\n        function Velocity() {\n            this.v = Vec2.zero();\n            this.w = 0;\n        }\n        return Velocity;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var Position = /** @class */ function() {\n        function Position() {\n            this.c = Vec2.zero();\n            this.a = 0;\n        }\n        Position.prototype.getTransform = function(xf, p) {\n            xf.q.setAngle(this.a);\n            xf.p.setVec2(Vec2.sub(this.c, Rot.mulVec2(xf.q, p)));\n            return xf;\n        };\n        return Position;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A shape is used for collision detection. You can create a shape however you\n     * like. Shapes used for simulation in World are created automatically when a\n     * Fixture is created. Shapes may encapsulate one or more child shapes.\n     */ var Shape = /** @class */ function() {\n        function Shape() {}\n        /** @internal */ Shape.prototype._reset = function() {};\n        Shape.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return typeof obj.m_type === \"string\" && typeof obj.m_radius === \"number\";\n        };\n        Shape.prototype.getRadius = function() {\n            return this.m_radius;\n        };\n        /**\n         * Get the type of this shape. You can use this to down cast to the concrete\n         * shape.\n         *\n         * @return the shape type.\n         */ Shape.prototype.getType = function() {\n            return this.m_type;\n        };\n        return Shape;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var FixtureDefDefault = {\n        userData: null,\n        friction: 0.2,\n        restitution: 0.0,\n        density: 0.0,\n        isSensor: false,\n        filterGroupIndex: 0,\n        filterCategoryBits: 0x0001,\n        filterMaskBits: 0xFFFF\n    };\n    /**\n     * This proxy is used internally to connect shape children to the broad-phase.\n     */ var FixtureProxy = /** @class */ function() {\n        function FixtureProxy(fixture, childIndex) {\n            this.aabb = new AABB();\n            this.fixture = fixture;\n            this.childIndex = childIndex;\n            this.proxyId;\n        }\n        return FixtureProxy;\n    }();\n    /**\n     * A fixture is used to attach a shape to a body for collision detection. A\n     * fixture inherits its transform from its parent. Fixtures hold additional\n     * non-geometric data such as friction, collision filters, etc.\n     *\n     * To create a new Fixture use {@link Body.createFixture}.\n     */ var Fixture = /** @class */ function() {\n        // tslint:disable-next-line:typedef\n        /** @internal */ function Fixture(body, shape, def) {\n            if (shape.shape) {\n                def = shape;\n                shape = shape.shape;\n            } else if (typeof def === \"number\") def = {\n                density: def\n            };\n            def = options(def, FixtureDefDefault);\n            this.m_body = body;\n            this.m_friction = def.friction;\n            this.m_restitution = def.restitution;\n            this.m_density = def.density;\n            this.m_isSensor = def.isSensor;\n            this.m_filterGroupIndex = def.filterGroupIndex;\n            this.m_filterCategoryBits = def.filterCategoryBits;\n            this.m_filterMaskBits = def.filterMaskBits;\n            // TODO validate shape\n            this.m_shape = shape; // .clone();\n            this.m_next = null;\n            this.m_proxies = [];\n            this.m_proxyCount = 0;\n            var childCount = this.m_shape.getChildCount();\n            for(var i = 0; i < childCount; ++i)this.m_proxies[i] = new FixtureProxy(this, i);\n            this.m_userData = def.userData;\n        }\n        /**\n         * Re-setup fixture.\n         * @internal\n         */ Fixture.prototype._reset = function() {\n            var body = this.getBody();\n            var broadPhase = body.m_world.m_broadPhase;\n            this.destroyProxies(broadPhase);\n            if (this.m_shape._reset) this.m_shape._reset();\n            var childCount = this.m_shape.getChildCount();\n            for(var i = 0; i < childCount; ++i)this.m_proxies[i] = new FixtureProxy(this, i);\n            this.createProxies(broadPhase, body.m_xf);\n            body.resetMassData();\n        };\n        /** @internal */ Fixture.prototype._serialize = function() {\n            return {\n                friction: this.m_friction,\n                restitution: this.m_restitution,\n                density: this.m_density,\n                isSensor: this.m_isSensor,\n                filterGroupIndex: this.m_filterGroupIndex,\n                filterCategoryBits: this.m_filterCategoryBits,\n                filterMaskBits: this.m_filterMaskBits,\n                shape: this.m_shape\n            };\n        };\n        /** @internal */ Fixture._deserialize = function(data, body, restore) {\n            var shape = restore(Shape, data.shape);\n            var fixture = shape && new Fixture(body, shape, data);\n            return fixture;\n        };\n        /**\n         * Get the type of the child shape. You can use this to down cast to the\n         * concrete shape.\n         */ Fixture.prototype.getType = function() {\n            return this.m_shape.getType();\n        };\n        /**\n         * Get the child shape. You can modify the child shape, however you should not\n         * change the number of vertices because this will crash some collision caching\n         * mechanisms. Manipulating the shape may lead to non-physical behavior.\n         */ Fixture.prototype.getShape = function() {\n            return this.m_shape;\n        };\n        /**\n         * A sensor shape collects contact information but never generates a collision\n         * response.\n         */ Fixture.prototype.isSensor = function() {\n            return this.m_isSensor;\n        };\n        /**\n         * Set if this fixture is a sensor.\n         */ Fixture.prototype.setSensor = function(sensor) {\n            if (sensor != this.m_isSensor) {\n                this.m_body.setAwake(true);\n                this.m_isSensor = sensor;\n            }\n        };\n        // /**\n        //  * Get the contact filtering data.\n        //  */\n        // getFilterData() {\n        //   return this.m_filter;\n        // }\n        /**\n         * Get the user data that was assigned in the fixture definition. Use this to\n         * store your application specific data.\n         */ Fixture.prototype.getUserData = function() {\n            return this.m_userData;\n        };\n        /**\n         * Set the user data. Use this to store your application specific data.\n         */ Fixture.prototype.setUserData = function(data) {\n            this.m_userData = data;\n        };\n        /**\n         * Get the parent body of this fixture. This is null if the fixture is not\n         * attached.\n         */ Fixture.prototype.getBody = function() {\n            return this.m_body;\n        };\n        /**\n         * Get the next fixture in the parent body's fixture list.\n         */ Fixture.prototype.getNext = function() {\n            return this.m_next;\n        };\n        /**\n         * Get the density of this fixture.\n         */ Fixture.prototype.getDensity = function() {\n            return this.m_density;\n        };\n        /**\n         * Set the density of this fixture. This will _not_ automatically adjust the\n         * mass of the body. You must call Body.resetMassData to update the body's mass.\n         */ Fixture.prototype.setDensity = function(density) {\n            this.m_density = density;\n        };\n        /**\n         * Get the coefficient of friction, usually in the range [0,1].\n         */ Fixture.prototype.getFriction = function() {\n            return this.m_friction;\n        };\n        /**\n         * Set the coefficient of friction. This will not change the friction of\n         * existing contacts.\n         */ Fixture.prototype.setFriction = function(friction) {\n            this.m_friction = friction;\n        };\n        /**\n         * Get the coefficient of restitution.\n         */ Fixture.prototype.getRestitution = function() {\n            return this.m_restitution;\n        };\n        /**\n         * Set the coefficient of restitution. This will not change the restitution of\n         * existing contacts.\n         */ Fixture.prototype.setRestitution = function(restitution) {\n            this.m_restitution = restitution;\n        };\n        /**\n         * Test a point in world coordinates for containment in this fixture.\n         */ Fixture.prototype.testPoint = function(p) {\n            return this.m_shape.testPoint(this.m_body.getTransform(), p);\n        };\n        /**\n         * Cast a ray against this shape.\n         */ Fixture.prototype.rayCast = function(output, input, childIndex) {\n            return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n        };\n        /**\n         * Get the mass data for this fixture. The mass data is based on the density and\n         * the shape. The rotational inertia is about the shape's origin. This operation\n         * may be expensive.\n         */ Fixture.prototype.getMassData = function(massData) {\n            this.m_shape.computeMass(massData, this.m_density);\n        };\n        /**\n         * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n         * more accurate AABB, compute it using the shape and the body transform.\n         */ Fixture.prototype.getAABB = function(childIndex) {\n            return this.m_proxies[childIndex].aabb;\n        };\n        /**\n         * These support body activation/deactivation.\n         */ Fixture.prototype.createProxies = function(broadPhase, xf) {\n            // Create proxies in the broad-phase.\n            this.m_proxyCount = this.m_shape.getChildCount();\n            for(var i = 0; i < this.m_proxyCount; ++i){\n                var proxy = this.m_proxies[i];\n                this.m_shape.computeAABB(proxy.aabb, xf, i);\n                proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n            }\n        };\n        Fixture.prototype.destroyProxies = function(broadPhase) {\n            // Destroy proxies in the broad-phase.\n            for(var i = 0; i < this.m_proxyCount; ++i){\n                var proxy = this.m_proxies[i];\n                broadPhase.destroyProxy(proxy.proxyId);\n                proxy.proxyId = null;\n            }\n            this.m_proxyCount = 0;\n        };\n        /**\n         * Updates this fixture proxy in broad-phase (with combined AABB of current and\n         * next transformation).\n         */ Fixture.prototype.synchronize = function(broadPhase, xf1, xf2) {\n            for(var i = 0; i < this.m_proxyCount; ++i){\n                var proxy = this.m_proxies[i];\n                // Compute an AABB that covers the swept shape (may miss some rotation\n                // effect).\n                var aabb1 = new AABB();\n                var aabb2 = new AABB();\n                this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);\n                this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);\n                proxy.aabb.combine(aabb1, aabb2);\n                var displacement = Vec2.sub(xf2.p, xf1.p);\n                broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n            }\n        };\n        /**\n         * Set the contact filtering data. This will not update contacts until the next\n         * time step when either parent body is active and awake. This automatically\n         * calls refilter.\n         */ Fixture.prototype.setFilterData = function(filter) {\n            this.m_filterGroupIndex = filter.groupIndex;\n            this.m_filterCategoryBits = filter.categoryBits;\n            this.m_filterMaskBits = filter.maskBits;\n            this.refilter();\n        };\n        Fixture.prototype.getFilterGroupIndex = function() {\n            return this.m_filterGroupIndex;\n        };\n        Fixture.prototype.setFilterGroupIndex = function(groupIndex) {\n            this.m_filterGroupIndex = groupIndex;\n        };\n        Fixture.prototype.getFilterCategoryBits = function() {\n            return this.m_filterCategoryBits;\n        };\n        Fixture.prototype.setFilterCategoryBits = function(categoryBits) {\n            this.m_filterCategoryBits = categoryBits;\n        };\n        Fixture.prototype.getFilterMaskBits = function() {\n            return this.m_filterMaskBits;\n        };\n        Fixture.prototype.setFilterMaskBits = function(maskBits) {\n            this.m_filterMaskBits = maskBits;\n        };\n        /**\n         * Call this if you want to establish collision that was previously disabled by\n         * ContactFilter.\n         */ Fixture.prototype.refilter = function() {\n            if (this.m_body == null) return;\n            // Flag associated contacts for filtering.\n            var edge = this.m_body.getContactList();\n            while(edge){\n                var contact = edge.contact;\n                var fixtureA = contact.getFixtureA();\n                var fixtureB = contact.getFixtureB();\n                if (fixtureA == this || fixtureB == this) contact.flagForFiltering();\n                edge = edge.next;\n            }\n            var world = this.m_body.getWorld();\n            if (world == null) return;\n            // Touch each proxy so that new pairs may be created\n            var broadPhase = world.m_broadPhase;\n            for(var i = 0; i < this.m_proxyCount; ++i)broadPhase.touchProxy(this.m_proxies[i].proxyId);\n        };\n        /**\n         * Implement this method to provide collision filtering, if you want finer\n         * control over contact creation.\n         *\n         * Return true if contact calculations should be performed between these two\n         * fixtures.\n         *\n         * Warning: for performance reasons this is only called when the AABBs begin to\n         * overlap.\n         */ Fixture.prototype.shouldCollide = function(that) {\n            if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) return that.m_filterGroupIndex > 0;\n            var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n            var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n            var collide = collideA && collideB;\n            return collide;\n        };\n        return Fixture;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var STATIC = \"static\";\n    var KINEMATIC = \"kinematic\";\n    var DYNAMIC = \"dynamic\";\n    var BodyDefDefault = {\n        type: STATIC,\n        position: Vec2.zero(),\n        angle: 0.0,\n        linearVelocity: Vec2.zero(),\n        angularVelocity: 0.0,\n        linearDamping: 0.0,\n        angularDamping: 0.0,\n        fixedRotation: false,\n        bullet: false,\n        gravityScale: 1.0,\n        allowSleep: true,\n        awake: true,\n        active: true,\n        userData: null\n    };\n    /**\n     * MassData This holds the mass data computed for a shape.\n     */ var MassData = /** @class */ function() {\n        function MassData() {\n            /** The mass of the shape, usually in kilograms. */ this.mass = 0;\n            /** The position of the shape's centroid relative to the shape's origin. */ this.center = Vec2.zero();\n            /** The rotational inertia of the shape about the local origin. */ this.I = 0;\n        }\n        return MassData;\n    }();\n    /**\n     * A rigid body composed of one or more fixtures.\n     *\n     * To create a new Body use {@link World.createBody}.\n     */ var Body = /** @class */ function() {\n        /** @internal */ function Body(world, def) {\n            def = options(def, BodyDefDefault);\n            this.m_world = world;\n            this.m_awakeFlag = def.awake;\n            this.m_autoSleepFlag = def.allowSleep;\n            this.m_bulletFlag = def.bullet;\n            this.m_fixedRotationFlag = def.fixedRotation;\n            this.m_activeFlag = def.active;\n            this.m_islandFlag = false;\n            this.m_toiFlag = false;\n            this.m_userData = def.userData;\n            this.m_type = def.type;\n            if (this.m_type == DYNAMIC) {\n                this.m_mass = 1.0;\n                this.m_invMass = 1.0;\n            } else {\n                this.m_mass = 0.0;\n                this.m_invMass = 0.0;\n            }\n            // Rotational inertia about the center of mass.\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            // the body origin transform\n            this.m_xf = Transform.identity();\n            this.m_xf.p = Vec2.clone(def.position);\n            this.m_xf.q.setAngle(def.angle);\n            // the swept motion for CCD\n            this.m_sweep = new Sweep();\n            this.m_sweep.setTransform(this.m_xf);\n            // position and velocity correction\n            this.c_velocity = new Velocity();\n            this.c_position = new Position();\n            this.m_force = Vec2.zero();\n            this.m_torque = 0.0;\n            this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n            this.m_angularVelocity = def.angularVelocity;\n            this.m_linearDamping = def.linearDamping;\n            this.m_angularDamping = def.angularDamping;\n            this.m_gravityScale = def.gravityScale;\n            this.m_sleepTime = 0.0;\n            this.m_jointList = null;\n            this.m_contactList = null;\n            this.m_fixtureList = null;\n            this.m_prev = null;\n            this.m_next = null;\n            this.m_destroyed = false;\n        }\n        /** @internal */ Body.prototype._serialize = function() {\n            var fixtures = [];\n            for(var f = this.m_fixtureList; f; f = f.m_next)fixtures.push(f);\n            return {\n                type: this.m_type,\n                bullet: this.m_bulletFlag,\n                position: this.m_xf.p,\n                angle: this.m_xf.q.getAngle(),\n                linearVelocity: this.m_linearVelocity,\n                angularVelocity: this.m_angularVelocity,\n                fixtures: fixtures\n            };\n        };\n        /** @internal */ Body._deserialize = function(data, world, restore) {\n            var body = new Body(world, data);\n            if (data.fixtures) for(var i = data.fixtures.length - 1; i >= 0; i--){\n                var fixture = restore(Fixture, data.fixtures[i], body);\n                body._addFixture(fixture);\n            }\n            return body;\n        };\n        Body.prototype.isWorldLocked = function() {\n            return this.m_world && this.m_world.isLocked() ? true : false;\n        };\n        Body.prototype.getWorld = function() {\n            return this.m_world;\n        };\n        Body.prototype.getNext = function() {\n            return this.m_next;\n        };\n        Body.prototype.setUserData = function(data) {\n            this.m_userData = data;\n        };\n        Body.prototype.getUserData = function() {\n            return this.m_userData;\n        };\n        Body.prototype.getFixtureList = function() {\n            return this.m_fixtureList;\n        };\n        Body.prototype.getJointList = function() {\n            return this.m_jointList;\n        };\n        /**\n         * Warning: this list changes during the time step and you may miss some\n         * collisions if you don't use ContactListener.\n         */ Body.prototype.getContactList = function() {\n            return this.m_contactList;\n        };\n        Body.prototype.isStatic = function() {\n            return this.m_type == STATIC;\n        };\n        Body.prototype.isDynamic = function() {\n            return this.m_type == DYNAMIC;\n        };\n        Body.prototype.isKinematic = function() {\n            return this.m_type == KINEMATIC;\n        };\n        /**\n         * This will alter the mass and velocity.\n         */ Body.prototype.setStatic = function() {\n            this.setType(STATIC);\n            return this;\n        };\n        Body.prototype.setDynamic = function() {\n            this.setType(DYNAMIC);\n            return this;\n        };\n        Body.prototype.setKinematic = function() {\n            this.setType(KINEMATIC);\n            return this;\n        };\n        /**\n         * @internal\n         */ Body.prototype.getType = function() {\n            return this.m_type;\n        };\n        /**\n         * @internal\n         */ Body.prototype.setType = function(type) {\n            if (this.isWorldLocked() == true) return;\n            if (this.m_type == type) return;\n            this.m_type = type;\n            this.resetMassData();\n            if (this.m_type == STATIC) {\n                this.m_linearVelocity.setZero();\n                this.m_angularVelocity = 0.0;\n                this.m_sweep.forward();\n                this.synchronizeFixtures();\n            }\n            this.setAwake(true);\n            this.m_force.setZero();\n            this.m_torque = 0.0;\n            // Delete the attached contacts.\n            var ce = this.m_contactList;\n            while(ce){\n                var ce0 = ce;\n                ce = ce.next;\n                this.m_world.destroyContact(ce0.contact);\n            }\n            this.m_contactList = null;\n            // Touch the proxies so that new contacts will be created (when appropriate)\n            var broadPhase = this.m_world.m_broadPhase;\n            for(var f = this.m_fixtureList; f; f = f.m_next){\n                var proxyCount = f.m_proxyCount;\n                for(var i = 0; i < proxyCount; ++i)broadPhase.touchProxy(f.m_proxies[i].proxyId);\n            }\n        };\n        Body.prototype.isBullet = function() {\n            return this.m_bulletFlag;\n        };\n        /**\n         * Should this body be treated like a bullet for continuous collision detection?\n         */ Body.prototype.setBullet = function(flag) {\n            this.m_bulletFlag = !!flag;\n        };\n        Body.prototype.isSleepingAllowed = function() {\n            return this.m_autoSleepFlag;\n        };\n        Body.prototype.setSleepingAllowed = function(flag) {\n            this.m_autoSleepFlag = !!flag;\n            if (this.m_autoSleepFlag == false) this.setAwake(true);\n        };\n        Body.prototype.isAwake = function() {\n            return this.m_awakeFlag;\n        };\n        /**\n         * Set the sleep state of the body. A sleeping body has very low CPU cost.\n         *\n         * @param flag Set to true to wake the body, false to put it to sleep.\n         */ Body.prototype.setAwake = function(flag) {\n            if (flag) {\n                if (this.m_awakeFlag == false) {\n                    this.m_awakeFlag = true;\n                    this.m_sleepTime = 0.0;\n                }\n            } else {\n                this.m_awakeFlag = false;\n                this.m_sleepTime = 0.0;\n                this.m_linearVelocity.setZero();\n                this.m_angularVelocity = 0.0;\n                this.m_force.setZero();\n                this.m_torque = 0.0;\n            }\n        };\n        Body.prototype.isActive = function() {\n            return this.m_activeFlag;\n        };\n        /**\n         * Set the active state of the body. An inactive body is not simulated and\n         * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n         * will be added to the broad-phase. If you pass a flag of false, all fixtures\n         * will be removed from the broad-phase and all contacts will be destroyed.\n         * Fixtures and joints are otherwise unaffected.\n         *\n         * You may continue to create/destroy fixtures and joints on inactive bodies.\n         * Fixtures on an inactive body are implicitly inactive and will not participate\n         * in collisions, ray-casts, or queries. Joints connected to an inactive body\n         * are implicitly inactive. An inactive body is still owned by a World object\n         * and remains\n         */ Body.prototype.setActive = function(flag) {\n            if (flag == this.m_activeFlag) return;\n            this.m_activeFlag = !!flag;\n            if (this.m_activeFlag) {\n                // Create all proxies.\n                var broadPhase = this.m_world.m_broadPhase;\n                for(var f = this.m_fixtureList; f; f = f.m_next)f.createProxies(broadPhase, this.m_xf);\n            // Contacts are created the next time step.\n            } else {\n                // Destroy all proxies.\n                var broadPhase = this.m_world.m_broadPhase;\n                for(var f = this.m_fixtureList; f; f = f.m_next)f.destroyProxies(broadPhase);\n                // Destroy the attached contacts.\n                var ce = this.m_contactList;\n                while(ce){\n                    var ce0 = ce;\n                    ce = ce.next;\n                    this.m_world.destroyContact(ce0.contact);\n                }\n                this.m_contactList = null;\n            }\n        };\n        Body.prototype.isFixedRotation = function() {\n            return this.m_fixedRotationFlag;\n        };\n        /**\n         * Set this body to have fixed rotation. This causes the mass to be reset.\n         */ Body.prototype.setFixedRotation = function(flag) {\n            if (this.m_fixedRotationFlag == flag) return;\n            this.m_fixedRotationFlag = !!flag;\n            this.m_angularVelocity = 0.0;\n            this.resetMassData();\n        };\n        /**\n         * Get the world transform for the body's origin.\n         */ Body.prototype.getTransform = function() {\n            return this.m_xf;\n        };\n        /**\n         * Set the position of the body's origin and rotation. Manipulating a body's\n         * transform may cause non-physical behavior. Note: contacts are updated on the\n         * next call to World.step.\n         *\n         * @param position The world position of the body's local origin.\n         * @param angle The world rotation in radians.\n         */ Body.prototype.setTransform = function(position, angle) {\n            if (this.isWorldLocked() == true) return;\n            this.m_xf.setNum(position, angle);\n            this.m_sweep.setTransform(this.m_xf);\n            var broadPhase = this.m_world.m_broadPhase;\n            for(var f = this.m_fixtureList; f; f = f.m_next)f.synchronize(broadPhase, this.m_xf, this.m_xf);\n        };\n        Body.prototype.synchronizeTransform = function() {\n            this.m_sweep.getTransform(this.m_xf, 1);\n        };\n        /**\n         * Update fixtures in broad-phase.\n         */ Body.prototype.synchronizeFixtures = function() {\n            var xf = Transform.identity();\n            this.m_sweep.getTransform(xf, 0);\n            var broadPhase = this.m_world.m_broadPhase;\n            for(var f = this.m_fixtureList; f; f = f.m_next)f.synchronize(broadPhase, xf, this.m_xf);\n        };\n        /**\n         * Used in TOI.\n         */ Body.prototype.advance = function(alpha) {\n            // Advance to the new safe time. This doesn't sync the broad-phase.\n            this.m_sweep.advance(alpha);\n            this.m_sweep.c.setVec2(this.m_sweep.c0);\n            this.m_sweep.a = this.m_sweep.a0;\n            this.m_sweep.getTransform(this.m_xf, 1);\n        };\n        /**\n         * Get the world position for the body's origin.\n         */ Body.prototype.getPosition = function() {\n            return this.m_xf.p;\n        };\n        Body.prototype.setPosition = function(p) {\n            this.setTransform(p, this.m_sweep.a);\n        };\n        /**\n         * Get the current world rotation angle in radians.\n         */ Body.prototype.getAngle = function() {\n            return this.m_sweep.a;\n        };\n        Body.prototype.setAngle = function(angle) {\n            this.setTransform(this.m_xf.p, angle);\n        };\n        /**\n         * Get the world position of the center of mass.\n         */ Body.prototype.getWorldCenter = function() {\n            return this.m_sweep.c;\n        };\n        /**\n         * Get the local position of the center of mass.\n         */ Body.prototype.getLocalCenter = function() {\n            return this.m_sweep.localCenter;\n        };\n        /**\n         * Get the linear velocity of the center of mass.\n         *\n         * @return the linear velocity of the center of mass.\n         */ Body.prototype.getLinearVelocity = function() {\n            return this.m_linearVelocity;\n        };\n        /**\n         * Get the world linear velocity of a world point attached to this body.\n         *\n         * @param worldPoint A point in world coordinates.\n         */ Body.prototype.getLinearVelocityFromWorldPoint = function(worldPoint) {\n            var localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n            return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity, localCenter));\n        };\n        /**\n         * Get the world velocity of a local point.\n         *\n         * @param localPoint A point in local coordinates.\n         */ Body.prototype.getLinearVelocityFromLocalPoint = function(localPoint) {\n            return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n        };\n        /**\n         * Set the linear velocity of the center of mass.\n         *\n         * @param v The new linear velocity of the center of mass.\n         */ Body.prototype.setLinearVelocity = function(v) {\n            if (this.m_type == STATIC) return;\n            if (Vec2.dot(v, v) > 0.0) this.setAwake(true);\n            this.m_linearVelocity.setVec2(v);\n        };\n        /**\n         * Get the angular velocity.\n         *\n         * @returns the angular velocity in radians/second.\n         */ Body.prototype.getAngularVelocity = function() {\n            return this.m_angularVelocity;\n        };\n        /**\n         * Set the angular velocity.\n         *\n         * @param omega The new angular velocity in radians/second.\n         */ Body.prototype.setAngularVelocity = function(w) {\n            if (this.m_type == STATIC) return;\n            if (w * w > 0.0) this.setAwake(true);\n            this.m_angularVelocity = w;\n        };\n        Body.prototype.getLinearDamping = function() {\n            return this.m_linearDamping;\n        };\n        Body.prototype.setLinearDamping = function(linearDamping) {\n            this.m_linearDamping = linearDamping;\n        };\n        Body.prototype.getAngularDamping = function() {\n            return this.m_angularDamping;\n        };\n        Body.prototype.setAngularDamping = function(angularDamping) {\n            this.m_angularDamping = angularDamping;\n        };\n        Body.prototype.getGravityScale = function() {\n            return this.m_gravityScale;\n        };\n        /**\n         * Scale the gravity applied to this body.\n         */ Body.prototype.setGravityScale = function(scale) {\n            this.m_gravityScale = scale;\n        };\n        /**\n         * Get the total mass of the body.\n         *\n         * @returns The mass, usually in kilograms (kg).\n         */ Body.prototype.getMass = function() {\n            return this.m_mass;\n        };\n        /**\n         * Get the rotational inertia of the body about the local origin.\n         *\n         * @return the rotational inertia, usually in kg-m^2.\n         */ Body.prototype.getInertia = function() {\n            return this.m_I + this.m_mass * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n        };\n        /**\n         * Copy the mass data of the body to data.\n         */ Body.prototype.getMassData = function(data) {\n            data.mass = this.m_mass;\n            data.I = this.getInertia();\n            data.center.setVec2(this.m_sweep.localCenter);\n        };\n        /**\n         * This resets the mass properties to the sum of the mass properties of the\n         * fixtures. This normally does not need to be called unless you called\n         * SetMassData to override the mass and you later want to reset the mass.\n         */ Body.prototype.resetMassData = function() {\n            // Compute mass data from shapes. Each shape has its own density.\n            this.m_mass = 0.0;\n            this.m_invMass = 0.0;\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            this.m_sweep.localCenter.setZero();\n            // Static and kinematic bodies have zero mass.\n            if (this.isStatic() || this.isKinematic()) {\n                this.m_sweep.c0.setVec2(this.m_xf.p);\n                this.m_sweep.c.setVec2(this.m_xf.p);\n                this.m_sweep.a0 = this.m_sweep.a;\n                return;\n            }\n            // Accumulate mass over all fixtures.\n            var localCenter = Vec2.zero();\n            for(var f = this.m_fixtureList; f; f = f.m_next){\n                if (f.m_density == 0.0) continue;\n                var massData = new MassData();\n                f.getMassData(massData);\n                this.m_mass += massData.mass;\n                localCenter.addMul(massData.mass, massData.center);\n                this.m_I += massData.I;\n            }\n            // Compute center of mass.\n            if (this.m_mass > 0.0) {\n                this.m_invMass = 1.0 / this.m_mass;\n                localCenter.mul(this.m_invMass);\n            } else {\n                // Force all dynamic bodies to have a positive mass.\n                this.m_mass = 1.0;\n                this.m_invMass = 1.0;\n            }\n            if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n                // Center the inertia about the center of mass.\n                this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);\n                this.m_invI = 1.0 / this.m_I;\n            } else {\n                this.m_I = 0.0;\n                this.m_invI = 0.0;\n            }\n            // Move center of mass.\n            var oldCenter = Vec2.clone(this.m_sweep.c);\n            this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n            // Update center of mass velocity.\n            this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));\n        };\n        /**\n         * Set the mass properties to override the mass properties of the fixtures. Note\n         * that this changes the center of mass position. Note that creating or\n         * destroying fixtures can also alter the mass. This function has no effect if\n         * the body isn't dynamic.\n         *\n         * @param massData The mass properties.\n         */ Body.prototype.setMassData = function(massData) {\n            if (this.isWorldLocked() == true) return;\n            if (this.m_type != DYNAMIC) return;\n            this.m_invMass = 0.0;\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            this.m_mass = massData.mass;\n            if (this.m_mass <= 0.0) this.m_mass = 1.0;\n            this.m_invMass = 1.0 / this.m_mass;\n            if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n                this.m_I = massData.I - this.m_mass * Vec2.dot(massData.center, massData.center);\n                this.m_invI = 1.0 / this.m_I;\n            }\n            // Move center of mass.\n            var oldCenter = Vec2.clone(this.m_sweep.c);\n            this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n            // Update center of mass velocity.\n            this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));\n        };\n        /**\n         * Apply a force at a world point. If the force is not applied at the center of\n         * mass, it will generate a torque and affect the angular velocity. This wakes\n         * up the body.\n         *\n         * @param force The world force vector, usually in Newtons (N).\n         * @param point The world position of the point of application.\n         * @param wake Also wake up the body\n         */ Body.prototype.applyForce = function(force, point, wake) {\n            if (wake === void 0) wake = true;\n            if (this.m_type != DYNAMIC) return;\n            if (wake && this.m_awakeFlag == false) this.setAwake(true);\n            // Don't accumulate a force if the body is sleeping.\n            if (this.m_awakeFlag) {\n                this.m_force.add(force);\n                this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n            }\n        };\n        /**\n         * Apply a force to the center of mass. This wakes up the body.\n         *\n         * @param force The world force vector, usually in Newtons (N).\n         * @param wake Also wake up the body\n         */ Body.prototype.applyForceToCenter = function(force, wake) {\n            if (wake === void 0) wake = true;\n            if (this.m_type != DYNAMIC) return;\n            if (wake && this.m_awakeFlag == false) this.setAwake(true);\n            // Don't accumulate a force if the body is sleeping\n            if (this.m_awakeFlag) this.m_force.add(force);\n        };\n        /**\n         * Apply a torque. This affects the angular velocity without affecting the\n         * linear velocity of the center of mass. This wakes up the body.\n         *\n         * @param torque About the z-axis (out of the screen), usually in N-m.\n         * @param wake Also wake up the body\n         */ Body.prototype.applyTorque = function(torque, wake) {\n            if (wake === void 0) wake = true;\n            if (this.m_type != DYNAMIC) return;\n            if (wake && this.m_awakeFlag == false) this.setAwake(true);\n            // Don't accumulate a force if the body is sleeping\n            if (this.m_awakeFlag) this.m_torque += torque;\n        };\n        /**\n         * Apply an impulse at a point. This immediately modifies the velocity. It also\n         * modifies the angular velocity if the point of application is not at the\n         * center of mass. This wakes up the body.\n         *\n         * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n         * @param point The world position of the point of application.\n         * @param wake Also wake up the body\n         */ Body.prototype.applyLinearImpulse = function(impulse, point, wake) {\n            if (wake === void 0) wake = true;\n            if (this.m_type != DYNAMIC) return;\n            if (wake && this.m_awakeFlag == false) this.setAwake(true);\n            // Don't accumulate velocity if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_linearVelocity.addMul(this.m_invMass, impulse);\n                this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n            }\n        };\n        /**\n         * Apply an angular impulse.\n         *\n         * @param impulse The angular impulse in units of kg*m*m/s\n         * @param wake Also wake up the body\n         */ Body.prototype.applyAngularImpulse = function(impulse, wake) {\n            if (wake === void 0) wake = true;\n            if (this.m_type != DYNAMIC) return;\n            if (wake && this.m_awakeFlag == false) this.setAwake(true);\n            // Don't accumulate velocity if the body is sleeping\n            if (this.m_awakeFlag) this.m_angularVelocity += this.m_invI * impulse;\n        };\n        /**\n         * This is used to prevent connected bodies (by joints) from colliding,\n         * depending on the joint's collideConnected flag.\n         */ Body.prototype.shouldCollide = function(that) {\n            // At least one body should be dynamic.\n            if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) return false;\n            // Does a joint prevent collision?\n            for(var jn = this.m_jointList; jn; jn = jn.next)if (jn.other == that) {\n                if (jn.joint.m_collideConnected == false) return false;\n            }\n            return true;\n        };\n        /**\n         * @internal Used for deserialize.\n         */ Body.prototype._addFixture = function(fixture) {\n            if (this.isWorldLocked() == true) return null;\n            if (this.m_activeFlag) {\n                var broadPhase = this.m_world.m_broadPhase;\n                fixture.createProxies(broadPhase, this.m_xf);\n            }\n            fixture.m_next = this.m_fixtureList;\n            this.m_fixtureList = fixture;\n            // Adjust mass properties if needed.\n            if (fixture.m_density > 0.0) this.resetMassData();\n            // Let the world know we have a new fixture. This will cause new contacts\n            // to be created at the beginning of the next time step.\n            this.m_world.m_newFixture = true;\n            return fixture;\n        };\n        // tslint:disable-next-line:typedef\n        Body.prototype.createFixture = function(shape, fixdef) {\n            if (this.isWorldLocked() == true) return null;\n            var fixture = new Fixture(this, shape, fixdef);\n            this._addFixture(fixture);\n            return fixture;\n        };\n        /**\n         * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n         * all contacts associated with this fixture. This will automatically adjust the\n         * mass of the body if the body is dynamic and the fixture has positive density.\n         * All fixtures attached to a body are implicitly destroyed when the body is\n         * destroyed.\n         *\n         * Warning: This function is locked during callbacks.\n         *\n         * @param fixture The fixture to be removed.\n         */ Body.prototype.destroyFixture = function(fixture) {\n            if (this.isWorldLocked() == true) return;\n            if (this.m_fixtureList === fixture) this.m_fixtureList = fixture.m_next;\n            else {\n                var node = this.m_fixtureList;\n                while(node != null){\n                    if (node.m_next === fixture) {\n                        node.m_next = fixture.m_next;\n                        break;\n                    }\n                    node = node.m_next;\n                }\n            }\n            // Destroy any contacts associated with the fixture.\n            var edge = this.m_contactList;\n            while(edge){\n                var c = edge.contact;\n                edge = edge.next;\n                var fixtureA = c.getFixtureA();\n                var fixtureB = c.getFixtureB();\n                if (fixture == fixtureA || fixture == fixtureB) // This destroys the contact and removes it from\n                // this body's contact list.\n                this.m_world.destroyContact(c);\n            }\n            if (this.m_activeFlag) {\n                var broadPhase = this.m_world.m_broadPhase;\n                fixture.destroyProxies(broadPhase);\n            }\n            fixture.m_body = null;\n            fixture.m_next = null;\n            this.m_world.publish(\"remove-fixture\", fixture);\n            // Reset the mass data.\n            this.resetMassData();\n        };\n        /**\n         * Get the corresponding world point of a local point.\n         */ Body.prototype.getWorldPoint = function(localPoint) {\n            return Transform.mulVec2(this.m_xf, localPoint);\n        };\n        /**\n         * Get the corresponding world vector of a local vector.\n         */ Body.prototype.getWorldVector = function(localVector) {\n            return Rot.mulVec2(this.m_xf.q, localVector);\n        };\n        /**\n         * Gets the corresponding local point of a world point.\n         */ Body.prototype.getLocalPoint = function(worldPoint) {\n            return Transform.mulTVec2(this.m_xf, worldPoint);\n        };\n        /**\n         * Gets the corresponding local vector of a world vector.\n         */ Body.prototype.getLocalVector = function(worldVector) {\n            return Rot.mulTVec2(this.m_xf.q, worldVector);\n        };\n        /**\n         * A static body does not move under simulation and behaves as if it has infinite mass.\n         * Internally, zero is stored for the mass and the inverse mass.\n         * Static bodies can be moved manually by the user.\n         * A static body has zero velocity.\n         * Static bodies do not collide with other static or kinematic bodies.\n         */ Body.STATIC = \"static\";\n        /**\n         * A kinematic body moves under simulation according to its velocity.\n         * Kinematic bodies do not respond to forces.\n         * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n         * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n         * Kinematic bodies do not collide with other kinematic or static bodies.\n         */ Body.KINEMATIC = \"kinematic\";\n        /**\n         * A dynamic body is fully simulated.\n         * They can be moved manually by the user, but normally they move according to forces.\n         * A dynamic body can collide with all body types.\n         * A dynamic body always has finite, non-zero mass.\n         * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n         */ Body.DYNAMIC = \"dynamic\";\n        return Body;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A 2-by-2 matrix. Stored in column-major order.\n     */ var Mat22 = /** @class */ function() {\n        // tslint:disable-next-line:typedef\n        function Mat22(a, b, c, d) {\n            if (typeof a === \"object\" && a !== null) {\n                this.ex = Vec2.clone(a);\n                this.ey = Vec2.clone(b);\n            } else if (typeof a === \"number\") {\n                this.ex = Vec2.neo(a, c);\n                this.ey = Vec2.neo(b, d);\n            } else {\n                this.ex = Vec2.zero();\n                this.ey = Vec2.zero();\n            }\n        }\n        /** @internal */ Mat22.prototype.toString = function() {\n            return JSON.stringify(this);\n        };\n        Mat22.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n        };\n        Mat22.assert = function(o) {\n            return;\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.prototype.set = function(a, b, c, d) {\n            if (typeof a === \"number\" && typeof b === \"number\" && typeof c === \"number\" && typeof d === \"number\") {\n                this.ex.setNum(a, c);\n                this.ey.setNum(b, d);\n            } else if (typeof a === \"object\" && typeof b === \"object\") {\n                this.ex.setVec2(a);\n                this.ey.setVec2(b);\n            } else if (typeof a === \"object\") {\n                this.ex.setVec2(a.ex);\n                this.ey.setVec2(a.ey);\n            }\n        };\n        Mat22.prototype.setIdentity = function() {\n            this.ex.x = 1.0;\n            this.ey.x = 0.0;\n            this.ex.y = 0.0;\n            this.ey.y = 1.0;\n        };\n        Mat22.prototype.setZero = function() {\n            this.ex.x = 0.0;\n            this.ey.x = 0.0;\n            this.ex.y = 0.0;\n            this.ey.y = 0.0;\n        };\n        Mat22.prototype.getInverse = function() {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) det = 1.0 / det;\n            var imx = new Mat22();\n            imx.ex.x = det * d;\n            imx.ey.x = -det * b;\n            imx.ex.y = -det * c;\n            imx.ey.y = det * a;\n            return imx;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases.\n         */ Mat22.prototype.solve = function(v) {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) det = 1.0 / det;\n            var w = Vec2.zero();\n            w.x = det * (d * v.x - b * v.y);\n            w.y = det * (a * v.y - c * v.x);\n            return w;\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.mul = function(mx, v) {\n            if (v && \"x\" in v && \"y\" in v) {\n                var x = mx.ex.x * v.x + mx.ey.x * v.y;\n                var y = mx.ex.y * v.x + mx.ey.y * v.y;\n                return Vec2.neo(x, y);\n            } else if (v && \"ex\" in v && \"ey\" in v) {\n                // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n                var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n                var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n                var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n                var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n                return new Mat22(a, b, c, d);\n            }\n        };\n        Mat22.mulVec2 = function(mx, v) {\n            var x = mx.ex.x * v.x + mx.ey.x * v.y;\n            var y = mx.ex.y * v.x + mx.ey.y * v.y;\n            return Vec2.neo(x, y);\n        };\n        Mat22.mulMat22 = function(mx, v) {\n            // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n            var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n            var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n            var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n            var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n            return new Mat22(a, b, c, d);\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.mulT = function(mx, v) {\n            if (v && \"x\" in v && \"y\" in v) return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n            else if (v && \"ex\" in v && \"ey\" in v) {\n                var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n                var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n                return new Mat22(c1, c2);\n            }\n        };\n        Mat22.mulTVec2 = function(mx, v) {\n            return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n        };\n        Mat22.mulTMat22 = function(mx, v) {\n            var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n            var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n            return new Mat22(c1, c2);\n        };\n        Mat22.abs = function(mx) {\n            return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n        };\n        Mat22.add = function(mx1, mx2) {\n            return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n        };\n        return Mat22;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var ManifoldType;\n    (function(ManifoldType) {\n        ManifoldType[ManifoldType[\"e_circles\"] = 0] = \"e_circles\";\n        ManifoldType[ManifoldType[\"e_faceA\"] = 1] = \"e_faceA\";\n        ManifoldType[ManifoldType[\"e_faceB\"] = 2] = \"e_faceB\";\n    })(ManifoldType || (ManifoldType = {}));\n    var ContactFeatureType;\n    (function(ContactFeatureType) {\n        ContactFeatureType[ContactFeatureType[\"e_vertex\"] = 0] = \"e_vertex\";\n        ContactFeatureType[ContactFeatureType[\"e_face\"] = 1] = \"e_face\";\n    })(ContactFeatureType || (ContactFeatureType = {}));\n    /**\n     * This is used for determining the state of contact points.\n     */ var PointState;\n    (function(PointState) {\n        /** Point does not exist */ PointState[PointState[\"nullState\"] = 0] = \"nullState\";\n        /** Point was added in the update */ PointState[PointState[\"addState\"] = 1] = \"addState\";\n        /** Point persisted across the update */ PointState[PointState[\"persistState\"] = 2] = \"persistState\";\n        /** Point was removed in the update */ PointState[PointState[\"removeState\"] = 3] = \"removeState\";\n    })(PointState || (PointState = {}));\n    /**\n     * Used for computing contact manifolds.\n     */ var ClipVertex = /** @class */ function() {\n        function ClipVertex() {\n            this.v = Vec2.zero();\n            this.id = new ContactID();\n        }\n        ClipVertex.prototype.set = function(o) {\n            this.v.setVec2(o.v);\n            this.id.set(o.id);\n        };\n        return ClipVertex;\n    }();\n    /**\n     * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n     * method of Contact subclasses.\n     *\n     * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n     * with radius and e_circles point versus point with radius.\n     *\n     * We store contacts in this way so that position correction can account for\n     * movement, which is critical for continuous physics. All contact scenarios\n     * must be expressed in one of these types. This structure is stored across time\n     * steps, so we keep it small.\n     *\n     * @prop type e_circle, e_faceA, e_faceB\n     * @prop localPoint Usage depends on manifold type:<br>\n     *       e_circles: the local center of circleA <br>\n     *       e_faceA: the center of faceA <br>\n     *       e_faceB: the center of faceB\n     * @prop localNormal Usage depends on manifold type:<br>\n     *       e_circles: not used <br>\n     *       e_faceA: the normal on polygonA <br>\n     *       e_faceB: the normal on polygonB\n     * @prop points The points of contact {ManifoldPoint[]}\n     * @prop pointCount The number of manifold points\n     */ var Manifold = /** @class */ function() {\n        function Manifold() {\n            this.localNormal = Vec2.zero();\n            this.localPoint = Vec2.zero();\n            this.points = [\n                new ManifoldPoint(),\n                new ManifoldPoint()\n            ];\n            this.pointCount = 0;\n        }\n        /**\n         * Evaluate the manifold with supplied transforms. This assumes modest motion\n         * from the original state. This does not change the point count, impulses, etc.\n         * The radii must come from the shapes that generated the manifold.\n         */ Manifold.prototype.getWorldManifold = function(wm, xfA, radiusA, xfB, radiusB) {\n            if (this.pointCount == 0) return;\n            wm = wm || new WorldManifold();\n            var normal = wm.normal;\n            var points = wm.points;\n            var separations = wm.separations;\n            // TODO: improve\n            switch(this.type){\n                case ManifoldType.e_circles:\n                    normal = Vec2.neo(1.0, 0.0);\n                    var pointA = Transform.mulVec2(xfA, this.localPoint);\n                    var pointB = Transform.mulVec2(xfB, this.points[0].localPoint);\n                    var dist = Vec2.sub(pointB, pointA);\n                    if (Vec2.lengthSquared(dist) > math.EPSILON * math.EPSILON) {\n                        normal.setVec2(dist);\n                        normal.normalize();\n                    }\n                    var cA = pointA.clone().addMul(radiusA, normal);\n                    var cB = pointB.clone().addMul(-radiusB, normal);\n                    points[0] = Vec2.mid(cA, cB);\n                    separations[0] = Vec2.dot(Vec2.sub(cB, cA), normal);\n                    points.length = 1;\n                    separations.length = 1;\n                    break;\n                case ManifoldType.e_faceA:\n                    normal = Rot.mulVec2(xfA.q, this.localNormal);\n                    var planePoint = Transform.mulVec2(xfA, this.localPoint);\n                    for(var i = 0; i < this.pointCount; ++i){\n                        var clipPoint = Transform.mulVec2(xfB, this.points[i].localPoint);\n                        var cA = Vec2.clone(clipPoint).addMul(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n                        var cB = Vec2.clone(clipPoint).subMul(radiusB, normal);\n                        points[i] = Vec2.mid(cA, cB);\n                        separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);\n                    }\n                    points.length = this.pointCount;\n                    separations.length = this.pointCount;\n                    break;\n                case ManifoldType.e_faceB:\n                    normal = Rot.mulVec2(xfB.q, this.localNormal);\n                    var planePoint = Transform.mulVec2(xfB, this.localPoint);\n                    for(var i = 0; i < this.pointCount; ++i){\n                        var clipPoint = Transform.mulVec2(xfA, this.points[i].localPoint);\n                        var cB = Vec2.combine(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n                        var cA = Vec2.combine(1, clipPoint, -radiusA, normal);\n                        points[i] = Vec2.mid(cA, cB);\n                        separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);\n                    }\n                    points.length = this.pointCount;\n                    separations.length = this.pointCount;\n                    // Ensure normal points from A to B.\n                    normal.mul(-1);\n                    break;\n            }\n            wm.normal = normal;\n            wm.points = points;\n            wm.separations = separations;\n            return wm;\n        };\n        Manifold.clipSegmentToLine = clipSegmentToLine;\n        Manifold.ClipVertex = ClipVertex;\n        Manifold.getPointStates = getPointStates;\n        Manifold.PointState = PointState;\n        return Manifold;\n    }();\n    /**\n     * A manifold point is a contact point belonging to a contact manifold. It holds\n     * details related to the geometry and dynamics of the contact points.\n     *\n     * This structure is stored across time steps, so we keep it small.\n     *\n     * Note: impulses are used for internal caching and may not provide reliable\n     * contact forces, especially for high speed collisions.\n     */ var ManifoldPoint = /** @class */ function() {\n        function ManifoldPoint() {\n            /**\n             * Usage depends on manifold type.\n             *       e_circles: the local center of circleB,\n             *       e_faceA: the local center of cirlceB or the clip point of polygonB,\n             *       e_faceB: the clip point of polygonA.\n             */ this.localPoint = Vec2.zero();\n            /**\n             * The non-penetration impulse\n             */ this.normalImpulse = 0;\n            /**\n             * The friction impulse\n             */ this.tangentImpulse = 0;\n            /**\n             * Uniquely identifies a contact point between two shapes to facilatate warm starting\n             */ this.id = new ContactID();\n        }\n        return ManifoldPoint;\n    }();\n    /**\n     * Contact ids to facilitate warm starting.\n     */ var ContactID = /** @class */ function() {\n        function ContactID() {\n            this.cf = new ContactFeature();\n        }\n        Object.defineProperty(ContactID.prototype, \"key\", {\n            /**\n             * Used to quickly compare contact ids.\n             */ get: function() {\n                return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ContactID.prototype.set = function(o) {\n            // this.key = o.key;\n            this.cf.set(o.cf);\n        };\n        return ContactID;\n    }();\n    /**\n     * The features that intersect to form the contact point.\n     */ var ContactFeature = /** @class */ function() {\n        function ContactFeature() {}\n        ContactFeature.prototype.set = function(o) {\n            this.indexA = o.indexA;\n            this.indexB = o.indexB;\n            this.typeA = o.typeA;\n            this.typeB = o.typeB;\n        };\n        return ContactFeature;\n    }();\n    /**\n     * This is used to compute the current state of a contact manifold.\n     */ var WorldManifold = /** @class */ function() {\n        function WorldManifold() {\n            /**\n             * World contact point (point of intersection)\n             */ this.points = []; // [maxManifoldPoints]\n            /**\n             * A negative value indicates overlap, in meters\n             */ this.separations = []; // [maxManifoldPoints]\n        }\n        return WorldManifold;\n    }();\n    /**\n     * Compute the point states given two manifolds. The states pertain to the\n     * transition from manifold1 to manifold2. So state1 is either persist or remove\n     * while state2 is either add or persist.\n     */ function getPointStates(state1, state2, manifold1, manifold2) {\n        // state1, state2: PointState[Settings.maxManifoldPoints]\n        // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n        // state1[i] = PointState.nullState;\n        // state2[i] = PointState.nullState;\n        // }\n        // Detect persists and removes.\n        for(var i = 0; i < manifold1.pointCount; ++i){\n            var id = manifold1.points[i].id;\n            state1[i] = PointState.removeState;\n            for(var j = 0; j < manifold2.pointCount; ++j)if (manifold2.points[j].id.key == id.key) {\n                state1[i] = PointState.persistState;\n                break;\n            }\n        }\n        // Detect persists and adds.\n        for(var i = 0; i < manifold2.pointCount; ++i){\n            var id = manifold2.points[i].id;\n            state2[i] = PointState.addState;\n            for(var j = 0; j < manifold1.pointCount; ++j)if (manifold1.points[j].id.key == id.key) {\n                state2[i] = PointState.persistState;\n                break;\n            }\n        }\n    }\n    /**\n     * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n     */ function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {\n        // Start with no output points\n        var numOut = 0;\n        // Calculate the distance of end points to the line\n        var distance0 = Vec2.dot(normal, vIn[0].v) - offset;\n        var distance1 = Vec2.dot(normal, vIn[1].v) - offset;\n        // If the points are behind the plane\n        if (distance0 <= 0.0) vOut[numOut++].set(vIn[0]);\n        if (distance1 <= 0.0) vOut[numOut++].set(vIn[1]);\n        // If the points are on different sides of the plane\n        if (distance0 * distance1 < 0.0) {\n            // Find intersection point of edge and plane\n            var interp = distance0 / (distance0 - distance1);\n            vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);\n            // VertexA is hitting edgeB.\n            vOut[numOut].id.cf.indexA = vertexIndexA;\n            vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;\n            vOut[numOut].id.cf.typeA = ContactFeatureType.e_vertex;\n            vOut[numOut].id.cf.typeB = ContactFeatureType.e_face;\n            ++numOut;\n        }\n        return numOut;\n    }\n    var stats = {\n        gjkCalls: 0,\n        gjkIters: 0,\n        gjkMaxIters: 0,\n        toiTime: 0,\n        toiMaxTime: 0,\n        toiCalls: 0,\n        toiIters: 0,\n        toiMaxIters: 0,\n        toiRootIters: 0,\n        toiMaxRootIters: 0,\n        toString: function(newline) {\n            newline = typeof newline === \"string\" ? newline : \"\\n\";\n            var string = \"\";\n            // tslint:disable-next-line:no-for-in\n            for(var name_1 in this)if (typeof this[name_1] !== \"function\" && typeof this[name_1] !== \"object\") string += name_1 + \": \" + this[name_1] + newline;\n            return string;\n        }\n    };\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n     */ stats.gjkCalls = 0;\n    stats.gjkIters = 0;\n    stats.gjkMaxIters = 0;\n    /**\n     * Input for Distance. You have to option to use the shape radii in the\n     * computation. Even\n     */ var DistanceInput = /** @class */ function() {\n        function DistanceInput() {\n            this.proxyA = new DistanceProxy();\n            this.proxyB = new DistanceProxy();\n            this.transformA = null;\n            this.transformB = null;\n            this.useRadii = false;\n        }\n        return DistanceInput;\n    }();\n    /**\n     * Output for Distance.\n     *\n     * @prop {Vec2} pointA closest point on shapeA\n     * @prop {Vec2} pointB closest point on shapeB\n     * @prop distance\n     * @prop iterations number of GJK iterations used\n     */ var DistanceOutput = /** @class */ function() {\n        function DistanceOutput() {\n            this.pointA = Vec2.zero();\n            this.pointB = Vec2.zero();\n        }\n        return DistanceOutput;\n    }();\n    /**\n     * Used to warm start Distance. Set count to zero on first call.\n     *\n     * @prop {number} metric length or area\n     * @prop {array} indexA vertices on shape A\n     * @prop {array} indexB vertices on shape B\n     * @prop {number} count\n     */ var SimplexCache = /** @class */ function() {\n        function SimplexCache() {\n            this.metric = 0;\n            this.indexA = [];\n            this.indexB = [];\n            this.count = 0;\n        }\n        return SimplexCache;\n    }();\n    /**\n     * Compute the closest points between two shapes. Supports any combination of:\n     * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n     * the first call set SimplexCache.count to zero.\n     */ function Distance(output, cache, input) {\n        ++stats.gjkCalls;\n        var proxyA = input.proxyA;\n        var proxyB = input.proxyB;\n        var xfA = input.transformA;\n        var xfB = input.transformB;\n        // Initialize the simplex.\n        var simplex = new Simplex();\n        simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n        // Get simplex vertices as an array.\n        var vertices = simplex.m_v;\n        var k_maxIters = Settings.maxDistnceIterations;\n        // These store the vertices of the last simplex so that we\n        // can check for duplicates and prevent cycling.\n        var saveA = [];\n        var saveB = []; // int[3]\n        var saveCount = 0;\n        // Main iteration loop.\n        var iter = 0;\n        while(iter < k_maxIters){\n            // Copy simplex so we can identify duplicates.\n            saveCount = simplex.m_count;\n            for(var i = 0; i < saveCount; ++i){\n                saveA[i] = vertices[i].indexA;\n                saveB[i] = vertices[i].indexB;\n            }\n            simplex.solve();\n            // If we have 3 points, then the origin is in the corresponding triangle.\n            if (simplex.m_count === 3) break;\n            // Compute closest point.\n            var p = simplex.getClosestPoint();\n            p.lengthSquared();\n            // Get search direction.\n            var d = simplex.getSearchDirection();\n            // Ensure the search direction is numerically fit.\n            if (d.lengthSquared() < math.EPSILON * math.EPSILON) break;\n            // Compute a tentative new simplex vertex using support points.\n            var vertex = vertices[simplex.m_count]; // SimplexVertex\n            vertex.indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(d)));\n            vertex.wA = Transform.mulVec2(xfA, proxyA.getVertex(vertex.indexA));\n            vertex.indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, d));\n            vertex.wB = Transform.mulVec2(xfB, proxyB.getVertex(vertex.indexB));\n            vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n            // Iteration count is equated to the number of support point calls.\n            ++iter;\n            ++stats.gjkIters;\n            // Check for duplicate support points. This is the main termination\n            // criteria.\n            var duplicate = false;\n            for(var i = 0; i < saveCount; ++i)if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n                duplicate = true;\n                break;\n            }\n            // If we found a duplicate support point we must exit to avoid cycling.\n            if (duplicate) break;\n            // New vertex is ok and needed.\n            ++simplex.m_count;\n        }\n        stats.gjkMaxIters = math.max(stats.gjkMaxIters, iter);\n        // Prepare output.\n        simplex.getWitnessPoints(output.pointA, output.pointB);\n        output.distance = Vec2.distance(output.pointA, output.pointB);\n        output.iterations = iter;\n        // Cache the simplex.\n        simplex.writeCache(cache);\n        // Apply radii if requested.\n        if (input.useRadii) {\n            var rA = proxyA.m_radius;\n            var rB = proxyB.m_radius;\n            if (output.distance > rA + rB && output.distance > math.EPSILON) {\n                // Shapes are still no overlapped.\n                // Move the witness points to the outer surface.\n                output.distance -= rA + rB;\n                var normal = Vec2.sub(output.pointB, output.pointA);\n                normal.normalize();\n                output.pointA.addMul(rA, normal);\n                output.pointB.subMul(rB, normal);\n            } else {\n                // Shapes are overlapped when radii are considered.\n                // Move the witness points to the middle.\n                var p = Vec2.mid(output.pointA, output.pointB);\n                output.pointA.setVec2(p);\n                output.pointB.setVec2(p);\n                output.distance = 0.0;\n            }\n        }\n    }\n    /**\n     * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n     */ var DistanceProxy = /** @class */ function() {\n        function DistanceProxy() {\n            this.m_buffer = []; // Vec2[2]\n            this.m_vertices = []; // Vec2[]\n            this.m_count = 0;\n            this.m_radius = 0;\n        }\n        /**\n         * Get the vertex count.\n         */ DistanceProxy.prototype.getVertexCount = function() {\n            return this.m_count;\n        };\n        /**\n         * Get a vertex by index. Used by Distance.\n         */ DistanceProxy.prototype.getVertex = function(index) {\n            return this.m_vertices[index];\n        };\n        /**\n         * Get the supporting vertex index in the given direction.\n         */ DistanceProxy.prototype.getSupport = function(d) {\n            var bestIndex = 0;\n            var bestValue = Vec2.dot(this.m_vertices[0], d);\n            for(var i = 0; i < this.m_count; ++i){\n                var value = Vec2.dot(this.m_vertices[i], d);\n                if (value > bestValue) {\n                    bestIndex = i;\n                    bestValue = value;\n                }\n            }\n            return bestIndex;\n        };\n        /**\n         * Get the supporting vertex in the given direction.\n         */ DistanceProxy.prototype.getSupportVertex = function(d) {\n            return this.m_vertices[this.getSupport(d)];\n        };\n        /**\n         * Initialize the proxy using the given shape. The shape must remain in scope\n         * while the proxy is in use.\n         */ DistanceProxy.prototype.set = function(shape, index) {\n            shape.computeDistanceProxy(this, index);\n        };\n        return DistanceProxy;\n    }();\n    var SimplexVertex = /** @class */ function() {\n        function SimplexVertex() {\n            /** support point in proxyA */ this.wA = Vec2.zero();\n            /** support point in proxyB */ this.wB = Vec2.zero();\n            /** wB - wA; */ this.w = Vec2.zero();\n        }\n        SimplexVertex.prototype.set = function(v) {\n            this.indexA = v.indexA;\n            this.indexB = v.indexB;\n            this.wA = Vec2.clone(v.wA);\n            this.wB = Vec2.clone(v.wB);\n            this.w = Vec2.clone(v.w);\n            this.a = v.a;\n        };\n        return SimplexVertex;\n    }();\n    var Simplex = /** @class */ function() {\n        function Simplex() {\n            this.m_v1 = new SimplexVertex();\n            this.m_v2 = new SimplexVertex();\n            this.m_v3 = new SimplexVertex();\n            this.m_v = [\n                this.m_v1,\n                this.m_v2,\n                this.m_v3\n            ];\n            this.m_count;\n        }\n        /** @internal */ Simplex.prototype.toString = function() {\n            if (this.m_count === 3) return [\n                \"+\" + this.m_count,\n                this.m_v1.a,\n                this.m_v1.wA.x,\n                this.m_v1.wA.y,\n                this.m_v1.wB.x,\n                this.m_v1.wB.y,\n                this.m_v2.a,\n                this.m_v2.wA.x,\n                this.m_v2.wA.y,\n                this.m_v2.wB.x,\n                this.m_v2.wB.y,\n                this.m_v3.a,\n                this.m_v3.wA.x,\n                this.m_v3.wA.y,\n                this.m_v3.wB.x,\n                this.m_v3.wB.y\n            ].toString();\n            else if (this.m_count === 2) return [\n                \"+\" + this.m_count,\n                this.m_v1.a,\n                this.m_v1.wA.x,\n                this.m_v1.wA.y,\n                this.m_v1.wB.x,\n                this.m_v1.wB.y,\n                this.m_v2.a,\n                this.m_v2.wA.x,\n                this.m_v2.wA.y,\n                this.m_v2.wB.x,\n                this.m_v2.wB.y\n            ].toString();\n            else if (this.m_count === 1) return [\n                \"+\" + this.m_count,\n                this.m_v1.a,\n                this.m_v1.wA.x,\n                this.m_v1.wA.y,\n                this.m_v1.wB.x,\n                this.m_v1.wB.y\n            ].toString();\n            else return \"+\" + this.m_count;\n        };\n        Simplex.prototype.readCache = function(cache, proxyA, transformA, proxyB, transformB) {\n            // Copy data from cache.\n            this.m_count = cache.count;\n            for(var i = 0; i < this.m_count; ++i){\n                var v = this.m_v[i];\n                v.indexA = cache.indexA[i];\n                v.indexB = cache.indexB[i];\n                var wALocal = proxyA.getVertex(v.indexA);\n                var wBLocal = proxyB.getVertex(v.indexB);\n                v.wA = Transform.mulVec2(transformA, wALocal);\n                v.wB = Transform.mulVec2(transformB, wBLocal);\n                v.w = Vec2.sub(v.wB, v.wA);\n                v.a = 0.0;\n            }\n            // Compute the new simplex metric, if it is substantially different than\n            // old metric then flush the simplex.\n            if (this.m_count > 1) {\n                var metric1 = cache.metric;\n                var metric2 = this.getMetric();\n                if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2 || metric2 < math.EPSILON) // Reset the simplex.\n                this.m_count = 0;\n            }\n            // If the cache is empty or invalid...\n            if (this.m_count === 0) {\n                var v = this.m_v[0];\n                v.indexA = 0;\n                v.indexB = 0;\n                var wALocal = proxyA.getVertex(0);\n                var wBLocal = proxyB.getVertex(0);\n                v.wA = Transform.mulVec2(transformA, wALocal);\n                v.wB = Transform.mulVec2(transformB, wBLocal);\n                v.w = Vec2.sub(v.wB, v.wA);\n                v.a = 1.0;\n                this.m_count = 1;\n            }\n        };\n        Simplex.prototype.writeCache = function(cache) {\n            cache.metric = this.getMetric();\n            cache.count = this.m_count;\n            for(var i = 0; i < this.m_count; ++i){\n                cache.indexA[i] = this.m_v[i].indexA;\n                cache.indexB[i] = this.m_v[i].indexB;\n            }\n        };\n        Simplex.prototype.getSearchDirection = function() {\n            switch(this.m_count){\n                case 1:\n                    return Vec2.neg(this.m_v1.w);\n                case 2:\n                    var e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);\n                    var sgn = Vec2.crossVec2Vec2(e12, Vec2.neg(this.m_v1.w));\n                    if (sgn > 0.0) // Origin is left of e12.\n                    return Vec2.crossNumVec2(1.0, e12);\n                    else // Origin is right of e12.\n                    return Vec2.crossVec2Num(e12, 1.0);\n                default:\n                    return Vec2.zero();\n            }\n        };\n        Simplex.prototype.getClosestPoint = function() {\n            switch(this.m_count){\n                case 0:\n                    return Vec2.zero();\n                case 1:\n                    return Vec2.clone(this.m_v1.w);\n                case 2:\n                    return Vec2.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);\n                case 3:\n                    return Vec2.zero();\n                default:\n                    return Vec2.zero();\n            }\n        };\n        Simplex.prototype.getWitnessPoints = function(pA, pB) {\n            switch(this.m_count){\n                case 0:\n                    break;\n                case 1:\n                    pA.setVec2(this.m_v1.wA);\n                    pB.setVec2(this.m_v1.wB);\n                    break;\n                case 2:\n                    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n                    pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);\n                    break;\n                case 3:\n                    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n                    pA.addMul(this.m_v3.a, this.m_v3.wA);\n                    pB.setVec2(pA);\n                    break;\n            }\n        };\n        Simplex.prototype.getMetric = function() {\n            switch(this.m_count){\n                case 0:\n                    return 0.0;\n                case 1:\n                    return 0.0;\n                case 2:\n                    return Vec2.distance(this.m_v1.w, this.m_v2.w);\n                case 3:\n                    return Vec2.crossVec2Vec2(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w, this.m_v1.w));\n                default:\n                    return 0.0;\n            }\n        };\n        Simplex.prototype.solve = function() {\n            switch(this.m_count){\n                case 1:\n                    break;\n                case 2:\n                    this.solve2();\n                    break;\n                case 3:\n                    this.solve3();\n                    break;\n            }\n        };\n        // Solve a line segment using barycentric coordinates.\n        //\n        // p = a1 * w1 + a2 * w2\n        // a1 + a2 = 1\n        //\n        // The vector from the origin to the closest point on the line is\n        // perpendicular to the line.\n        // e12 = w2 - w1\n        // dot(p, e) = 0\n        // a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n        //\n        // 2-by-2 linear system\n        // [1 1 ][a1] = [1]\n        // [w1.e12 w2.e12][a2] = [0]\n        //\n        // Define\n        // d12_1 = dot(w2, e12)\n        // d12_2 = -dot(w1, e12)\n        // d12 = d12_1 + d12_2\n        //\n        // Solution\n        // a1 = d12_1 / d12\n        // a2 = d12_2 / d12\n        Simplex.prototype.solve2 = function() {\n            var w1 = this.m_v1.w;\n            var w2 = this.m_v2.w;\n            var e12 = Vec2.sub(w2, w1);\n            // w1 region\n            var d12_2 = -Vec2.dot(w1, e12);\n            if (d12_2 <= 0.0) {\n                // a2 <= 0, so we clamp it to 0\n                this.m_v1.a = 1.0;\n                this.m_count = 1;\n                return;\n            }\n            // w2 region\n            var d12_1 = Vec2.dot(w2, e12);\n            if (d12_1 <= 0.0) {\n                // a1 <= 0, so we clamp it to 0\n                this.m_v2.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v2);\n                return;\n            }\n            // Must be in e12 region.\n            var inv_d12 = 1.0 / (d12_1 + d12_2);\n            this.m_v1.a = d12_1 * inv_d12;\n            this.m_v2.a = d12_2 * inv_d12;\n            this.m_count = 2;\n        };\n        // Possible regions:\n        // - points[2]\n        // - edge points[0]-points[2]\n        // - edge points[1]-points[2]\n        // - inside the triangle\n        Simplex.prototype.solve3 = function() {\n            var w1 = this.m_v1.w;\n            var w2 = this.m_v2.w;\n            var w3 = this.m_v3.w;\n            // Edge12\n            // [1 1 ][a1] = [1]\n            // [w1.e12 w2.e12][a2] = [0]\n            // a3 = 0\n            var e12 = Vec2.sub(w2, w1);\n            var w1e12 = Vec2.dot(w1, e12);\n            var w2e12 = Vec2.dot(w2, e12);\n            var d12_1 = w2e12;\n            var d12_2 = -w1e12;\n            // Edge13\n            // [1 1 ][a1] = [1]\n            // [w1.e13 w3.e13][a3] = [0]\n            // a2 = 0\n            var e13 = Vec2.sub(w3, w1);\n            var w1e13 = Vec2.dot(w1, e13);\n            var w3e13 = Vec2.dot(w3, e13);\n            var d13_1 = w3e13;\n            var d13_2 = -w1e13;\n            // Edge23\n            // [1 1 ][a2] = [1]\n            // [w2.e23 w3.e23][a3] = [0]\n            // a1 = 0\n            var e23 = Vec2.sub(w3, w2);\n            var w2e23 = Vec2.dot(w2, e23);\n            var w3e23 = Vec2.dot(w3, e23);\n            var d23_1 = w3e23;\n            var d23_2 = -w2e23;\n            // Triangle123\n            var n123 = Vec2.crossVec2Vec2(e12, e13);\n            var d123_1 = n123 * Vec2.crossVec2Vec2(w2, w3);\n            var d123_2 = n123 * Vec2.crossVec2Vec2(w3, w1);\n            var d123_3 = n123 * Vec2.crossVec2Vec2(w1, w2);\n            // w1 region\n            if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n                this.m_v1.a = 1.0;\n                this.m_count = 1;\n                return;\n            }\n            // e12\n            if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n                var inv_d12 = 1.0 / (d12_1 + d12_2);\n                this.m_v1.a = d12_1 * inv_d12;\n                this.m_v2.a = d12_2 * inv_d12;\n                this.m_count = 2;\n                return;\n            }\n            // e13\n            if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n                var inv_d13 = 1.0 / (d13_1 + d13_2);\n                this.m_v1.a = d13_1 * inv_d13;\n                this.m_v3.a = d13_2 * inv_d13;\n                this.m_count = 2;\n                this.m_v2.set(this.m_v3);\n                return;\n            }\n            // w2 region\n            if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n                this.m_v2.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v2);\n                return;\n            }\n            // w3 region\n            if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n                this.m_v3.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v3);\n                return;\n            }\n            // e23\n            if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n                var inv_d23 = 1.0 / (d23_1 + d23_2);\n                this.m_v2.a = d23_1 * inv_d23;\n                this.m_v3.a = d23_2 * inv_d23;\n                this.m_count = 2;\n                this.m_v1.set(this.m_v3);\n                return;\n            }\n            // Must be in triangle123\n            var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n            this.m_v1.a = d123_1 * inv_d123;\n            this.m_v2.a = d123_2 * inv_d123;\n            this.m_v3.a = d123_3 * inv_d123;\n            this.m_count = 3;\n        };\n        return Simplex;\n    }();\n    /**\n     * Determine if two generic shapes overlap.\n     */ function testOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB) {\n        var input = new DistanceInput();\n        input.proxyA.set(shapeA, indexA);\n        input.proxyB.set(shapeB, indexB);\n        input.transformA = xfA;\n        input.transformB = xfB;\n        input.useRadii = true;\n        var cache = new SimplexCache();\n        var output = new DistanceOutput();\n        Distance(output, cache, input);\n        return output.distance < 10.0 * math.EPSILON;\n    }\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A contact edge is used to connect bodies and contacts together in a contact\n     * graph where each body is a node and each contact is an edge. A contact edge\n     * belongs to a doubly linked list maintained in each attached body. Each\n     * contact has two contact nodes, one for each attached body.\n     *\n     * @prop {Contact} contact The contact\n     * @prop {ContactEdge} prev The previous contact edge in the body's contact list\n     * @prop {ContactEdge} next The next contact edge in the body's contact list\n     * @prop {Body} other Provides quick access to the other body attached.\n     */ var ContactEdge = /** @class */ function() {\n        function ContactEdge(contact) {\n            this.contact = contact;\n        }\n        return ContactEdge;\n    }();\n    /**\n     * Friction mixing law. The idea is to allow either fixture to drive the\n     * restitution to zero. For example, anything slides on ice.\n     */ function mixFriction(friction1, friction2) {\n        return math.sqrt(friction1 * friction2);\n    }\n    /**\n     * Restitution mixing law. The idea is allow for anything to bounce off an\n     * inelastic surface. For example, a superball bounces on anything.\n     */ function mixRestitution(restitution1, restitution2) {\n        return restitution1 > restitution2 ? restitution1 : restitution2;\n    }\n    // TODO: move this to Settings?\n    var s_registers = [];\n    // TODO: merge with ManifoldPoint?\n    var VelocityConstraintPoint = /** @class */ function() {\n        function VelocityConstraintPoint() {\n            this.rA = Vec2.zero();\n            this.rB = Vec2.zero();\n            this.normalImpulse = 0;\n            this.tangentImpulse = 0;\n            this.normalMass = 0;\n            this.tangentMass = 0;\n            this.velocityBias = 0;\n        }\n        return VelocityConstraintPoint;\n    }();\n    /**\n     * The class manages contact between two shapes. A contact exists for each\n     * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n     * object may exist that has no contact points.\n     */ var Contact = /** @class */ function() {\n        function Contact(fA, indexA, fB, indexB, evaluateFcn) {\n            /** @internal */ this.m_manifold = new Manifold();\n            /** @internal */ this.m_prev = null;\n            /** @internal */ this.m_next = null;\n            /** @internal */ this.m_toi = 1.0;\n            /** @internal */ this.m_toiCount = 0;\n            /** @internal This contact has a valid TOI in m_toi */ this.m_toiFlag = false;\n            /** @internal */ this.m_tangentSpeed = 0.0;\n            /** @internal This contact can be disabled (by user) */ this.m_enabledFlag = true;\n            /** @internal Used when crawling contact graph when forming islands. */ this.m_islandFlag = false;\n            /** @internal Set when the shapes are touching. */ this.m_touchingFlag = false;\n            /** @internal This contact needs filtering because a fixture filter was changed. */ this.m_filterFlag = false;\n            /** @internal This bullet contact had a TOI event */ this.m_bulletHitFlag = false;\n            /** @internal Contact reporting impulse object cache */ this.m_impulse = new ContactImpulse(this);\n            // VelocityConstraint\n            /** @internal */ this.v_points = []; // [maxManifoldPoints];\n            /** @internal */ this.v_normal = Vec2.zero();\n            /** @internal */ this.v_normalMass = new Mat22();\n            /** @internal */ this.v_K = new Mat22();\n            // PositionConstraint\n            /** @internal */ this.p_localPoints = []; // [maxManifoldPoints];\n            /** @internal */ this.p_localNormal = Vec2.zero();\n            /** @internal */ this.p_localPoint = Vec2.zero();\n            /** @internal */ this.p_localCenterA = Vec2.zero();\n            /** @internal */ this.p_localCenterB = Vec2.zero();\n            // Nodes for connecting bodies.\n            this.m_nodeA = new ContactEdge(this);\n            this.m_nodeB = new ContactEdge(this);\n            this.m_fixtureA = fA;\n            this.m_fixtureB = fB;\n            this.m_indexA = indexA;\n            this.m_indexB = indexB;\n            this.m_evaluateFcn = evaluateFcn;\n            this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n            this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n        }\n        Contact.prototype.initConstraint = function(step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var shapeA = fixtureA.getShape();\n            var shapeB = fixtureB.getShape();\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var manifold = this.getManifold();\n            var pointCount = manifold.pointCount;\n            this.v_invMassA = bodyA.m_invMass;\n            this.v_invMassB = bodyB.m_invMass;\n            this.v_invIA = bodyA.m_invI;\n            this.v_invIB = bodyB.m_invI;\n            this.v_friction = this.m_friction;\n            this.v_restitution = this.m_restitution;\n            this.v_tangentSpeed = this.m_tangentSpeed;\n            this.v_pointCount = pointCount;\n            this.v_K.setZero();\n            this.v_normalMass.setZero();\n            this.p_invMassA = bodyA.m_invMass;\n            this.p_invMassB = bodyB.m_invMass;\n            this.p_invIA = bodyA.m_invI;\n            this.p_invIB = bodyB.m_invI;\n            this.p_localCenterA = Vec2.clone(bodyA.m_sweep.localCenter);\n            this.p_localCenterB = Vec2.clone(bodyB.m_sweep.localCenter);\n            this.p_radiusA = shapeA.m_radius;\n            this.p_radiusB = shapeB.m_radius;\n            this.p_type = manifold.type;\n            this.p_localNormal = Vec2.clone(manifold.localNormal);\n            this.p_localPoint = Vec2.clone(manifold.localPoint);\n            this.p_pointCount = pointCount;\n            for(var j = 0; j < pointCount; ++j){\n                var cp = manifold.points[j];\n                var vcp = this.v_points[j] = new VelocityConstraintPoint();\n                if (step.warmStarting) {\n                    vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n                    vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n                } else {\n                    vcp.normalImpulse = 0.0;\n                    vcp.tangentImpulse = 0.0;\n                }\n                vcp.rA.setZero();\n                vcp.rB.setZero();\n                vcp.normalMass = 0.0;\n                vcp.tangentMass = 0.0;\n                vcp.velocityBias = 0.0;\n                this.p_localPoints[j] = Vec2.clone(cp.localPoint);\n            }\n        };\n        /**\n         * Get the contact manifold. Do not modify the manifold unless you understand\n         * the internals of the library.\n         */ Contact.prototype.getManifold = function() {\n            return this.m_manifold;\n        };\n        /**\n         * Get the world manifold.\n         */ Contact.prototype.getWorldManifold = function(worldManifold) {\n            var bodyA = this.m_fixtureA.getBody();\n            var bodyB = this.m_fixtureB.getBody();\n            var shapeA = this.m_fixtureA.getShape();\n            var shapeB = this.m_fixtureB.getShape();\n            return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);\n        };\n        /**\n         * Enable/disable this contact. This can be used inside the pre-solve contact\n         * listener. The contact is only disabled for the current time step (or sub-step\n         * in continuous collisions).\n         */ Contact.prototype.setEnabled = function(flag) {\n            this.m_enabledFlag = !!flag;\n        };\n        /**\n         * Has this contact been disabled?\n         */ Contact.prototype.isEnabled = function() {\n            return this.m_enabledFlag;\n        };\n        /**\n         * Is this contact touching?\n         */ Contact.prototype.isTouching = function() {\n            return this.m_touchingFlag;\n        };\n        /**\n         * Get the next contact in the world's contact list.\n         */ Contact.prototype.getNext = function() {\n            return this.m_next;\n        };\n        /**\n         * Get fixture A in this contact.\n         */ Contact.prototype.getFixtureA = function() {\n            return this.m_fixtureA;\n        };\n        /**\n         * Get fixture B in this contact.\n         */ Contact.prototype.getFixtureB = function() {\n            return this.m_fixtureB;\n        };\n        /**\n         * Get the child primitive index for fixture A.\n         */ Contact.prototype.getChildIndexA = function() {\n            return this.m_indexA;\n        };\n        /**\n         * Get the child primitive index for fixture B.\n         */ Contact.prototype.getChildIndexB = function() {\n            return this.m_indexB;\n        };\n        /**\n         * Flag this contact for filtering. Filtering will occur the next time step.\n         */ Contact.prototype.flagForFiltering = function() {\n            this.m_filterFlag = true;\n        };\n        /**\n         * Override the default friction mixture. You can call this in\n         * ContactListener.preSolve. This value persists until set or reset.\n         */ Contact.prototype.setFriction = function(friction) {\n            this.m_friction = friction;\n        };\n        /**\n         * Get the friction.\n         */ Contact.prototype.getFriction = function() {\n            return this.m_friction;\n        };\n        /**\n         * Reset the friction mixture to the default value.\n         */ Contact.prototype.resetFriction = function() {\n            this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n        };\n        /**\n         * Override the default restitution mixture. You can call this in\n         * ContactListener.preSolve. The value persists until you set or reset.\n         */ Contact.prototype.setRestitution = function(restitution) {\n            this.m_restitution = restitution;\n        };\n        /**\n         * Get the restitution.\n         */ Contact.prototype.getRestitution = function() {\n            return this.m_restitution;\n        };\n        /**\n         * Reset the restitution to the default value.\n         */ Contact.prototype.resetRestitution = function() {\n            this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n        };\n        /**\n         * Set the desired tangent speed for a conveyor belt behavior. In meters per\n         * second.\n         */ Contact.prototype.setTangentSpeed = function(speed) {\n            this.m_tangentSpeed = speed;\n        };\n        /**\n         * Get the desired tangent speed. In meters per second.\n         */ Contact.prototype.getTangentSpeed = function() {\n            return this.m_tangentSpeed;\n        };\n        /**\n         * Called by Update method, and implemented by subclasses.\n         */ Contact.prototype.evaluate = function(manifold, xfA, xfB) {\n            this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB, this.m_fixtureB, this.m_indexB);\n        };\n        /**\n         * Updates the contact manifold and touching status.\n         *\n         * Note: do not assume the fixture AABBs are overlapping or are valid.\n         *\n         * @param listener.beginContact\n         * @param listener.endContact\n         * @param listener.preSolve\n         */ Contact.prototype.update = function(listener) {\n            // Re-enable this contact.\n            this.m_enabledFlag = true;\n            var touching = false;\n            var wasTouching = this.m_touchingFlag;\n            var sensorA = this.m_fixtureA.isSensor();\n            var sensorB = this.m_fixtureB.isSensor();\n            var sensor = sensorA || sensorB;\n            var bodyA = this.m_fixtureA.getBody();\n            var bodyB = this.m_fixtureB.getBody();\n            var xfA = bodyA.getTransform();\n            var xfB = bodyB.getTransform();\n            var oldManifold;\n            // Is this contact a sensor?\n            if (sensor) {\n                var shapeA = this.m_fixtureA.getShape();\n                var shapeB = this.m_fixtureB.getShape();\n                touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n                // Sensors don't generate manifolds.\n                this.m_manifold.pointCount = 0;\n            } else {\n                // TODO reuse manifold\n                oldManifold = this.m_manifold;\n                this.m_manifold = new Manifold();\n                this.evaluate(this.m_manifold, xfA, xfB);\n                touching = this.m_manifold.pointCount > 0;\n                // Match old contact ids to new contact ids and copy the\n                // stored impulses to warm start the solver.\n                for(var i = 0; i < this.m_manifold.pointCount; ++i){\n                    var nmp = this.m_manifold.points[i];\n                    nmp.normalImpulse = 0.0;\n                    nmp.tangentImpulse = 0.0;\n                    for(var j = 0; j < oldManifold.pointCount; ++j){\n                        var omp = oldManifold.points[j];\n                        if (omp.id.key == nmp.id.key) {\n                            nmp.normalImpulse = omp.normalImpulse;\n                            nmp.tangentImpulse = omp.tangentImpulse;\n                            break;\n                        }\n                    }\n                }\n                if (touching != wasTouching) {\n                    bodyA.setAwake(true);\n                    bodyB.setAwake(true);\n                }\n            }\n            this.m_touchingFlag = touching;\n            if (!wasTouching && touching && listener) listener.beginContact(this);\n            if (wasTouching && !touching && listener) listener.endContact(this);\n            if (!sensor && touching && listener) listener.preSolve(this, oldManifold);\n        };\n        Contact.prototype.solvePositionConstraint = function(step) {\n            return this._solvePositionConstraint(step);\n        };\n        Contact.prototype.solvePositionConstraintTOI = function(step, toiA, toiB) {\n            return this._solvePositionConstraint(step, toiA, toiB);\n        };\n        Contact.prototype._solvePositionConstraint = function(step, toiA, toiB) {\n            var toi = !!toiA && !!toiB;\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            bodyA.c_velocity;\n            bodyB.c_velocity;\n            var positionA = bodyA.c_position;\n            var positionB = bodyB.c_position;\n            var localCenterA = Vec2.clone(this.p_localCenterA);\n            var localCenterB = Vec2.clone(this.p_localCenterB);\n            var mA = 0.0;\n            var iA = 0.0;\n            if (!toi || bodyA == toiA || bodyA == toiB) {\n                mA = this.p_invMassA;\n                iA = this.p_invIA;\n            }\n            var mB = 0.0;\n            var iB = 0.0;\n            if (!toi || bodyB == toiA || bodyB == toiB) {\n                mB = this.p_invMassB;\n                iB = this.p_invIB;\n            }\n            var cA = Vec2.clone(positionA.c);\n            var aA = positionA.a;\n            var cB = Vec2.clone(positionB.c);\n            var aB = positionB.a;\n            var minSeparation = 0.0;\n            // Solve normal constraints\n            for(var j = 0; j < this.p_pointCount; ++j){\n                var xfA = Transform.identity();\n                var xfB = Transform.identity();\n                xfA.q.setAngle(aA);\n                xfB.q.setAngle(aB);\n                xfA.p = Vec2.sub(cA, Rot.mulVec2(xfA.q, localCenterA));\n                xfB.p = Vec2.sub(cB, Rot.mulVec2(xfB.q, localCenterB));\n                // PositionSolverManifold\n                var normal = void 0;\n                var point = void 0;\n                var separation = void 0;\n                switch(this.p_type){\n                    case ManifoldType.e_circles:\n                        var pointA = Transform.mulVec2(xfA, this.p_localPoint);\n                        var pointB = Transform.mulVec2(xfB, this.p_localPoints[0]);\n                        normal = Vec2.sub(pointB, pointA);\n                        normal.normalize();\n                        point = Vec2.combine(0.5, pointA, 0.5, pointB);\n                        separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA - this.p_radiusB;\n                        break;\n                    case ManifoldType.e_faceA:\n                        normal = Rot.mulVec2(xfA.q, this.p_localNormal);\n                        var planePoint = Transform.mulVec2(xfA, this.p_localPoint);\n                        var clipPoint = Transform.mulVec2(xfB, this.p_localPoints[j]);\n                        separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n                        point = clipPoint;\n                        break;\n                    case ManifoldType.e_faceB:\n                        normal = Rot.mulVec2(xfB.q, this.p_localNormal);\n                        var planePoint = Transform.mulVec2(xfB, this.p_localPoint);\n                        var clipPoint = Transform.mulVec2(xfA, this.p_localPoints[j]);\n                        separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n                        point = clipPoint;\n                        // Ensure normal points from A to B\n                        normal.mul(-1);\n                        break;\n                }\n                var rA = Vec2.sub(point, cA);\n                var rB = Vec2.sub(point, cB);\n                // Track max constraint error.\n                minSeparation = math.min(minSeparation, separation);\n                var baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n                var linearSlop = Settings.linearSlop;\n                var maxLinearCorrection = Settings.maxLinearCorrection;\n                // Prevent large corrections and allow slop.\n                var C = math.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n                // Compute the effective mass.\n                var rnA = Vec2.crossVec2Vec2(rA, normal);\n                var rnB = Vec2.crossVec2Vec2(rB, normal);\n                var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n                // Compute normal impulse\n                var impulse = K > 0.0 ? -C / K : 0.0;\n                var P = Vec2.mulNumVec2(impulse, normal);\n                cA.subMul(mA, P);\n                aA -= iA * Vec2.crossVec2Vec2(rA, P);\n                cB.addMul(mB, P);\n                aB += iB * Vec2.crossVec2Vec2(rB, P);\n            }\n            positionA.c.setVec2(cA);\n            positionA.a = aA;\n            positionB.c.setVec2(cB);\n            positionB.a = aB;\n            return minSeparation;\n        };\n        Contact.prototype.initVelocityConstraint = function(step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var velocityA = bodyA.c_velocity;\n            var velocityB = bodyB.c_velocity;\n            var positionA = bodyA.c_position;\n            var positionB = bodyB.c_position;\n            var radiusA = this.p_radiusA;\n            var radiusB = this.p_radiusB;\n            var manifold = this.getManifold();\n            var mA = this.v_invMassA;\n            var mB = this.v_invMassB;\n            var iA = this.v_invIA;\n            var iB = this.v_invIB;\n            var localCenterA = Vec2.clone(this.p_localCenterA);\n            var localCenterB = Vec2.clone(this.p_localCenterB);\n            var cA = Vec2.clone(positionA.c);\n            var aA = positionA.a;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var cB = Vec2.clone(positionB.c);\n            var aB = positionB.a;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            xfA.q.setAngle(aA);\n            xfB.q.setAngle(aB);\n            xfA.p.setCombine(1, cA, -1, Rot.mulVec2(xfA.q, localCenterA));\n            xfB.p.setCombine(1, cB, -1, Rot.mulVec2(xfB.q, localCenterB));\n            var worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);\n            this.v_normal.setVec2(worldManifold.normal);\n            for(var j = 0; j < this.v_pointCount; ++j){\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                vcp.rA.setVec2(Vec2.sub(worldManifold.points[j], cA));\n                vcp.rB.setVec2(Vec2.sub(worldManifold.points[j], cB));\n                var rnA = Vec2.crossVec2Vec2(vcp.rA, this.v_normal);\n                var rnB = Vec2.crossVec2Vec2(vcp.rB, this.v_normal);\n                var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n                vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n                var tangent = Vec2.crossVec2Num(this.v_normal, 1.0);\n                var rtA = Vec2.crossVec2Vec2(vcp.rA, tangent);\n                var rtB = Vec2.crossVec2Vec2(vcp.rB, tangent);\n                var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n                vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n                // Setup a velocity bias for restitution.\n                vcp.velocityBias = 0.0;\n                var vRel = Vec2.dot(this.v_normal, vB) + Vec2.dot(this.v_normal, Vec2.crossNumVec2(wB, vcp.rB)) - Vec2.dot(this.v_normal, vA) - Vec2.dot(this.v_normal, Vec2.crossNumVec2(wA, vcp.rA));\n                if (vRel < -Settings.velocityThreshold) vcp.velocityBias = -this.v_restitution * vRel;\n            }\n            // If we have two points, then prepare the block solver.\n            if (this.v_pointCount == 2 && step.blockSolve) {\n                var vcp1 = this.v_points[0]; // VelocityConstraintPoint\n                var vcp2 = this.v_points[1]; // VelocityConstraintPoint\n                var rn1A = Vec2.crossVec2Vec2(vcp1.rA, this.v_normal);\n                var rn1B = Vec2.crossVec2Vec2(vcp1.rB, this.v_normal);\n                var rn2A = Vec2.crossVec2Vec2(vcp2.rA, this.v_normal);\n                var rn2B = Vec2.crossVec2Vec2(vcp2.rB, this.v_normal);\n                var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n                var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n                var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n                // Ensure a reasonable condition number.\n                var k_maxConditionNumber = 1000.0;\n                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n                    // K is safe to invert.\n                    this.v_K.ex.setNum(k11, k12);\n                    this.v_K.ey.setNum(k12, k22);\n                    this.v_normalMass.set(this.v_K.getInverse());\n                } else // The constraints are redundant, just use one.\n                // TODO_ERIN use deepest?\n                this.v_pointCount = 1;\n            }\n            positionA.c.setVec2(cA);\n            positionA.a = aA;\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            positionB.c.setVec2(cB);\n            positionB.a = aB;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        Contact.prototype.warmStartConstraint = function(step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var velocityA = bodyA.c_velocity;\n            var velocityB = bodyB.c_velocity;\n            bodyA.c_position;\n            bodyB.c_position;\n            var mA = this.v_invMassA;\n            var iA = this.v_invIA;\n            var mB = this.v_invMassB;\n            var iB = this.v_invIB;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var normal = this.v_normal;\n            var tangent = Vec2.crossVec2Num(normal, 1.0);\n            for(var j = 0; j < this.v_pointCount; ++j){\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                var P = Vec2.combine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n                wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                vA.subMul(mA, P);\n                wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n                vB.addMul(mB, P);\n            }\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        Contact.prototype.storeConstraintImpulses = function(step) {\n            var manifold = this.m_manifold;\n            for(var j = 0; j < this.v_pointCount; ++j){\n                manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n                manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n            }\n        };\n        Contact.prototype.solveVelocityConstraint = function(step) {\n            var bodyA = this.m_fixtureA.m_body;\n            var bodyB = this.m_fixtureB.m_body;\n            var velocityA = bodyA.c_velocity;\n            bodyA.c_position;\n            var velocityB = bodyB.c_velocity;\n            bodyB.c_position;\n            var mA = this.v_invMassA;\n            var iA = this.v_invIA;\n            var mB = this.v_invMassB;\n            var iB = this.v_invIB;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var normal = this.v_normal;\n            var tangent = Vec2.crossVec2Num(normal, 1.0);\n            var friction = this.v_friction;\n            // Solve tangent constraints first because non-penetration is more important\n            // than friction.\n            for(var j = 0; j < this.v_pointCount; ++j){\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                // Relative velocity at contact\n                var dv = Vec2.zero();\n                dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n                dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n                // Compute tangent force\n                var vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;\n                var lambda = vcp.tangentMass * -vt;\n                // Clamp the accumulated force\n                var maxFriction = friction * vcp.normalImpulse;\n                var newImpulse = math.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n                lambda = newImpulse - vcp.tangentImpulse;\n                vcp.tangentImpulse = newImpulse;\n                // Apply contact impulse\n                var P = Vec2.mulNumVec2(lambda, tangent);\n                vA.subMul(mA, P);\n                wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                vB.addMul(mB, P);\n                wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n            }\n            // Solve normal constraints\n            if (this.v_pointCount == 1 || step.blockSolve == false) for(var i = 0; i < this.v_pointCount; ++i){\n                var vcp = this.v_points[i]; // VelocityConstraintPoint\n                // Relative velocity at contact\n                var dv = Vec2.zero();\n                dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n                dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n                // Compute normal impulse\n                var vn = Vec2.dot(dv, normal);\n                var lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n                // Clamp the accumulated impulse\n                var newImpulse = math.max(vcp.normalImpulse + lambda, 0.0);\n                lambda = newImpulse - vcp.normalImpulse;\n                vcp.normalImpulse = newImpulse;\n                // Apply contact impulse\n                var P = Vec2.mulNumVec2(lambda, normal);\n                vA.subMul(mA, P);\n                wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                vB.addMul(mB, P);\n                wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n            }\n            else {\n                // Block solver developed in collaboration with Dirk Gregorius (back in\n                // 01/07 on Box2D_Lite).\n                // Build the mini LCP for this contact patch\n                //\n                // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =\n                // 1..2\n                //\n                // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n                // b = vn0 - velocityBias\n                //\n                // The system is solved using the \"Total enumeration method\" (s. Murty).\n                // The complementary constraint vn_i * x_i\n                // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n                // So for the 2D contact problem the cases\n                // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n                // vn1 = 0 need to be tested. The first valid\n                // solution that satisfies the problem is chosen.\n                //\n                // In order to account of the accumulated impulse 'a' (because of the\n                // iterative nature of the solver which only requires\n                // that the accumulated impulse is clamped and not the incremental\n                // impulse) we change the impulse variable (x_i).\n                //\n                // Substitute:\n                //\n                // x = a + d\n                //\n                // a := old total impulse\n                // x := new total impulse\n                // d := incremental impulse\n                //\n                // For the current iteration we extend the formula for the incremental\n                // impulse\n                // to compute the new total impulse:\n                //\n                // vn = A * d + b\n                // = A * (x - a) + b\n                // = A * x + b - A * a\n                // = A * x + b'\n                // b' = b - A * a;\n                var vcp1 = this.v_points[0]; // VelocityConstraintPoint\n                var vcp2 = this.v_points[1]; // VelocityConstraintPoint\n                var a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);\n                // Relative velocity at contact\n                var dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n                var dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n                // Compute normal velocity\n                var vn1 = Vec2.dot(dv1, normal);\n                var vn2 = Vec2.dot(dv2, normal);\n                var b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n                // Compute b'\n                b.sub(Mat22.mulVec2(this.v_K, a));\n                // NOT_USED(k_errorTol);\n                while(true){\n                    //\n                    // Case 1: vn = 0\n                    //\n                    // 0 = A * x + b'\n                    //\n                    // Solve for x:\n                    //\n                    // x = - inv(A) * b'\n                    //\n                    var x = Mat22.mulVec2(this.v_normalMass, b).neg();\n                    if (x.x >= 0.0 && x.y >= 0.0) {\n                        // Get the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 2: vn1 = 0 and x2 = 0\n                    //\n                    // 0 = a11 * x1 + a12 * 0 + b1'\n                    // vn2 = a21 * x1 + a22 * 0 + b2'\n                    //\n                    x.x = -vcp1.normalMass * b.x;\n                    x.y = 0.0;\n                    vn1 = 0.0;\n                    vn2 = this.v_K.ex.y * x.x + b.y;\n                    if (x.x >= 0.0 && vn2 >= 0.0) {\n                        // Get the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 3: vn2 = 0 and x1 = 0\n                    //\n                    // vn1 = a11 * 0 + a12 * x2 + b1'\n                    // 0 = a21 * 0 + a22 * x2 + b2'\n                    //\n                    x.x = 0.0;\n                    x.y = -vcp2.normalMass * b.y;\n                    vn1 = this.v_K.ey.x * x.y + b.x;\n                    vn2 = 0.0;\n                    if (x.y >= 0.0 && vn1 >= 0.0) {\n                        // Resubstitute for the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 4: x1 = 0 and x2 = 0\n                    //\n                    // vn1 = b1\n                    // vn2 = b2;\n                    //\n                    x.x = 0.0;\n                    x.y = 0.0;\n                    vn1 = b.x;\n                    vn2 = b.y;\n                    if (vn1 >= 0.0 && vn2 >= 0.0) {\n                        // Resubstitute for the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    break;\n                }\n            }\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        /**\n         * @internal\n         */ Contact.addType = function(type1, type2, callback) {\n            s_registers[type1] = s_registers[type1] || {};\n            s_registers[type1][type2] = callback;\n        };\n        /**\n         * @internal\n         */ Contact.create = function(fixtureA, indexA, fixtureB, indexB) {\n            var typeA = fixtureA.getType();\n            var typeB = fixtureB.getType();\n            // TODO: pool contacts\n            var contact;\n            var evaluateFcn;\n            if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n            else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n            else return null;\n            // Contact creation may swap fixtures.\n            fixtureA = contact.getFixtureA();\n            fixtureB = contact.getFixtureB();\n            indexA = contact.getChildIndexA();\n            indexB = contact.getChildIndexB();\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            // Connect to body A\n            contact.m_nodeA.contact = contact;\n            contact.m_nodeA.other = bodyB;\n            contact.m_nodeA.prev = null;\n            contact.m_nodeA.next = bodyA.m_contactList;\n            if (bodyA.m_contactList != null) bodyA.m_contactList.prev = contact.m_nodeA;\n            bodyA.m_contactList = contact.m_nodeA;\n            // Connect to body B\n            contact.m_nodeB.contact = contact;\n            contact.m_nodeB.other = bodyA;\n            contact.m_nodeB.prev = null;\n            contact.m_nodeB.next = bodyB.m_contactList;\n            if (bodyB.m_contactList != null) bodyB.m_contactList.prev = contact.m_nodeB;\n            bodyB.m_contactList = contact.m_nodeB;\n            // Wake up the bodies\n            if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n                bodyA.setAwake(true);\n                bodyB.setAwake(true);\n            }\n            return contact;\n        };\n        /**\n         * @internal\n         */ Contact.destroy = function(contact, listener) {\n            var fixtureA = contact.m_fixtureA;\n            var fixtureB = contact.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            if (contact.isTouching()) listener.endContact(contact);\n            // Remove from body 1\n            if (contact.m_nodeA.prev) contact.m_nodeA.prev.next = contact.m_nodeA.next;\n            if (contact.m_nodeA.next) contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n            if (contact.m_nodeA == bodyA.m_contactList) bodyA.m_contactList = contact.m_nodeA.next;\n            // Remove from body 2\n            if (contact.m_nodeB.prev) contact.m_nodeB.prev.next = contact.m_nodeB.next;\n            if (contact.m_nodeB.next) contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n            if (contact.m_nodeB == bodyB.m_contactList) bodyB.m_contactList = contact.m_nodeB.next;\n            if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n                bodyA.setAwake(true);\n                bodyB.setAwake(true);\n            }\n            fixtureA.getType();\n            fixtureB.getType();\n        // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n        // if (typeof destroyFcn === 'function') {\n        //   destroyFcn(contact);\n        // }\n        };\n        return Contact;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A joint edge is used to connect bodies and joints together in a joint graph\n     * where each body is a node and each joint is an edge. A joint edge belongs to\n     * a doubly linked list maintained in each attached body. Each joint has two\n     * joint nodes, one for each attached body.\n     */ var JointEdge = /** @class */ function() {\n        function JointEdge() {\n            /**\n             * provides quick access to the other body attached.\n             */ this.other = null;\n            /**\n             * the joint\n             */ this.joint = null;\n            /**\n             * prev the previous joint edge in the body's joint list\n             */ this.prev = null;\n            /**\n             * the next joint edge in the body's joint list\n             */ this.next = null;\n        }\n        return JointEdge;\n    }();\n    /**\n     * The base joint class. Joints are used to constraint two bodies together in\n     * various fashions. Some joints also feature limits and motors.\n     */ var Joint = /** @class */ function() {\n        function Joint(def, bodyA, bodyB) {\n            /** @internal */ this.m_type = \"unknown-joint\";\n            /** @internal */ this.m_prev = null;\n            /** @internal */ this.m_next = null;\n            /** @internal */ this.m_edgeA = new JointEdge();\n            /** @internal */ this.m_edgeB = new JointEdge();\n            /** @internal */ this.m_islandFlag = false;\n            bodyA = \"bodyA\" in def ? def.bodyA : bodyA;\n            bodyB = \"bodyB\" in def ? def.bodyB : bodyB;\n            this.m_bodyA = bodyA;\n            this.m_bodyB = bodyB;\n            this.m_collideConnected = !!def.collideConnected;\n            this.m_userData = def.userData;\n        }\n        /**\n         * Short-cut function to determine if either body is inactive.\n         */ Joint.prototype.isActive = function() {\n            return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n        };\n        /**\n         * Get the type of the concrete joint.\n         */ Joint.prototype.getType = function() {\n            return this.m_type;\n        };\n        /**\n         * Get the first body attached to this joint.\n         */ Joint.prototype.getBodyA = function() {\n            return this.m_bodyA;\n        };\n        /**\n         * Get the second body attached to this joint.\n         */ Joint.prototype.getBodyB = function() {\n            return this.m_bodyB;\n        };\n        /**\n         * Get the next joint the world joint list.\n         */ Joint.prototype.getNext = function() {\n            return this.m_next;\n        };\n        Joint.prototype.getUserData = function() {\n            return this.m_userData;\n        };\n        Joint.prototype.setUserData = function(data) {\n            this.m_userData = data;\n        };\n        /**\n         * Get collide connected. Note: modifying the collide connect flag won't work\n         * correctly because the flag is only checked when fixture AABBs begin to\n         * overlap.\n         */ Joint.prototype.getCollideConnected = function() {\n            return this.m_collideConnected;\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         */ Joint.prototype.shiftOrigin = function(newOrigin) {};\n        return Joint;\n    }();\n    var now = function() {\n        return Date.now();\n    };\n    var diff = function(time) {\n        return Date.now() - time;\n    };\n    var Timer = {\n        now: now,\n        diff: diff\n    };\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * Input parameters for TimeOfImpact.\n     */ var TOIInput = /** @class */ function() {\n        function TOIInput() {\n            this.proxyA = new DistanceProxy();\n            this.proxyB = new DistanceProxy();\n            this.sweepA = new Sweep();\n            this.sweepB = new Sweep();\n        }\n        return TOIInput;\n    }();\n    var TOIOutputState;\n    (function(TOIOutputState) {\n        TOIOutputState[TOIOutputState[\"e_unknown\"] = 0] = \"e_unknown\";\n        TOIOutputState[TOIOutputState[\"e_failed\"] = 1] = \"e_failed\";\n        TOIOutputState[TOIOutputState[\"e_overlapped\"] = 2] = \"e_overlapped\";\n        TOIOutputState[TOIOutputState[\"e_touching\"] = 3] = \"e_touching\";\n        TOIOutputState[TOIOutputState[\"e_separated\"] = 4] = \"e_separated\";\n    })(TOIOutputState || (TOIOutputState = {}));\n    /**\n     * Output parameters for TimeOfImpact.\n     */ var TOIOutput = /** @class */ function() {\n        function TOIOutput() {}\n        return TOIOutput;\n    }();\n    stats.toiTime = 0;\n    stats.toiMaxTime = 0;\n    stats.toiCalls = 0;\n    stats.toiIters = 0;\n    stats.toiMaxIters = 0;\n    stats.toiRootIters = 0;\n    stats.toiMaxRootIters = 0;\n    /**\n     * Compute the upper bound on time before two shapes penetrate. Time is\n     * represented as a fraction between [0,tMax]. This uses a swept separating axis\n     * and may miss some intermediate, non-tunneling collision. If you change the\n     * time interval, you should call this function again.\n     *\n     * Note: use Distance to compute the contact point and normal at the time of\n     * impact.\n     *\n     * CCD via the local separating axis method. This seeks progression by computing\n     * the largest time at which separation is maintained.\n     */ function TimeOfImpact(output, input) {\n        var timer = Timer.now();\n        ++stats.toiCalls;\n        output.state = TOIOutputState.e_unknown;\n        output.t = input.tMax;\n        var proxyA = input.proxyA; // DistanceProxy\n        var proxyB = input.proxyB; // DistanceProxy\n        var sweepA = input.sweepA; // Sweep\n        var sweepB = input.sweepB; // Sweep\n        // Large rotations can make the root finder fail, so we normalize the\n        // sweep angles.\n        sweepA.normalize();\n        sweepB.normalize();\n        var tMax = input.tMax;\n        var totalRadius = proxyA.m_radius + proxyB.m_radius;\n        var target = math.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n        var tolerance = 0.25 * Settings.linearSlop;\n        var t1 = 0.0;\n        var k_maxIterations = Settings.maxTOIIterations;\n        var iter = 0;\n        // Prepare input for distance query.\n        var cache = new SimplexCache();\n        var distanceInput = new DistanceInput();\n        distanceInput.proxyA = input.proxyA;\n        distanceInput.proxyB = input.proxyB;\n        distanceInput.useRadii = false;\n        // The outer loop progressively attempts to compute new separating axes.\n        // This loop terminates when an axis is repeated (no progress is made).\n        while(true){\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            sweepA.getTransform(xfA, t1);\n            sweepB.getTransform(xfB, t1);\n            // Get the distance between shapes. We can also use the results\n            // to get a separating axis.\n            distanceInput.transformA = xfA;\n            distanceInput.transformB = xfB;\n            var distanceOutput = new DistanceOutput();\n            Distance(distanceOutput, cache, distanceInput);\n            // If the shapes are overlapped, we give up on continuous collision.\n            if (distanceOutput.distance <= 0.0) {\n                // Failure!\n                output.state = TOIOutputState.e_overlapped;\n                output.t = 0.0;\n                break;\n            }\n            if (distanceOutput.distance < target + tolerance) {\n                // Victory!\n                output.state = TOIOutputState.e_touching;\n                output.t = t1;\n                break;\n            }\n            // Initialize the separating axis.\n            var fcn = new SeparationFunction();\n            fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n            // if (false) {\n            //   // Dump the curve seen by the root finder\n            //   const N = 100;\n            //   const dx = 1.0 / N;\n            //   const xs = []; // [ N + 1 ];\n            //   const fs = []; // [ N + 1 ];\n            //   const x = 0.0;\n            //   for (const i = 0; i <= N; ++i) {\n            //     sweepA.getTransform(xfA, x);\n            //     sweepB.getTransform(xfB, x);\n            //     const f = fcn.evaluate(xfA, xfB) - target;\n            //     printf(\"%g %g\\n\", x, f);\n            //     xs[i] = x;\n            //     fs[i] = f;\n            //     x += dx;\n            //   }\n            // }\n            // Compute the TOI on the separating axis. We do this by successively\n            // resolving the deepest point. This loop is bounded by the number of\n            // vertices.\n            var done = false;\n            var t2 = tMax;\n            var pushBackIter = 0;\n            while(true){\n                // Find the deepest point at t2. Store the witness point indices.\n                var s2 = fcn.findMinSeparation(t2);\n                // const indexA = fcn.indexA;\n                // const indexB = fcn.indexB;\n                // Is the final configuration separated?\n                if (s2 > target + tolerance) {\n                    // Victory!\n                    output.state = TOIOutputState.e_separated;\n                    output.t = tMax;\n                    done = true;\n                    break;\n                }\n                // Has the separation reached tolerance?\n                if (s2 > target - tolerance) {\n                    // Advance the sweeps\n                    t1 = t2;\n                    break;\n                }\n                // Compute the initial separation of the witness points.\n                var s1 = fcn.evaluate(t1);\n                // const indexA = fcn.indexA;\n                // const indexB = fcn.indexB;\n                // Check for initial overlap. This might happen if the root finder\n                // runs out of iterations.\n                if (s1 < target - tolerance) {\n                    output.state = TOIOutputState.e_failed;\n                    output.t = t1;\n                    done = true;\n                    break;\n                }\n                // Check for touching\n                if (s1 <= target + tolerance) {\n                    // Victory! t1 should hold the TOI (could be 0.0).\n                    output.state = TOIOutputState.e_touching;\n                    output.t = t1;\n                    done = true;\n                    break;\n                }\n                // Compute 1D root of: f(x) - target = 0\n                var rootIterCount = 0;\n                var a1 = t1;\n                var a2 = t2;\n                while(true){\n                    // Use a mix of the secant rule and bisection.\n                    var t = void 0;\n                    if (rootIterCount & 1) // Secant rule to improve convergence.\n                    t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n                    else // Bisection to guarantee progress.\n                    t = 0.5 * (a1 + a2);\n                    ++rootIterCount;\n                    ++stats.toiRootIters;\n                    var s = fcn.evaluate(t);\n                    fcn.indexA;\n                    fcn.indexB;\n                    if (math.abs(s - target) < tolerance) {\n                        // t2 holds a tentative value for t1\n                        t2 = t;\n                        break;\n                    }\n                    // Ensure we continue to bracket the root.\n                    if (s > target) {\n                        a1 = t;\n                        s1 = s;\n                    } else {\n                        a2 = t;\n                        s2 = s;\n                    }\n                    if (rootIterCount === 50) break;\n                }\n                stats.toiMaxRootIters = math.max(stats.toiMaxRootIters, rootIterCount);\n                ++pushBackIter;\n                if (pushBackIter === Settings.maxPolygonVertices) break;\n            }\n            ++iter;\n            ++stats.toiIters;\n            if (done) break;\n            if (iter === k_maxIterations) {\n                // Root finder got stuck. Semi-victory.\n                output.state = TOIOutputState.e_failed;\n                output.t = t1;\n                break;\n            }\n        }\n        stats.toiMaxIters = math.max(stats.toiMaxIters, iter);\n        var time = Timer.diff(timer);\n        stats.toiMaxTime = math.max(stats.toiMaxTime, time);\n        stats.toiTime += time;\n    }\n    var SeparationFunctionType;\n    (function(SeparationFunctionType) {\n        SeparationFunctionType[SeparationFunctionType[\"e_points\"] = 1] = \"e_points\";\n        SeparationFunctionType[SeparationFunctionType[\"e_faceA\"] = 2] = \"e_faceA\";\n        SeparationFunctionType[SeparationFunctionType[\"e_faceB\"] = 3] = \"e_faceB\";\n    })(SeparationFunctionType || (SeparationFunctionType = {}));\n    var SeparationFunction = /** @class */ function() {\n        function SeparationFunction() {\n            this.m_proxyA = new DistanceProxy();\n            this.m_proxyB = new DistanceProxy();\n            this.m_localPoint = Vec2.zero();\n            this.m_axis = Vec2.zero();\n        }\n        // TODO_ERIN might not need to return the separation\n        SeparationFunction.prototype.initialize = function(cache, proxyA, sweepA, proxyB, sweepB, t1) {\n            this.m_proxyA = proxyA;\n            this.m_proxyB = proxyB;\n            var count = cache.count;\n            this.m_sweepA = sweepA;\n            this.m_sweepB = sweepB;\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            this.m_sweepA.getTransform(xfA, t1);\n            this.m_sweepB.getTransform(xfB, t1);\n            if (count === 1) {\n                this.m_type = SeparationFunctionType.e_points;\n                var localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n                var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n                var pointA = Transform.mulVec2(xfA, localPointA);\n                var pointB = Transform.mulVec2(xfB, localPointB);\n                this.m_axis.setCombine(1, pointB, -1, pointA);\n                var s = this.m_axis.normalize();\n                return s;\n            } else if (cache.indexA[0] === cache.indexA[1]) {\n                // Two points on B and one on A.\n                this.m_type = SeparationFunctionType.e_faceB;\n                var localPointB1 = proxyB.getVertex(cache.indexB[0]);\n                var localPointB2 = proxyB.getVertex(cache.indexB[1]);\n                this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointB2, localPointB1), 1.0);\n                this.m_axis.normalize();\n                var normal = Rot.mulVec2(xfB.q, this.m_axis);\n                this.m_localPoint = Vec2.mid(localPointB1, localPointB2);\n                var pointB = Transform.mulVec2(xfB, this.m_localPoint);\n                var localPointA = proxyA.getVertex(cache.indexA[0]);\n                var pointA = Transform.mulVec2(xfA, localPointA);\n                var s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n                if (s < 0.0) {\n                    this.m_axis = Vec2.neg(this.m_axis);\n                    s = -s;\n                }\n                return s;\n            } else {\n                // Two points on A and one or two points on B.\n                this.m_type = SeparationFunctionType.e_faceA;\n                var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n                var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n                this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointA2, localPointA1), 1.0);\n                this.m_axis.normalize();\n                var normal = Rot.mulVec2(xfA.q, this.m_axis);\n                this.m_localPoint = Vec2.mid(localPointA1, localPointA2);\n                var pointA = Transform.mulVec2(xfA, this.m_localPoint);\n                var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n                var pointB = Transform.mulVec2(xfB, localPointB);\n                var s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n                if (s < 0.0) {\n                    this.m_axis = Vec2.neg(this.m_axis);\n                    s = -s;\n                }\n                return s;\n            }\n        };\n        SeparationFunction.prototype.compute = function(find, t) {\n            // It was findMinSeparation and evaluate\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            this.m_sweepA.getTransform(xfA, t);\n            this.m_sweepB.getTransform(xfB, t);\n            switch(this.m_type){\n                case SeparationFunctionType.e_points:\n                    if (find) {\n                        var axisA = Rot.mulTVec2(xfA.q, this.m_axis);\n                        var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(this.m_axis));\n                        this.indexA = this.m_proxyA.getSupport(axisA);\n                        this.indexB = this.m_proxyB.getSupport(axisB);\n                    }\n                    var localPointA = this.m_proxyA.getVertex(this.indexA);\n                    var localPointB = this.m_proxyB.getVertex(this.indexB);\n                    var pointA = Transform.mulVec2(xfA, localPointA);\n                    var pointB = Transform.mulVec2(xfB, localPointB);\n                    var sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);\n                    return sep;\n                case SeparationFunctionType.e_faceA:\n                    var normal = Rot.mulVec2(xfA.q, this.m_axis);\n                    var pointA = Transform.mulVec2(xfA, this.m_localPoint);\n                    if (find) {\n                        var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(normal));\n                        this.indexA = -1;\n                        this.indexB = this.m_proxyB.getSupport(axisB);\n                    }\n                    var localPointB = this.m_proxyB.getVertex(this.indexB);\n                    var pointB = Transform.mulVec2(xfB, localPointB);\n                    var sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n                    return sep;\n                case SeparationFunctionType.e_faceB:\n                    var normal = Rot.mulVec2(xfB.q, this.m_axis);\n                    var pointB = Transform.mulVec2(xfB, this.m_localPoint);\n                    if (find) {\n                        var axisA = Rot.mulTVec2(xfA.q, Vec2.neg(normal));\n                        this.indexB = -1;\n                        this.indexA = this.m_proxyA.getSupport(axisA);\n                    }\n                    var localPointA = this.m_proxyA.getVertex(this.indexA);\n                    var pointA = Transform.mulVec2(xfA, localPointA);\n                    var sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n                    return sep;\n                default:\n                    if (find) {\n                        this.indexA = -1;\n                        this.indexB = -1;\n                    }\n                    return 0.0;\n            }\n        };\n        SeparationFunction.prototype.findMinSeparation = function(t) {\n            return this.compute(true, t);\n        };\n        SeparationFunction.prototype.evaluate = function(t) {\n            return this.compute(false, t);\n        };\n        return SeparationFunction;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var TimeStep = /** @class */ function() {\n        function TimeStep() {\n            /** time step */ this.dt = 0;\n            /** inverse time step (0 if dt == 0) */ this.inv_dt = 0;\n            this.velocityIterations = 0;\n            this.positionIterations = 0;\n            this.warmStarting = false;\n            this.blockSolve = true;\n            /** timestep ratio for variable timestep */ this.inv_dt0 = 0.0;\n            /** dt * inv_dt0 */ this.dtRatio = 1;\n        }\n        TimeStep.prototype.reset = function(dt) {\n            if (this.dt > 0.0) this.inv_dt0 = this.inv_dt;\n            this.dt = dt;\n            this.inv_dt = dt == 0 ? 0 : 1 / dt;\n            this.dtRatio = dt * this.inv_dt0;\n        };\n        return TimeStep;\n    }();\n    // reuse\n    var s_subStep = new TimeStep();\n    /**\n     * Contact impulses for reporting. Impulses are used instead of forces because\n     * sub-step forces may approach infinity for rigid body collisions. These match\n     * up one-to-one with the contact points in Manifold.\n     */ var ContactImpulse = /** @class */ function() {\n        function ContactImpulse(contact) {\n            this.contact = contact;\n            this.normals = [];\n            this.tangents = [];\n        }\n        Object.defineProperty(ContactImpulse.prototype, \"normalImpulses\", {\n            get: function() {\n                var contact = this.contact;\n                var normals = this.normals;\n                normals.length = 0;\n                for(var p = 0; p < contact.v_points.length; ++p)normals.push(contact.v_points[p].normalImpulse);\n                return normals;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ContactImpulse.prototype, \"tangentImpulses\", {\n            get: function() {\n                var contact = this.contact;\n                var tangents = this.tangents;\n                tangents.length = 0;\n                for(var p = 0; p < contact.v_points.length; ++p)tangents.push(contact.v_points[p].tangentImpulse);\n                return tangents;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return ContactImpulse;\n    }();\n    /**\n     * Finds and solves islands. An island is a connected subset of the world.\n     */ var Solver = /** @class */ function() {\n        function Solver(world) {\n            this.m_world = world;\n            this.m_stack = [];\n            this.m_bodies = [];\n            this.m_contacts = [];\n            this.m_joints = [];\n        }\n        Solver.prototype.clear = function() {\n            this.m_stack.length = 0;\n            this.m_bodies.length = 0;\n            this.m_contacts.length = 0;\n            this.m_joints.length = 0;\n        };\n        Solver.prototype.addBody = function(body) {\n            this.m_bodies.push(body);\n        // why?\n        // body.c_position.c.setZero();\n        // body.c_position.a = 0;\n        // body.c_velocity.v.setZero();\n        // body.c_velocity.w = 0;\n        };\n        Solver.prototype.addContact = function(contact) {\n            this.m_contacts.push(contact);\n        };\n        Solver.prototype.addJoint = function(joint) {\n            this.m_joints.push(joint);\n        };\n        Solver.prototype.solveWorld = function(step) {\n            var world = this.m_world;\n            // Clear all the island flags.\n            for(var b = world.m_bodyList; b; b = b.m_next)b.m_islandFlag = false;\n            for(var c = world.m_contactList; c; c = c.m_next)c.m_islandFlag = false;\n            for(var j = world.m_jointList; j; j = j.m_next)j.m_islandFlag = false;\n            // Build and simulate all awake islands.\n            var stack = this.m_stack;\n            for(var seed = world.m_bodyList; seed; seed = seed.m_next){\n                if (seed.m_islandFlag) continue;\n                if (seed.isAwake() == false || seed.isActive() == false) continue;\n                // The seed can be dynamic or kinematic.\n                if (seed.isStatic()) continue;\n                // Reset island and stack.\n                this.clear();\n                stack.push(seed);\n                seed.m_islandFlag = true;\n                // Perform a depth first search (DFS) on the constraint graph.\n                while(stack.length > 0){\n                    // Grab the next body off the stack and add it to the island.\n                    var b = stack.pop();\n                    this.addBody(b);\n                    // Make sure the body is awake.\n                    b.setAwake(true);\n                    // To keep islands as small as possible, we don't\n                    // propagate islands across static bodies.\n                    if (b.isStatic()) continue;\n                    // Search all contacts connected to this body.\n                    for(var ce = b.m_contactList; ce; ce = ce.next){\n                        var contact = ce.contact;\n                        // Has this contact already been added to an island?\n                        if (contact.m_islandFlag) continue;\n                        // Is this contact solid and touching?\n                        if (contact.isEnabled() == false || contact.isTouching() == false) continue;\n                        // Skip sensors.\n                        var sensorA = contact.m_fixtureA.m_isSensor;\n                        var sensorB = contact.m_fixtureB.m_isSensor;\n                        if (sensorA || sensorB) continue;\n                        this.addContact(contact);\n                        contact.m_islandFlag = true;\n                        var other = ce.other;\n                        // Was the other body already added to this island?\n                        if (other.m_islandFlag) continue;\n                        // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n                        stack.push(other);\n                        other.m_islandFlag = true;\n                    }\n                    // Search all joints connect to this body.\n                    for(var je = b.m_jointList; je; je = je.next){\n                        if (je.joint.m_islandFlag == true) continue;\n                        var other = je.other;\n                        // Don't simulate joints connected to inactive bodies.\n                        if (other.isActive() == false) continue;\n                        this.addJoint(je.joint);\n                        je.joint.m_islandFlag = true;\n                        if (other.m_islandFlag) continue;\n                        // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n                        stack.push(other);\n                        other.m_islandFlag = true;\n                    }\n                }\n                this.solveIsland(step);\n                // Post solve cleanup.\n                for(var i = 0; i < this.m_bodies.length; ++i){\n                    // Allow static bodies to participate in other islands.\n                    // TODO: are they added at all?\n                    var b = this.m_bodies[i];\n                    if (b.isStatic()) b.m_islandFlag = false;\n                }\n            }\n        };\n        Solver.prototype.solveIsland = function(step) {\n            // B2: Island Solve\n            var world = this.m_world;\n            var gravity = world.m_gravity;\n            var allowSleep = world.m_allowSleep;\n            var h = step.dt;\n            // Integrate velocities and apply damping. Initialize the body state.\n            for(var i = 0; i < this.m_bodies.length; ++i){\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.m_sweep.c);\n                var a = body.m_sweep.a;\n                var v = Vec2.clone(body.m_linearVelocity);\n                var w = body.m_angularVelocity;\n                // Store positions for continuous collision.\n                body.m_sweep.c0.setVec2(body.m_sweep.c);\n                body.m_sweep.a0 = body.m_sweep.a;\n                if (body.isDynamic()) {\n                    // Integrate velocities.\n                    v.addMul(h * body.m_gravityScale, gravity);\n                    v.addMul(h * body.m_invMass, body.m_force);\n                    w += h * body.m_invI * body.m_torque;\n                    /**\n                     * <pre>\n                     * Apply damping.\n                     * ODE: dv/dt + c * v = 0\n                     * Solution: v(t) = v0 * exp(-c * t)\n                     * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n                     * v2 = exp(-c * dt) * v1\n                     * Pade approximation:\n                     * v2 = v1 * 1 / (1 + c * dt)\n                     * </pre>\n                     */ v.mul(1.0 / (1.0 + h * body.m_linearDamping));\n                    w *= 1.0 / (1.0 + h * body.m_angularDamping);\n                }\n                body.c_position.c = c;\n                body.c_position.a = a;\n                body.c_velocity.v = v;\n                body.c_velocity.w = w;\n            }\n            for(var i = 0; i < this.m_contacts.length; ++i){\n                var contact = this.m_contacts[i];\n                contact.initConstraint(step);\n            }\n            for(var i = 0; i < this.m_contacts.length; ++i){\n                var contact = this.m_contacts[i];\n                contact.initVelocityConstraint(step);\n            }\n            if (step.warmStarting) // Warm start.\n            for(var i = 0; i < this.m_contacts.length; ++i){\n                var contact = this.m_contacts[i];\n                contact.warmStartConstraint(step);\n            }\n            for(var i = 0; i < this.m_joints.length; ++i){\n                var joint = this.m_joints[i];\n                joint.initVelocityConstraints(step);\n            }\n            // Solve velocity constraints\n            for(var i = 0; i < step.velocityIterations; ++i){\n                for(var j = 0; j < this.m_joints.length; ++j){\n                    var joint = this.m_joints[j];\n                    joint.solveVelocityConstraints(step);\n                }\n                for(var j = 0; j < this.m_contacts.length; ++j){\n                    var contact = this.m_contacts[j];\n                    contact.solveVelocityConstraint(step);\n                }\n            }\n            // Store impulses for warm starting\n            for(var i = 0; i < this.m_contacts.length; ++i){\n                var contact = this.m_contacts[i];\n                contact.storeConstraintImpulses(step);\n            }\n            // Integrate positions\n            for(var i = 0; i < this.m_bodies.length; ++i){\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.c_position.c);\n                var a = body.c_position.a;\n                var v = Vec2.clone(body.c_velocity.v);\n                var w = body.c_velocity.w;\n                // Check for large velocities\n                var translation = Vec2.mulNumVec2(h, v);\n                if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {\n                    var ratio = Settings.maxTranslation / translation.length();\n                    v.mul(ratio);\n                }\n                var rotation = h * w;\n                if (rotation * rotation > Settings.maxRotationSquared) {\n                    var ratio = Settings.maxRotation / math.abs(rotation);\n                    w *= ratio;\n                }\n                // Integrate\n                c.addMul(h, v);\n                a += h * w;\n                body.c_position.c.setVec2(c);\n                body.c_position.a = a;\n                body.c_velocity.v.setVec2(v);\n                body.c_velocity.w = w;\n            }\n            // Solve position constraints\n            var positionSolved = false;\n            for(var i = 0; i < step.positionIterations; ++i){\n                var minSeparation = 0.0;\n                for(var j = 0; j < this.m_contacts.length; ++j){\n                    var contact = this.m_contacts[j];\n                    var separation = contact.solvePositionConstraint(step);\n                    minSeparation = math.min(minSeparation, separation);\n                }\n                // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n                // push the separation above -Settings.linearSlop.\n                var contactsOkay = minSeparation >= -3 * Settings.linearSlop;\n                var jointsOkay = true;\n                for(var j = 0; j < this.m_joints.length; ++j){\n                    var joint = this.m_joints[j];\n                    var jointOkay = joint.solvePositionConstraints(step);\n                    jointsOkay = jointsOkay && jointOkay;\n                }\n                if (contactsOkay && jointsOkay) {\n                    // Exit early if the position errors are small.\n                    positionSolved = true;\n                    break;\n                }\n            }\n            // Copy state buffers back to the bodies\n            for(var i = 0; i < this.m_bodies.length; ++i){\n                var body = this.m_bodies[i];\n                body.m_sweep.c.setVec2(body.c_position.c);\n                body.m_sweep.a = body.c_position.a;\n                body.m_linearVelocity.setVec2(body.c_velocity.v);\n                body.m_angularVelocity = body.c_velocity.w;\n                body.synchronizeTransform();\n            }\n            this.postSolveIsland();\n            if (allowSleep) {\n                var minSleepTime = Infinity;\n                var linTolSqr = Settings.linearSleepToleranceSqr;\n                var angTolSqr = Settings.angularSleepToleranceSqr;\n                for(var i = 0; i < this.m_bodies.length; ++i){\n                    var body = this.m_bodies[i];\n                    if (body.isStatic()) continue;\n                    if (body.m_autoSleepFlag == false || body.m_angularVelocity * body.m_angularVelocity > angTolSqr || Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr) {\n                        body.m_sleepTime = 0.0;\n                        minSleepTime = 0.0;\n                    } else {\n                        body.m_sleepTime += h;\n                        minSleepTime = math.min(minSleepTime, body.m_sleepTime);\n                    }\n                }\n                if (minSleepTime >= Settings.timeToSleep && positionSolved) for(var i = 0; i < this.m_bodies.length; ++i){\n                    var body = this.m_bodies[i];\n                    body.setAwake(false);\n                }\n            }\n        };\n        /** @internal */ Solver.prototype.printBodies = function(tag) {\n            for(var i = 0; i < this.m_bodies.length; ++i){\n                var b = this.m_bodies[i];\n                common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);\n            }\n        };\n        /**\n         * Find TOI contacts and solve them.\n         */ Solver.prototype.solveWorldTOI = function(step) {\n            var world = this.m_world;\n            if (world.m_stepComplete) {\n                for(var b = world.m_bodyList; b; b = b.m_next){\n                    b.m_islandFlag = false;\n                    b.m_sweep.alpha0 = 0.0;\n                }\n                for(var c = world.m_contactList; c; c = c.m_next){\n                    // Invalidate TOI\n                    c.m_toiFlag = false;\n                    c.m_islandFlag = false;\n                    c.m_toiCount = 0;\n                    c.m_toi = 1.0;\n                }\n            }\n            // Find TOI events and solve them.\n            while(true){\n                // Find the first TOI.\n                var minContact = null; // Contact\n                var minAlpha = 1.0;\n                for(var c = world.m_contactList; c; c = c.m_next){\n                    // Is this contact disabled?\n                    if (c.isEnabled() == false) continue;\n                    // Prevent excessive sub-stepping.\n                    if (c.m_toiCount > Settings.maxSubSteps) continue;\n                    var alpha = 1.0;\n                    if (c.m_toiFlag) // This contact has a valid cached TOI.\n                    alpha = c.m_toi;\n                    else {\n                        var fA_1 = c.getFixtureA();\n                        var fB_1 = c.getFixtureB();\n                        // Is there a sensor?\n                        if (fA_1.isSensor() || fB_1.isSensor()) continue;\n                        var bA_1 = fA_1.getBody();\n                        var bB_1 = fB_1.getBody();\n                        var activeA = bA_1.isAwake() && !bA_1.isStatic();\n                        var activeB = bB_1.isAwake() && !bB_1.isStatic();\n                        // Is at least one body active (awake and dynamic or kinematic)?\n                        if (activeA == false && activeB == false) continue;\n                        var collideA = bA_1.isBullet() || !bA_1.isDynamic();\n                        var collideB = bB_1.isBullet() || !bB_1.isDynamic();\n                        // Are these two non-bullet dynamic bodies?\n                        if (collideA == false && collideB == false) continue;\n                        // Compute the TOI for this contact.\n                        // Put the sweeps onto the same time interval.\n                        var alpha0 = bA_1.m_sweep.alpha0;\n                        if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {\n                            alpha0 = bB_1.m_sweep.alpha0;\n                            bA_1.m_sweep.advance(alpha0);\n                        } else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {\n                            alpha0 = bA_1.m_sweep.alpha0;\n                            bB_1.m_sweep.advance(alpha0);\n                        }\n                        var indexA = c.getChildIndexA();\n                        var indexB = c.getChildIndexB();\n                        bA_1.m_sweep;\n                        bB_1.m_sweep;\n                        // Compute the time of impact in interval [0, minTOI]\n                        var input = new TOIInput(); // TODO: reuse\n                        input.proxyA.set(fA_1.getShape(), indexA);\n                        input.proxyB.set(fB_1.getShape(), indexB);\n                        input.sweepA.set(bA_1.m_sweep);\n                        input.sweepB.set(bB_1.m_sweep);\n                        input.tMax = 1.0;\n                        var output = new TOIOutput(); // TODO: reuse\n                        TimeOfImpact(output, input);\n                        // Beta is the fraction of the remaining portion of the [time?].\n                        var beta = output.t;\n                        if (output.state == TOIOutputState.e_touching) alpha = math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n                        else alpha = 1.0;\n                        c.m_toi = alpha;\n                        c.m_toiFlag = true;\n                    }\n                    if (alpha < minAlpha) {\n                        // This is the minimum TOI found so far.\n                        minContact = c;\n                        minAlpha = alpha;\n                    }\n                }\n                if (minContact == null || 1.0 - 10.0 * math.EPSILON < minAlpha) {\n                    // No more TOI events. Done!\n                    world.m_stepComplete = true;\n                    break;\n                }\n                // Advance the bodies to the TOI.\n                var fA = minContact.getFixtureA();\n                var fB = minContact.getFixtureB();\n                var bA = fA.getBody();\n                var bB = fB.getBody();\n                var backup1 = bA.m_sweep.clone();\n                var backup2 = bB.m_sweep.clone();\n                bA.advance(minAlpha);\n                bB.advance(minAlpha);\n                // The TOI contact likely has some new contact points.\n                minContact.update(world);\n                minContact.m_toiFlag = false;\n                ++minContact.m_toiCount;\n                // Is the contact solid?\n                if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n                    // Restore the sweeps.\n                    minContact.setEnabled(false);\n                    bA.m_sweep.set(backup1);\n                    bB.m_sweep.set(backup2);\n                    bA.synchronizeTransform();\n                    bB.synchronizeTransform();\n                    continue;\n                }\n                bA.setAwake(true);\n                bB.setAwake(true);\n                // Build the island\n                this.clear();\n                this.addBody(bA);\n                this.addBody(bB);\n                this.addContact(minContact);\n                bA.m_islandFlag = true;\n                bB.m_islandFlag = true;\n                minContact.m_islandFlag = true;\n                // Get contacts on bodyA and bodyB.\n                var bodies = [\n                    bA,\n                    bB\n                ];\n                for(var i = 0; i < bodies.length; ++i){\n                    var body = bodies[i];\n                    if (body.isDynamic()) for(var ce = body.m_contactList; ce; ce = ce.next){\n                        // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n                        // if (this.m_contactCount == this.m_contactCapacity) { break; }\n                        var contact = ce.contact;\n                        // Has this contact already been added to the island?\n                        if (contact.m_islandFlag) continue;\n                        // Only add if either is static, kinematic or bullet.\n                        var other = ce.other;\n                        if (other.isDynamic() && !body.isBullet() && !other.isBullet()) continue;\n                        // Skip sensors.\n                        var sensorA = contact.m_fixtureA.m_isSensor;\n                        var sensorB = contact.m_fixtureB.m_isSensor;\n                        if (sensorA || sensorB) continue;\n                        // Tentatively advance the body to the TOI.\n                        var backup = other.m_sweep.clone();\n                        if (other.m_islandFlag == false) other.advance(minAlpha);\n                        // Update the contact points\n                        contact.update(world);\n                        // Was the contact disabled by the user?\n                        // Are there contact points?\n                        if (contact.isEnabled() == false || contact.isTouching() == false) {\n                            other.m_sweep.set(backup);\n                            other.synchronizeTransform();\n                            continue;\n                        }\n                        // Add the contact to the island\n                        contact.m_islandFlag = true;\n                        this.addContact(contact);\n                        // Has the other body already been added to the island?\n                        if (other.m_islandFlag) continue;\n                        // Add the other body to the island.\n                        other.m_islandFlag = true;\n                        if (!other.isStatic()) other.setAwake(true);\n                        this.addBody(other);\n                    }\n                }\n                s_subStep.reset((1.0 - minAlpha) * step.dt);\n                s_subStep.dtRatio = 1.0;\n                s_subStep.positionIterations = 20;\n                s_subStep.velocityIterations = step.velocityIterations;\n                s_subStep.warmStarting = false;\n                this.solveIslandTOI(s_subStep, bA, bB);\n                // Reset island flags and synchronize broad-phase proxies.\n                for(var i = 0; i < this.m_bodies.length; ++i){\n                    var body = this.m_bodies[i];\n                    body.m_islandFlag = false;\n                    if (!body.isDynamic()) continue;\n                    body.synchronizeFixtures();\n                    // Invalidate all contact TOIs on this displaced body.\n                    for(var ce = body.m_contactList; ce; ce = ce.next){\n                        ce.contact.m_toiFlag = false;\n                        ce.contact.m_islandFlag = false;\n                    }\n                }\n                // Commit fixture proxy movements to the broad-phase so that new contacts\n                // are created.\n                // Also, some contacts can be destroyed.\n                world.findNewContacts();\n                if (world.m_subStepping) {\n                    world.m_stepComplete = false;\n                    break;\n                }\n            }\n            var b, c;\n        };\n        Solver.prototype.solveIslandTOI = function(subStep, toiA, toiB) {\n            this.m_world;\n            // Initialize the body state.\n            for(var i = 0; i < this.m_bodies.length; ++i){\n                var body = this.m_bodies[i];\n                body.c_position.c.setVec2(body.m_sweep.c);\n                body.c_position.a = body.m_sweep.a;\n                body.c_velocity.v.setVec2(body.m_linearVelocity);\n                body.c_velocity.w = body.m_angularVelocity;\n            }\n            for(var i = 0; i < this.m_contacts.length; ++i){\n                var contact = this.m_contacts[i];\n                contact.initConstraint(subStep);\n            }\n            // Solve position constraints.\n            for(var i = 0; i < subStep.positionIterations; ++i){\n                var minSeparation = 0.0;\n                for(var j = 0; j < this.m_contacts.length; ++j){\n                    var contact = this.m_contacts[j];\n                    var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n                    minSeparation = math.min(minSeparation, separation);\n                }\n                // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n                // push the separation above -Settings.linearSlop.\n                var contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n                if (contactsOkay) break;\n            }\n            var i, c;\n            // Leap of faith to new safe state.\n            toiA.m_sweep.c0.setVec2(toiA.c_position.c);\n            toiA.m_sweep.a0 = toiA.c_position.a;\n            toiB.m_sweep.c0.setVec2(toiB.c_position.c);\n            toiB.m_sweep.a0 = toiB.c_position.a;\n            // No warm starting is needed for TOI events because warm\n            // starting impulses were applied in the discrete solver.\n            for(var i = 0; i < this.m_contacts.length; ++i){\n                var contact = this.m_contacts[i];\n                contact.initVelocityConstraint(subStep);\n            }\n            // Solve velocity constraints.\n            for(var i = 0; i < subStep.velocityIterations; ++i)for(var j = 0; j < this.m_contacts.length; ++j){\n                var contact = this.m_contacts[j];\n                contact.solveVelocityConstraint(subStep);\n            }\n            // Don't store the TOI contact forces for warm starting\n            // because they can be quite large.\n            var h = subStep.dt;\n            // Integrate positions\n            for(var i = 0; i < this.m_bodies.length; ++i){\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.c_position.c);\n                var a = body.c_position.a;\n                var v = Vec2.clone(body.c_velocity.v);\n                var w = body.c_velocity.w;\n                // Check for large velocities\n                var translation = Vec2.mulNumVec2(h, v);\n                if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {\n                    var ratio = Settings.maxTranslation / translation.length();\n                    v.mul(ratio);\n                }\n                var rotation = h * w;\n                if (rotation * rotation > Settings.maxRotationSquared) {\n                    var ratio = Settings.maxRotation / math.abs(rotation);\n                    w *= ratio;\n                }\n                // Integrate\n                c.addMul(h, v);\n                a += h * w;\n                body.c_position.c = c;\n                body.c_position.a = a;\n                body.c_velocity.v = v;\n                body.c_velocity.w = w;\n                // Sync bodies\n                body.m_sweep.c = c;\n                body.m_sweep.a = a;\n                body.m_linearVelocity = v;\n                body.m_angularVelocity = w;\n                body.synchronizeTransform();\n            }\n            this.postSolveIsland();\n        };\n        /** @internal */ Solver.prototype.postSolveIsland = function() {\n            for(var c = 0; c < this.m_contacts.length; ++c){\n                var contact = this.m_contacts[c];\n                this.m_world.postSolve(contact, contact.m_impulse);\n            }\n        };\n        return Solver;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var WorldDefDefault = {\n        gravity: Vec2.zero(),\n        allowSleep: true,\n        warmStarting: true,\n        continuousPhysics: true,\n        subStepping: false,\n        blockSolve: true,\n        velocityIterations: 8,\n        positionIterations: 3\n    };\n    var World = /** @class */ function() {\n        /**\n         * @param def World definition or gravity vector.\n         */ function World(def) {\n            var _this = this;\n            /** @internal */ this.s_step = new TimeStep(); // reuse\n            /**\n             * @internal\n             * Callback for broad-phase.\n             */ this.createContact = function(proxyA, proxyB) {\n                var fixtureA = proxyA.fixture;\n                var fixtureB = proxyB.fixture;\n                var indexA = proxyA.childIndex;\n                var indexB = proxyB.childIndex;\n                var bodyA = fixtureA.getBody();\n                var bodyB = fixtureB.getBody();\n                // Are the fixtures on the same body?\n                if (bodyA == bodyB) return;\n                // TODO_ERIN use a hash table to remove a potential bottleneck when both\n                // bodies have a lot of contacts.\n                // Does a contact already exist?\n                var edge = bodyB.getContactList(); // ContactEdge\n                while(edge){\n                    if (edge.other == bodyA) {\n                        var fA = edge.contact.getFixtureA();\n                        var fB = edge.contact.getFixtureB();\n                        var iA = edge.contact.getChildIndexA();\n                        var iB = edge.contact.getChildIndexB();\n                        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) // A contact already exists.\n                        return;\n                        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) // A contact already exists.\n                        return;\n                    }\n                    edge = edge.next;\n                }\n                if (bodyB.shouldCollide(bodyA) == false) return;\n                if (fixtureB.shouldCollide(fixtureA) == false) return;\n                // Call the factory.\n                var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n                if (contact == null) return;\n                // Insert into the world.\n                contact.m_prev = null;\n                if (_this.m_contactList != null) {\n                    contact.m_next = _this.m_contactList;\n                    _this.m_contactList.m_prev = contact;\n                }\n                _this.m_contactList = contact;\n                ++_this.m_contactCount;\n            };\n            if (!(this instanceof World)) return new World(def);\n            if (def && Vec2.isValid(def)) def = {\n                gravity: def\n            };\n            def = options(def, WorldDefDefault);\n            this.m_solver = new Solver(this);\n            this.m_broadPhase = new BroadPhase();\n            this.m_contactList = null;\n            this.m_contactCount = 0;\n            this.m_bodyList = null;\n            this.m_bodyCount = 0;\n            this.m_jointList = null;\n            this.m_jointCount = 0;\n            this.m_stepComplete = true;\n            this.m_allowSleep = def.allowSleep;\n            this.m_gravity = Vec2.clone(def.gravity);\n            this.m_clearForces = true;\n            this.m_newFixture = false;\n            this.m_locked = false;\n            // These are for debugging the solver.\n            this.m_warmStarting = def.warmStarting;\n            this.m_continuousPhysics = def.continuousPhysics;\n            this.m_subStepping = def.subStepping;\n            this.m_blockSolve = def.blockSolve;\n            this.m_velocityIterations = def.velocityIterations;\n            this.m_positionIterations = def.positionIterations;\n            this.m_t = 0;\n        }\n        /** @internal */ World.prototype._serialize = function() {\n            var bodies = [];\n            var joints = [];\n            for(var b = this.getBodyList(); b; b = b.getNext())bodies.push(b);\n            for(var j = this.getJointList(); j; j = j.getNext())// @ts-ignore\n            if (typeof j._serialize === \"function\") joints.push(j);\n            return {\n                gravity: this.m_gravity,\n                bodies: bodies,\n                joints: joints\n            };\n        };\n        /** @internal */ World._deserialize = function(data, context, restore) {\n            if (!data) return new World();\n            var world = new World(data.gravity);\n            if (data.bodies) for(var i = data.bodies.length - 1; i >= 0; i -= 1)world._addBody(restore(Body, data.bodies[i], world));\n            if (data.joints) for(var i = data.joints.length - 1; i >= 0; i--)world.createJoint(restore(Joint, data.joints[i], world));\n            return world;\n        };\n        /**\n         * Get the world body list. With the returned body, use Body.getNext to get the\n         * next body in the world list. A null body indicates the end of the list.\n         *\n         * @return the head of the world body list.\n         */ World.prototype.getBodyList = function() {\n            return this.m_bodyList;\n        };\n        /**\n         * Get the world joint list. With the returned joint, use Joint.getNext to get\n         * the next joint in the world list. A null joint indicates the end of the list.\n         *\n         * @return the head of the world joint list.\n         */ World.prototype.getJointList = function() {\n            return this.m_jointList;\n        };\n        /**\n         * Get the world contact list. With the returned contact, use Contact.getNext to\n         * get the next contact in the world list. A null contact indicates the end of\n         * the list.\n         *\n         * Warning: contacts are created and destroyed in the middle of a time step.\n         * Use ContactListener to avoid missing contacts.\n         *\n         * @return the head of the world contact list.\n         */ World.prototype.getContactList = function() {\n            return this.m_contactList;\n        };\n        World.prototype.getBodyCount = function() {\n            return this.m_bodyCount;\n        };\n        World.prototype.getJointCount = function() {\n            return this.m_jointCount;\n        };\n        /**\n         * Get the number of contacts (each may have 0 or more contact points).\n         */ World.prototype.getContactCount = function() {\n            return this.m_contactCount;\n        };\n        /**\n         * Change the global gravity vector.\n         */ World.prototype.setGravity = function(gravity) {\n            this.m_gravity = gravity;\n        };\n        /**\n         * Get the global gravity vector.\n         */ World.prototype.getGravity = function() {\n            return this.m_gravity;\n        };\n        /**\n         * Is the world locked (in the middle of a time step).\n         */ World.prototype.isLocked = function() {\n            return this.m_locked;\n        };\n        /**\n         * Enable/disable sleep.\n         */ World.prototype.setAllowSleeping = function(flag) {\n            if (flag == this.m_allowSleep) return;\n            this.m_allowSleep = flag;\n            if (this.m_allowSleep == false) for(var b = this.m_bodyList; b; b = b.m_next)b.setAwake(true);\n        };\n        World.prototype.getAllowSleeping = function() {\n            return this.m_allowSleep;\n        };\n        /**\n         * Enable/disable warm starting. For testing.\n         */ World.prototype.setWarmStarting = function(flag) {\n            this.m_warmStarting = flag;\n        };\n        World.prototype.getWarmStarting = function() {\n            return this.m_warmStarting;\n        };\n        /**\n         * Enable/disable continuous physics. For testing.\n         */ World.prototype.setContinuousPhysics = function(flag) {\n            this.m_continuousPhysics = flag;\n        };\n        World.prototype.getContinuousPhysics = function() {\n            return this.m_continuousPhysics;\n        };\n        /**\n         * Enable/disable single stepped continuous physics. For testing.\n         */ World.prototype.setSubStepping = function(flag) {\n            this.m_subStepping = flag;\n        };\n        World.prototype.getSubStepping = function() {\n            return this.m_subStepping;\n        };\n        /**\n         * Set flag to control automatic clearing of forces after each time step.\n         */ World.prototype.setAutoClearForces = function(flag) {\n            this.m_clearForces = flag;\n        };\n        /**\n         * Get the flag that controls automatic clearing of forces after each time step.\n         */ World.prototype.getAutoClearForces = function() {\n            return this.m_clearForces;\n        };\n        /**\n         * Manually clear the force buffer on all bodies. By default, forces are cleared\n         * automatically after each call to step. The default behavior is modified by\n         * calling setAutoClearForces. The purpose of this function is to support\n         * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n         * under a variable frame-rate. When you perform sub-stepping you will disable\n         * auto clearing of forces and instead call clearForces after all sub-steps are\n         * complete in one pass of your game loop.\n         *\n         * See {@link World.setAutoClearForces}\n         */ World.prototype.clearForces = function() {\n            for(var body = this.m_bodyList; body; body = body.getNext()){\n                body.m_force.setZero();\n                body.m_torque = 0.0;\n            }\n        };\n        /**\n         * Query the world for all fixtures that potentially overlap the provided AABB.\n         *\n         * @param aabb The query box.\n         * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n         */ World.prototype.queryAABB = function(aabb, callback) {\n            var broadPhase = this.m_broadPhase;\n            this.m_broadPhase.query(aabb, function(proxyId) {\n                var proxy = broadPhase.getUserData(proxyId);\n                return callback(proxy.fixture);\n            });\n        };\n        /**\n         * Ray-cast the world for all fixtures in the path of the ray. Your callback\n         * controls whether you get the closest point, any point, or n-points. The\n         * ray-cast ignores shapes that contain the starting point.\n         *\n         * @param point1 The ray starting point\n         * @param point2 The ray ending point\n         * @param callback A user implemented callback function.\n         */ World.prototype.rayCast = function(point1, point2, callback) {\n            var broadPhase = this.m_broadPhase;\n            this.m_broadPhase.rayCast({\n                maxFraction: 1.0,\n                p1: point1,\n                p2: point2\n            }, function(input, proxyId) {\n                var proxy = broadPhase.getUserData(proxyId);\n                var fixture = proxy.fixture;\n                var index = proxy.childIndex;\n                // @ts-ignore\n                var output = {}; // TODO GC\n                var hit = fixture.rayCast(output, input, index);\n                if (hit) {\n                    var fraction = output.fraction;\n                    var point = Vec2.add(Vec2.mulNumVec2(1.0 - fraction, input.p1), Vec2.mulNumVec2(fraction, input.p2));\n                    return callback(fixture, point, output.normal, fraction);\n                }\n                return input.maxFraction;\n            });\n        };\n        /**\n         * Get the number of broad-phase proxies.\n         */ World.prototype.getProxyCount = function() {\n            return this.m_broadPhase.getProxyCount();\n        };\n        /**\n         * Get the height of broad-phase dynamic tree.\n         */ World.prototype.getTreeHeight = function() {\n            return this.m_broadPhase.getTreeHeight();\n        };\n        /**\n         * Get the balance of broad-phase dynamic tree.\n         */ World.prototype.getTreeBalance = function() {\n            return this.m_broadPhase.getTreeBalance();\n        };\n        /**\n         * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n         * The minimum is 1.\n         */ World.prototype.getTreeQuality = function() {\n            return this.m_broadPhase.getTreeQuality();\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The body shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */ World.prototype.shiftOrigin = function(newOrigin) {\n            if (this.m_locked) return;\n            for(var b = this.m_bodyList; b; b = b.m_next){\n                b.m_xf.p.sub(newOrigin);\n                b.m_sweep.c0.sub(newOrigin);\n                b.m_sweep.c.sub(newOrigin);\n            }\n            for(var j = this.m_jointList; j; j = j.m_next)j.shiftOrigin(newOrigin);\n            this.m_broadPhase.shiftOrigin(newOrigin);\n        };\n        /**\n         * @internal Used for deserialize.\n         */ World.prototype._addBody = function(body) {\n            if (this.isLocked()) return;\n            // Add to world doubly linked list.\n            body.m_prev = null;\n            body.m_next = this.m_bodyList;\n            if (this.m_bodyList) this.m_bodyList.m_prev = body;\n            this.m_bodyList = body;\n            ++this.m_bodyCount;\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createBody = function(arg1, arg2) {\n            if (this.isLocked()) return null;\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) def = {\n                position: arg1,\n                angle: arg2\n            };\n            else if (typeof arg1 === \"object\") def = arg1;\n            var body = new Body(this, def);\n            this._addBody(body);\n            return body;\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createDynamicBody = function(arg1, arg2) {\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) def = {\n                position: arg1,\n                angle: arg2\n            };\n            else if (typeof arg1 === \"object\") def = arg1;\n            def.type = \"dynamic\";\n            return this.createBody(def);\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createKinematicBody = function(arg1, arg2) {\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) def = {\n                position: arg1,\n                angle: arg2\n            };\n            else if (typeof arg1 === \"object\") def = arg1;\n            def.type = \"kinematic\";\n            return this.createBody(def);\n        };\n        /**\n         * Destroy a rigid body given a definition. No reference to the definition is\n         * retained.\n         *\n         * Warning: This automatically deletes all associated shapes and joints.\n         *\n         * Warning: This function is locked during callbacks.\n         */ World.prototype.destroyBody = function(b) {\n            if (this.isLocked()) return;\n            if (b.m_destroyed) return false;\n            // Delete the attached joints.\n            var je = b.m_jointList;\n            while(je){\n                var je0 = je;\n                je = je.next;\n                this.publish(\"remove-joint\", je0.joint);\n                this.destroyJoint(je0.joint);\n                b.m_jointList = je;\n            }\n            b.m_jointList = null;\n            // Delete the attached contacts.\n            var ce = b.m_contactList;\n            while(ce){\n                var ce0 = ce;\n                ce = ce.next;\n                this.destroyContact(ce0.contact);\n                b.m_contactList = ce;\n            }\n            b.m_contactList = null;\n            // Delete the attached fixtures. This destroys broad-phase proxies.\n            var f = b.m_fixtureList;\n            while(f){\n                var f0 = f;\n                f = f.m_next;\n                this.publish(\"remove-fixture\", f0);\n                f0.destroyProxies(this.m_broadPhase);\n                b.m_fixtureList = f;\n            }\n            b.m_fixtureList = null;\n            // Remove world body list.\n            if (b.m_prev) b.m_prev.m_next = b.m_next;\n            if (b.m_next) b.m_next.m_prev = b.m_prev;\n            if (b == this.m_bodyList) this.m_bodyList = b.m_next;\n            b.m_destroyed = true;\n            --this.m_bodyCount;\n            this.publish(\"remove-body\", b);\n            return true;\n        };\n        /**\n         * Create a joint to constrain bodies together. No reference to the definition\n         * is retained. This may cause the connected bodies to cease colliding.\n         *\n         * Warning: This function is locked during callbacks.\n         */ World.prototype.createJoint = function(joint) {\n            if (this.isLocked()) return null;\n            // Connect to the world list.\n            joint.m_prev = null;\n            joint.m_next = this.m_jointList;\n            if (this.m_jointList) this.m_jointList.m_prev = joint;\n            this.m_jointList = joint;\n            ++this.m_jointCount;\n            // Connect to the bodies' doubly linked lists.\n            joint.m_edgeA.joint = joint;\n            joint.m_edgeA.other = joint.m_bodyB;\n            joint.m_edgeA.prev = null;\n            joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n            if (joint.m_bodyA.m_jointList) joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n            joint.m_bodyA.m_jointList = joint.m_edgeA;\n            joint.m_edgeB.joint = joint;\n            joint.m_edgeB.other = joint.m_bodyA;\n            joint.m_edgeB.prev = null;\n            joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n            if (joint.m_bodyB.m_jointList) joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n            joint.m_bodyB.m_jointList = joint.m_edgeB;\n            // If the joint prevents collisions, then flag any contacts for filtering.\n            if (joint.m_collideConnected == false) {\n                for(var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next)if (edge.other == joint.m_bodyA) // Flag the contact for filtering at the next time step (where either\n                // body is awake).\n                edge.contact.flagForFiltering();\n            }\n            // Note: creating a joint doesn't wake the bodies.\n            return joint;\n        };\n        /**\n         * Destroy a joint. This may cause the connected bodies to begin colliding.\n         * Warning: This function is locked during callbacks.\n         */ World.prototype.destroyJoint = function(joint) {\n            if (this.isLocked()) return;\n            // Remove from the doubly linked list.\n            if (joint.m_prev) joint.m_prev.m_next = joint.m_next;\n            if (joint.m_next) joint.m_next.m_prev = joint.m_prev;\n            if (joint == this.m_jointList) this.m_jointList = joint.m_next;\n            // Disconnect from bodies.\n            var bodyA = joint.m_bodyA;\n            var bodyB = joint.m_bodyB;\n            // Wake up connected bodies.\n            bodyA.setAwake(true);\n            bodyB.setAwake(true);\n            // Remove from body 1.\n            if (joint.m_edgeA.prev) joint.m_edgeA.prev.next = joint.m_edgeA.next;\n            if (joint.m_edgeA.next) joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n            if (joint.m_edgeA == bodyA.m_jointList) bodyA.m_jointList = joint.m_edgeA.next;\n            joint.m_edgeA.prev = null;\n            joint.m_edgeA.next = null;\n            // Remove from body 2\n            if (joint.m_edgeB.prev) joint.m_edgeB.prev.next = joint.m_edgeB.next;\n            if (joint.m_edgeB.next) joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n            if (joint.m_edgeB == bodyB.m_jointList) bodyB.m_jointList = joint.m_edgeB.next;\n            joint.m_edgeB.prev = null;\n            joint.m_edgeB.next = null;\n            --this.m_jointCount;\n            // If the joint prevents collisions, then flag any contacts for filtering.\n            if (joint.m_collideConnected == false) {\n                var edge = bodyB.getContactList();\n                while(edge){\n                    if (edge.other == bodyA) // Flag the contact for filtering at the next time step (where either\n                    // body is awake).\n                    edge.contact.flagForFiltering();\n                    edge = edge.next;\n                }\n            }\n            this.publish(\"remove-joint\", joint);\n        };\n        /**\n         * Take a time step. This performs collision detection, integration, and\n         * constraint solution.\n         *\n         * Broad-phase, narrow-phase, solve and solve time of impacts.\n         *\n         * @param timeStep Time step, this should not vary.\n         */ World.prototype.step = function(timeStep, velocityIterations, positionIterations) {\n            this.publish(\"pre-step\", timeStep);\n            if ((velocityIterations | 0) !== velocityIterations) // TODO: remove this in future\n            velocityIterations = 0;\n            velocityIterations = velocityIterations || this.m_velocityIterations;\n            positionIterations = positionIterations || this.m_positionIterations;\n            // If new fixtures were added, we need to find the new contacts.\n            if (this.m_newFixture) {\n                this.findNewContacts();\n                this.m_newFixture = false;\n            }\n            this.m_locked = true;\n            this.s_step.reset(timeStep);\n            this.s_step.velocityIterations = velocityIterations;\n            this.s_step.positionIterations = positionIterations;\n            this.s_step.warmStarting = this.m_warmStarting;\n            this.s_step.blockSolve = this.m_blockSolve;\n            // Update contacts. This is where some contacts are destroyed.\n            this.updateContacts();\n            // Integrate velocities, solve velocity constraints, and integrate positions.\n            if (this.m_stepComplete && timeStep > 0.0) {\n                this.m_solver.solveWorld(this.s_step);\n                // Synchronize fixtures, check for out of range bodies.\n                for(var b = this.m_bodyList; b; b = b.getNext()){\n                    // If a body was not in an island then it did not move.\n                    if (b.m_islandFlag == false) continue;\n                    if (b.isStatic()) continue;\n                    // Update fixtures (for broad-phase).\n                    b.synchronizeFixtures();\n                }\n                // Look for new contacts.\n                this.findNewContacts();\n            }\n            // Handle TOI events.\n            if (this.m_continuousPhysics && timeStep > 0.0) this.m_solver.solveWorldTOI(this.s_step);\n            if (this.m_clearForces) this.clearForces();\n            this.m_locked = false;\n            this.publish(\"post-step\", timeStep);\n        };\n        /**\n         * @internal\n         * Call this method to find new contacts.\n         */ World.prototype.findNewContacts = function() {\n            this.m_broadPhase.updatePairs(this.createContact);\n        };\n        /**\n         * @internal\n         * Removes old non-overlapping contacts, applies filters and updates contacts.\n         */ World.prototype.updateContacts = function() {\n            // Update awake contacts.\n            var c;\n            var next_c = this.m_contactList;\n            while(c = next_c){\n                next_c = c.getNext();\n                var fixtureA = c.getFixtureA();\n                var fixtureB = c.getFixtureB();\n                var indexA = c.getChildIndexA();\n                var indexB = c.getChildIndexB();\n                var bodyA = fixtureA.getBody();\n                var bodyB = fixtureB.getBody();\n                // Is this contact flagged for filtering?\n                if (c.m_filterFlag) {\n                    if (bodyB.shouldCollide(bodyA) == false) {\n                        this.destroyContact(c);\n                        continue;\n                    }\n                    if (fixtureB.shouldCollide(fixtureA) == false) {\n                        this.destroyContact(c);\n                        continue;\n                    }\n                    // Clear the filtering flag.\n                    c.m_filterFlag = false;\n                }\n                var activeA = bodyA.isAwake() && !bodyA.isStatic();\n                var activeB = bodyB.isAwake() && !bodyB.isStatic();\n                // At least one body must be awake and it must be dynamic or kinematic.\n                if (activeA == false && activeB == false) continue;\n                var proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n                var proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n                var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n                // Here we destroy contacts that cease to overlap in the broad-phase.\n                if (overlap == false) {\n                    this.destroyContact(c);\n                    continue;\n                }\n                // The contact persists.\n                c.update(this);\n            }\n        };\n        /**\n         * @internal\n         */ World.prototype.destroyContact = function(contact) {\n            Contact.destroy(contact, this);\n            // Remove from the world.\n            if (contact.m_prev) contact.m_prev.m_next = contact.m_next;\n            if (contact.m_next) contact.m_next.m_prev = contact.m_prev;\n            if (contact == this.m_contactList) this.m_contactList = contact.m_next;\n            --this.m_contactCount;\n        };\n        /**\n         * Register an event listener.\n         */ // tslint:disable-next-line:typedef\n        World.prototype.on = function(name, listener) {\n            if (typeof name !== \"string\" || typeof listener !== \"function\") return this;\n            if (!this._listeners) this._listeners = {};\n            if (!this._listeners[name]) this._listeners[name] = [];\n            this._listeners[name].push(listener);\n            return this;\n        };\n        /**\n         * Remove an event listener.\n         */ // tslint:disable-next-line:typedef\n        World.prototype.off = function(name, listener) {\n            if (typeof name !== \"string\" || typeof listener !== \"function\") return this;\n            var listeners = this._listeners && this._listeners[name];\n            if (!listeners || !listeners.length) return this;\n            var index = listeners.indexOf(listener);\n            if (index >= 0) listeners.splice(index, 1);\n            return this;\n        };\n        World.prototype.publish = function(name, arg1, arg2, arg3) {\n            var listeners = this._listeners && this._listeners[name];\n            if (!listeners || !listeners.length) return 0;\n            for(var l = 0; l < listeners.length; l++)listeners[l].call(this, arg1, arg2, arg3);\n            return listeners.length;\n        };\n        /**\n         * @internal\n         */ World.prototype.beginContact = function(contact) {\n            this.publish(\"begin-contact\", contact);\n        };\n        /**\n         * @internal\n         */ World.prototype.endContact = function(contact) {\n            this.publish(\"end-contact\", contact);\n        };\n        /**\n         * @internal\n         */ World.prototype.preSolve = function(contact, oldManifold) {\n            this.publish(\"pre-solve\", contact, oldManifold);\n        };\n        /**\n         * @internal\n         */ World.prototype.postSolve = function(contact, impulse) {\n            this.publish(\"post-solve\", contact, impulse);\n        };\n        return World;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var Vec3 = /** @class */ function() {\n        // tslint:disable-next-line:typedef\n        function Vec3(x, y, z) {\n            if (!(this instanceof Vec3)) return new Vec3(x, y, z);\n            if (typeof x === \"undefined\") {\n                this.x = 0;\n                this.y = 0;\n                this.z = 0;\n            } else if (typeof x === \"object\") {\n                this.x = x.x;\n                this.y = x.y;\n                this.z = x.z;\n            } else {\n                this.x = x;\n                this.y = y;\n                this.z = z;\n            }\n        }\n        /** @internal */ Vec3.prototype._serialize = function() {\n            return {\n                x: this.x,\n                y: this.y,\n                z: this.z\n            };\n        };\n        /** @internal */ Vec3._deserialize = function(data) {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = data.x;\n            obj.y = data.y;\n            obj.z = data.z;\n            return obj;\n        };\n        /** @internal */ Vec3.neo = function(x, y, z) {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = x;\n            obj.y = y;\n            obj.z = z;\n            return obj;\n        };\n        Vec3.zero = function() {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = 0;\n            obj.y = 0;\n            obj.z = 0;\n            return obj;\n        };\n        Vec3.clone = function(v) {\n            return Vec3.neo(v.x, v.y, v.z);\n        };\n        /** @internal */ Vec3.prototype.toString = function() {\n            return JSON.stringify(this);\n        };\n        /**\n         * Does this vector contain finite coordinates?\n         */ Vec3.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return math.isFinite(obj.x) && math.isFinite(obj.y) && math.isFinite(obj.z);\n        };\n        Vec3.assert = function(o) {\n            return;\n        };\n        Vec3.prototype.setZero = function() {\n            this.x = 0.0;\n            this.y = 0.0;\n            this.z = 0.0;\n            return this;\n        };\n        Vec3.prototype.set = function(x, y, z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            return this;\n        };\n        Vec3.prototype.add = function(w) {\n            this.x += w.x;\n            this.y += w.y;\n            this.z += w.z;\n            return this;\n        };\n        Vec3.prototype.sub = function(w) {\n            this.x -= w.x;\n            this.y -= w.y;\n            this.z -= w.z;\n            return this;\n        };\n        Vec3.prototype.mul = function(m) {\n            this.x *= m;\n            this.y *= m;\n            this.z *= m;\n            return this;\n        };\n        Vec3.areEqual = function(v, w) {\n            return v === w || typeof v === \"object\" && v !== null && typeof w === \"object\" && w !== null && v.x === w.x && v.y === w.y && v.z === w.z;\n        };\n        /**\n         * Perform the dot product on two vectors.\n         */ Vec3.dot = function(v, w) {\n            return v.x * w.x + v.y * w.y + v.z * w.z;\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         */ Vec3.cross = function(v, w) {\n            return new Vec3(v.y * w.z - v.z * w.y, v.z * w.x - v.x * w.z, v.x * w.y - v.y * w.x);\n        };\n        Vec3.add = function(v, w) {\n            return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n        };\n        Vec3.sub = function(v, w) {\n            return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n        };\n        Vec3.mul = function(v, m) {\n            return new Vec3(m * v.x, m * v.y, m * v.z);\n        };\n        Vec3.prototype.neg = function() {\n            this.x = -this.x;\n            this.y = -this.y;\n            this.z = -this.z;\n            return this;\n        };\n        Vec3.neg = function(v) {\n            return new Vec3(-v.x, -v.y, -v.z);\n        };\n        return Vec3;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A line segment (edge) shape. These can be connected in chains or loops to\n     * other edge shapes. The connectivity information is used to ensure correct\n     * contact normals.\n     */ var EdgeShape = /** @class */ function(_super) {\n        __extends(EdgeShape, _super);\n        function EdgeShape(v1, v2) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof EdgeShape)) return new EdgeShape(v1, v2);\n            _this = _super.call(this) || this;\n            _this.m_type = EdgeShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n            _this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n            _this.m_vertex0 = Vec2.zero();\n            _this.m_vertex3 = Vec2.zero();\n            _this.m_hasVertex0 = false;\n            _this.m_hasVertex3 = false;\n            return _this;\n        }\n        /** @internal */ EdgeShape.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                vertex1: this.m_vertex1,\n                vertex2: this.m_vertex2,\n                vertex0: this.m_vertex0,\n                vertex3: this.m_vertex3,\n                hasVertex0: this.m_hasVertex0,\n                hasVertex3: this.m_hasVertex3\n            };\n        };\n        /** @internal */ EdgeShape._deserialize = function(data) {\n            var shape = new EdgeShape(data.vertex1, data.vertex2);\n            if (shape.m_hasVertex0) shape.setPrevVertex(data.vertex0);\n            if (shape.m_hasVertex3) shape.setNextVertex(data.vertex3);\n            return shape;\n        };\n        /** @internal @deprecated */ EdgeShape.prototype.setNext = function(v) {\n            return this.setNextVertex(v);\n        };\n        /**\n         * Optional next vertex, used for smooth collision.\n         */ EdgeShape.prototype.setNextVertex = function(v) {\n            if (v) {\n                this.m_vertex3.setVec2(v);\n                this.m_hasVertex3 = true;\n            } else {\n                this.m_vertex3.setZero();\n                this.m_hasVertex3 = false;\n            }\n            return this;\n        };\n        /**\n         * Optional next vertex, used for smooth collision.\n         */ EdgeShape.prototype.getNextVertex = function() {\n            return this.m_vertex3;\n        };\n        /** @internal @deprecated */ EdgeShape.prototype.setPrev = function(v) {\n            return this.setPrevVertex(v);\n        };\n        /**\n         * Optional prev vertex, used for smooth collision.\n         */ EdgeShape.prototype.setPrevVertex = function(v) {\n            if (v) {\n                this.m_vertex0.setVec2(v);\n                this.m_hasVertex0 = true;\n            } else {\n                this.m_vertex0.setZero();\n                this.m_hasVertex0 = false;\n            }\n            return this;\n        };\n        /**\n         * Optional prev vertex, used for smooth collision.\n         */ EdgeShape.prototype.getPrevVertex = function() {\n            return this.m_vertex0;\n        };\n        /**\n         * Set this as an isolated edge.\n         */ EdgeShape.prototype._set = function(v1, v2) {\n            this.m_vertex1.setVec2(v1);\n            this.m_vertex2.setVec2(v2);\n            this.m_hasVertex0 = false;\n            this.m_hasVertex3 = false;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */ EdgeShape.prototype._clone = function() {\n            var clone = new EdgeShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_vertex1.setVec2(this.m_vertex1);\n            clone.m_vertex2.setVec2(this.m_vertex2);\n            clone.m_vertex0.setVec2(this.m_vertex0);\n            clone.m_vertex3.setVec2(this.m_vertex3);\n            clone.m_hasVertex0 = this.m_hasVertex0;\n            clone.m_hasVertex3 = this.m_hasVertex3;\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */ EdgeShape.prototype.getChildCount = function() {\n            return 1;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */ EdgeShape.prototype.testPoint = function(xf, p) {\n            return false;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */ EdgeShape.prototype.rayCast = function(output, input, xf, childIndex) {\n            // p = p1 + t * d\n            // v = v1 + s * e\n            // p1 + t * d = v1 + s * e\n            // s * e - t * d = p1 - v1\n            // NOT_USED(childIndex);\n            // Put the ray into the edge's frame of reference.\n            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n            var d = Vec2.sub(p2, p1);\n            var v1 = this.m_vertex1;\n            var v2 = this.m_vertex2;\n            var e = Vec2.sub(v2, v1);\n            var normal = Vec2.neo(e.y, -e.x);\n            normal.normalize();\n            // q = p1 + t * d\n            // dot(normal, q - v1) = 0\n            // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n            var numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n            var denominator = Vec2.dot(normal, d);\n            if (denominator == 0.0) return false;\n            var t = numerator / denominator;\n            if (t < 0.0 || input.maxFraction < t) return false;\n            var q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n            // q = v1 + s * r\n            // s = dot(q - v1, r) / dot(r, r)\n            var r = Vec2.sub(v2, v1);\n            var rr = Vec2.dot(r, r);\n            if (rr == 0.0) return false;\n            var s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n            if (s < 0.0 || 1.0 < s) return false;\n            output.fraction = t;\n            if (numerator > 0.0) output.normal = Rot.mulVec2(xf.q, normal).neg();\n            else output.normal = Rot.mulVec2(xf.q, normal);\n            return true;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */ EdgeShape.prototype.computeAABB = function(aabb, xf, childIndex) {\n            var v1 = Transform.mulVec2(xf, this.m_vertex1);\n            var v2 = Transform.mulVec2(xf, this.m_vertex2);\n            aabb.combinePoints(v1, v2);\n            aabb.extend(this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */ EdgeShape.prototype.computeMass = function(massData, density) {\n            massData.mass = 0.0;\n            massData.center.setCombine(0.5, this.m_vertex1, 0.5, this.m_vertex2);\n            massData.I = 0.0;\n        };\n        EdgeShape.prototype.computeDistanceProxy = function(proxy) {\n            proxy.m_vertices.push(this.m_vertex1);\n            proxy.m_vertices.push(this.m_vertex2);\n            proxy.m_count = 2;\n            proxy.m_radius = this.m_radius;\n        };\n        EdgeShape.TYPE = \"edge\";\n        return EdgeShape;\n    }(Shape);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A chain shape is a free form sequence of line segments. The chain has\n     * two-sided collision, so you can use inside and outside collision. Therefore,\n     * you may use any winding order. Connectivity information is used to create\n     * smooth collisions.\n     *\n     * WARNING: The chain will not collide properly if there are self-intersections.\n     */ var ChainShape = /** @class */ function(_super) {\n        __extends(ChainShape, _super);\n        function ChainShape(vertices, loop) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof ChainShape)) return new ChainShape(vertices, loop);\n            _this = _super.call(this) || this;\n            _this.m_type = ChainShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_vertices = [];\n            _this.m_count = 0;\n            _this.m_prevVertex = null;\n            _this.m_nextVertex = null;\n            _this.m_hasPrevVertex = false;\n            _this.m_hasNextVertex = false;\n            _this.m_isLoop = !!loop;\n            if (vertices && vertices.length) {\n                if (loop) _this._createLoop(vertices);\n                else _this._createChain(vertices);\n            }\n            return _this;\n        }\n        /** @internal */ ChainShape.prototype._serialize = function() {\n            var data = {\n                type: this.m_type,\n                vertices: this.m_vertices,\n                isLoop: this.m_isLoop,\n                hasPrevVertex: this.m_hasPrevVertex,\n                hasNextVertex: this.m_hasNextVertex,\n                prevVertex: null,\n                nextVertex: null\n            };\n            if (this.m_prevVertex) data.prevVertex = this.m_prevVertex;\n            if (this.m_nextVertex) data.nextVertex = this.m_nextVertex;\n            return data;\n        };\n        /** @internal */ ChainShape._deserialize = function(data, fixture, restore) {\n            var vertices = [];\n            if (data.vertices) for(var i = 0; i < data.vertices.length; i++)vertices.push(restore(Vec2, data.vertices[i]));\n            var shape = new ChainShape(vertices, data.isLoop);\n            if (data.prevVertex) shape.setPrevVertex(data.prevVertex);\n            if (data.nextVertex) shape.setNextVertex(data.nextVertex);\n            return shape;\n        };\n        // clear() {\n        //   this.m_vertices.length = 0;\n        //   this.m_count = 0;\n        // }\n        /**\n         * @internal\n         * Create a loop. This automatically adjusts connectivity.\n         *\n         * @param vertices an array of vertices, these are copied\n         * @param count the vertex count\n         */ ChainShape.prototype._createLoop = function(vertices) {\n            for(var i = 1; i < vertices.length; ++i){\n                vertices[i - 1];\n                vertices[i];\n            }\n            this.m_vertices = [];\n            this.m_count = vertices.length + 1;\n            for(var i = 0; i < vertices.length; ++i)this.m_vertices[i] = Vec2.clone(vertices[i]);\n            this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n            this.m_prevVertex = this.m_vertices[this.m_count - 2];\n            this.m_nextVertex = this.m_vertices[1];\n            this.m_hasPrevVertex = true;\n            this.m_hasNextVertex = true;\n            return this;\n        };\n        /**\n         * @internal\n         * Create a chain with isolated end vertices.\n         *\n         * @param vertices an array of vertices, these are copied\n         * @param count the vertex count\n         */ ChainShape.prototype._createChain = function(vertices) {\n            for(var i = 1; i < vertices.length; ++i){\n                // If the code crashes here, it means your vertices are too close together.\n                vertices[i - 1];\n                vertices[i];\n            }\n            this.m_count = vertices.length;\n            for(var i = 0; i < vertices.length; ++i)this.m_vertices[i] = Vec2.clone(vertices[i]);\n            this.m_hasPrevVertex = false;\n            this.m_hasNextVertex = false;\n            this.m_prevVertex = null;\n            this.m_nextVertex = null;\n            return this;\n        };\n        /** @internal */ ChainShape.prototype._reset = function() {\n            if (this.m_isLoop) this._createLoop(this.m_vertices);\n            else this._createChain(this.m_vertices);\n        };\n        /**\n         * Establish connectivity to a vertex that precedes the first vertex. Don't call\n         * this for loops.\n         */ ChainShape.prototype.setPrevVertex = function(prevVertex) {\n            this.m_prevVertex = prevVertex;\n            this.m_hasPrevVertex = true;\n        };\n        ChainShape.prototype.getPrevVertex = function() {\n            return this.m_prevVertex;\n        };\n        /**\n         * Establish connectivity to a vertex that follows the last vertex. Don't call\n         * this for loops.\n         */ ChainShape.prototype.setNextVertex = function(nextVertex) {\n            this.m_nextVertex = nextVertex;\n            this.m_hasNextVertex = true;\n        };\n        ChainShape.prototype.getNextVertex = function() {\n            return this.m_nextVertex;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */ ChainShape.prototype._clone = function() {\n            var clone = new ChainShape();\n            clone._createChain(this.m_vertices);\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_prevVertex = this.m_prevVertex;\n            clone.m_nextVertex = this.m_nextVertex;\n            clone.m_hasPrevVertex = this.m_hasPrevVertex;\n            clone.m_hasNextVertex = this.m_hasNextVertex;\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */ ChainShape.prototype.getChildCount = function() {\n            // edge count = vertex count - 1\n            return this.m_count - 1;\n        };\n        // Get a child edge.\n        ChainShape.prototype.getChildEdge = function(edge, childIndex) {\n            edge.m_type = EdgeShape.TYPE;\n            edge.m_radius = this.m_radius;\n            edge.m_vertex1 = this.m_vertices[childIndex];\n            edge.m_vertex2 = this.m_vertices[childIndex + 1];\n            if (childIndex > 0) {\n                edge.m_vertex0 = this.m_vertices[childIndex - 1];\n                edge.m_hasVertex0 = true;\n            } else {\n                edge.m_vertex0 = this.m_prevVertex;\n                edge.m_hasVertex0 = this.m_hasPrevVertex;\n            }\n            if (childIndex < this.m_count - 2) {\n                edge.m_vertex3 = this.m_vertices[childIndex + 2];\n                edge.m_hasVertex3 = true;\n            } else {\n                edge.m_vertex3 = this.m_nextVertex;\n                edge.m_hasVertex3 = this.m_hasNextVertex;\n            }\n        };\n        ChainShape.prototype.getVertex = function(index) {\n            if (index < this.m_count) return this.m_vertices[index];\n            else return this.m_vertices[0];\n        };\n        ChainShape.prototype.isLoop = function() {\n            return this.m_isLoop;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * This always return false.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */ ChainShape.prototype.testPoint = function(xf, p) {\n            return false;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */ ChainShape.prototype.rayCast = function(output, input, xf, childIndex) {\n            var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n            return edgeShape.rayCast(output, input, xf, 0);\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */ ChainShape.prototype.computeAABB = function(aabb, xf, childIndex) {\n            var v1 = Transform.mulVec2(xf, this.getVertex(childIndex));\n            var v2 = Transform.mulVec2(xf, this.getVertex(childIndex + 1));\n            aabb.combinePoints(v1, v2);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * Chains have zero mass.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */ ChainShape.prototype.computeMass = function(massData, density) {\n            massData.mass = 0.0;\n            massData.center = Vec2.zero();\n            massData.I = 0.0;\n        };\n        ChainShape.prototype.computeDistanceProxy = function(proxy, childIndex) {\n            proxy.m_buffer[0] = this.getVertex(childIndex);\n            proxy.m_buffer[1] = this.getVertex(childIndex + 1);\n            proxy.m_vertices = proxy.m_buffer;\n            proxy.m_count = 2;\n            proxy.m_radius = this.m_radius;\n        };\n        ChainShape.TYPE = \"chain\";\n        return ChainShape;\n    }(Shape);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A convex polygon. It is assumed that the interior of the polygon is to the\n     * left of each edge. Polygons have a maximum number of vertices equal to\n     * Settings.maxPolygonVertices. In most cases you should not need many vertices\n     * for a convex polygon. extends Shape\n     */ var PolygonShape = /** @class */ function(_super) {\n        __extends(PolygonShape, _super);\n        // @ts-ignore\n        function PolygonShape(vertices) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PolygonShape)) return new PolygonShape(vertices);\n            _this = _super.call(this) || this;\n            _this.m_type = PolygonShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_centroid = Vec2.zero();\n            _this.m_vertices = [];\n            _this.m_normals = [];\n            _this.m_count = 0;\n            if (vertices && vertices.length) _this._set(vertices);\n            return _this;\n        }\n        /** @internal */ PolygonShape.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                vertices: this.m_vertices\n            };\n        };\n        /** @internal */ PolygonShape._deserialize = function(data, fixture, restore) {\n            var vertices = [];\n            if (data.vertices) for(var i = 0; i < data.vertices.length; i++)vertices.push(restore(Vec2, data.vertices[i]));\n            var shape = new PolygonShape(vertices);\n            return shape;\n        };\n        PolygonShape.prototype.getVertex = function(index) {\n            return this.m_vertices[index];\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */ PolygonShape.prototype._clone = function() {\n            var clone = new PolygonShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_count = this.m_count;\n            clone.m_centroid.setVec2(this.m_centroid);\n            for(var i = 0; i < this.m_count; i++)clone.m_vertices.push(this.m_vertices[i].clone());\n            for(var i = 0; i < this.m_normals.length; i++)clone.m_normals.push(this.m_normals[i].clone());\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */ PolygonShape.prototype.getChildCount = function() {\n            return 1;\n        };\n        /** @internal */ PolygonShape.prototype._reset = function() {\n            this._set(this.m_vertices);\n        };\n        /**\n         * @internal\n         *\n         * Create a convex hull from the given array of local points. The count must be\n         * in the range [3, Settings.maxPolygonVertices].\n         *\n         * Warning: the points may be re-ordered, even if they form a convex polygon\n         * Warning: collinear points are handled but not removed. Collinear points may\n         * lead to poor stacking behavior.\n         */ PolygonShape.prototype._set = function(vertices) {\n            if (vertices.length < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            var n = math.min(vertices.length, Settings.maxPolygonVertices);\n            // Perform welding and copy vertices into local buffer.\n            var ps = []; // [Settings.maxPolygonVertices];\n            for(var i = 0; i < n; ++i){\n                var v = vertices[i];\n                var unique = true;\n                for(var j = 0; j < ps.length; ++j)if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n                    unique = false;\n                    break;\n                }\n                if (unique) ps.push(v);\n            }\n            n = ps.length;\n            if (n < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            // Create the convex hull using the Gift wrapping algorithm\n            // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n            // Find the right most point on the hull (in case of multiple points bottom most is used)\n            var i0 = 0;\n            var x0 = ps[0].x;\n            for(var i = 1; i < n; ++i){\n                var x = ps[i].x;\n                if (x > x0 || x === x0 && ps[i].y < ps[i0].y) {\n                    i0 = i;\n                    x0 = x;\n                }\n            }\n            var hull = []; // [Settings.maxPolygonVertices];\n            var m = 0;\n            var ih = i0;\n            while(true){\n                hull[m] = ih;\n                var ie = 0;\n                for(var j = 1; j < n; ++j){\n                    if (ie === ih) {\n                        ie = j;\n                        continue;\n                    }\n                    var r = Vec2.sub(ps[ie], ps[hull[m]]);\n                    var v = Vec2.sub(ps[j], ps[hull[m]]);\n                    var c = Vec2.crossVec2Vec2(r, v);\n                    // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n                    if (c < 0.0) ie = j;\n                    // Collinearity check\n                    if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) ie = j;\n                }\n                ++m;\n                ih = ie;\n                if (ie === i0) break;\n            }\n            if (m < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            this.m_count = m;\n            // Copy vertices.\n            this.m_vertices = [];\n            for(var i = 0; i < m; ++i)this.m_vertices[i] = ps[hull[i]];\n            // Compute normals. Ensure the edges have non-zero length.\n            for(var i = 0; i < m; ++i){\n                var i1 = i;\n                var i2 = i + 1 < m ? i + 1 : 0;\n                var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n                this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n                this.m_normals[i].normalize();\n            }\n            // Compute the polygon centroid.\n            this.m_centroid = ComputeCentroid(this.m_vertices, m);\n        };\n        /** @internal */ PolygonShape.prototype._setAsBox = function(hx, hy, center, angle) {\n            // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n            this.m_vertices[0] = Vec2.neo(hx, -hy);\n            this.m_vertices[1] = Vec2.neo(hx, hy);\n            this.m_vertices[2] = Vec2.neo(-hx, hy);\n            this.m_vertices[3] = Vec2.neo(-hx, -hy);\n            this.m_normals[0] = Vec2.neo(1.0, 0.0);\n            this.m_normals[1] = Vec2.neo(0.0, 1.0);\n            this.m_normals[2] = Vec2.neo(-1, 0.0);\n            this.m_normals[3] = Vec2.neo(0.0, -1);\n            this.m_count = 4;\n            if (Vec2.isValid(center)) {\n                angle = angle || 0;\n                this.m_centroid.setVec2(center);\n                var xf = Transform.identity();\n                xf.p.setVec2(center);\n                xf.q.setAngle(angle);\n                // Transform vertices and normals.\n                for(var i = 0; i < this.m_count; ++i){\n                    this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n                    this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n                }\n            }\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */ PolygonShape.prototype.testPoint = function(xf, p) {\n            var pLocal = Rot.mulTVec2(xf.q, Vec2.sub(p, xf.p));\n            for(var i = 0; i < this.m_count; ++i){\n                var dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));\n                if (dot > 0.0) return false;\n            }\n            return true;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */ PolygonShape.prototype.rayCast = function(output, input, xf, childIndex) {\n            // Put the ray into the polygon's frame of reference.\n            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n            var d = Vec2.sub(p2, p1);\n            var lower = 0.0;\n            var upper = input.maxFraction;\n            var index = -1;\n            for(var i = 0; i < this.m_count; ++i){\n                // p = p1 + a * d\n                // dot(normal, p - v) = 0\n                // dot(normal, p1 - v) + a * dot(normal, d) = 0\n                var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n                var denominator = Vec2.dot(this.m_normals[i], d);\n                if (denominator == 0.0) {\n                    if (numerator < 0.0) return false;\n                } else {\n                    // Note: we want this predicate without division:\n                    // lower < numerator / denominator, where denominator < 0\n                    // Since denominator < 0, we have to flip the inequality:\n                    // lower < numerator / denominator <==> denominator * lower > numerator.\n                    if (denominator < 0.0 && numerator < lower * denominator) {\n                        // Increase lower.\n                        // The segment enters this half-space.\n                        lower = numerator / denominator;\n                        index = i;\n                    } else if (denominator > 0.0 && numerator < upper * denominator) // Decrease upper.\n                    // The segment exits this half-space.\n                    upper = numerator / denominator;\n                }\n                // The use of epsilon here causes the assert on lower to trip\n                // in some cases. Apparently the use of epsilon was to make edge\n                // shapes work, but now those are handled separately.\n                // if (upper < lower - Math.EPSILON)\n                if (upper < lower) return false;\n            }\n            if (index >= 0) {\n                output.fraction = lower;\n                output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */ PolygonShape.prototype.computeAABB = function(aabb, xf, childIndex) {\n            var minX = Infinity;\n            var minY = Infinity;\n            var maxX = -Infinity;\n            var maxY = -Infinity;\n            for(var i = 0; i < this.m_count; ++i){\n                var v = Transform.mulVec2(xf, this.m_vertices[i]);\n                minX = math.min(minX, v.x);\n                maxX = math.max(maxX, v.x);\n                minY = math.min(minY, v.y);\n                maxY = math.max(maxY, v.y);\n            }\n            aabb.lowerBound.setNum(minX, minY);\n            aabb.upperBound.setNum(maxX, maxY);\n            aabb.extend(this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */ PolygonShape.prototype.computeMass = function(massData, density) {\n            var center = Vec2.zero();\n            var area = 0.0;\n            var I = 0.0;\n            // s is the reference point for forming triangles.\n            // It's location doesn't change the result (except for rounding error).\n            var s = Vec2.zero();\n            // This code would put the reference point inside the polygon.\n            for(var i = 0; i < this.m_count; ++i)s.add(this.m_vertices[i]);\n            s.mul(1.0 / this.m_count);\n            var k_inv3 = 1.0 / 3.0;\n            for(var i = 0; i < this.m_count; ++i){\n                // Triangle vertices.\n                var e1 = Vec2.sub(this.m_vertices[i], s);\n                var e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2.sub(this.m_vertices[0], s);\n                var D = Vec2.crossVec2Vec2(e1, e2);\n                var triangleArea = 0.5 * D;\n                area += triangleArea;\n                // Area weighted centroid\n                center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);\n                var ex1 = e1.x;\n                var ey1 = e1.y;\n                var ex2 = e2.x;\n                var ey2 = e2.y;\n                var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n                var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n                I += 0.25 * k_inv3 * D * (intx2 + inty2);\n            }\n            // Total mass\n            massData.mass = density * area;\n            center.mul(1.0 / area);\n            massData.center.setCombine(1, center, 1, s);\n            // Inertia tensor relative to the local origin (point s).\n            massData.I = density * I;\n            // Shift to center of mass then to original body origin.\n            massData.I += massData.mass * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));\n        };\n        /**\n         * Validate convexity. This is a very time consuming operation.\n         * @returns true if valid\n         */ PolygonShape.prototype.validate = function() {\n            for(var i = 0; i < this.m_count; ++i){\n                var i1 = i;\n                var i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n                var p = this.m_vertices[i1];\n                var e = Vec2.sub(this.m_vertices[i2], p);\n                for(var j = 0; j < this.m_count; ++j){\n                    if (j == i1 || j == i2) continue;\n                    var v = Vec2.sub(this.m_vertices[j], p);\n                    var c = Vec2.crossVec2Vec2(e, v);\n                    if (c < 0.0) return false;\n                }\n            }\n            return true;\n        };\n        PolygonShape.prototype.computeDistanceProxy = function(proxy) {\n            proxy.m_vertices = this.m_vertices;\n            proxy.m_count = this.m_count;\n            proxy.m_radius = this.m_radius;\n        };\n        PolygonShape.TYPE = \"polygon\";\n        return PolygonShape;\n    }(Shape);\n    function ComputeCentroid(vs, count) {\n        var c = Vec2.zero();\n        var area = 0.0;\n        // pRef is the reference point for forming triangles.\n        // It's location doesn't change the result (except for rounding error).\n        var pRef = Vec2.zero();\n        var i;\n        var inv3 = 1.0 / 3.0;\n        for(var i = 0; i < count; ++i){\n            // Triangle vertices.\n            var p1 = pRef;\n            var p2 = vs[i];\n            var p3 = i + 1 < count ? vs[i + 1] : vs[0];\n            var e1 = Vec2.sub(p2, p1);\n            var e2 = Vec2.sub(p3, p1);\n            var D = Vec2.crossVec2Vec2(e1, e2);\n            var triangleArea = 0.5 * D;\n            area += triangleArea;\n            // Area weighted centroid\n            c.addMul(triangleArea * inv3, p1);\n            c.addMul(triangleArea * inv3, p2);\n            c.addMul(triangleArea * inv3, p3);\n        }\n        c.mul(1.0 / area);\n        return c;\n    }\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A rectangle polygon which extend PolygonShape.\n     */ var BoxShape = /** @class */ function(_super) {\n        __extends(BoxShape, _super);\n        function BoxShape(hx, hy, center, angle) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof BoxShape)) return new BoxShape(hx, hy, center, angle);\n            _this = _super.call(this) || this;\n            _this._setAsBox(hx, hy, center, angle);\n            return _this;\n        }\n        BoxShape.TYPE = \"polygon\";\n        return BoxShape;\n    }(PolygonShape);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var CircleShape = /** @class */ function(_super) {\n        __extends(CircleShape, _super);\n        // tslint:disable-next-line:typedef\n        function CircleShape(a, b) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof CircleShape)) return new CircleShape(a, b);\n            _this = _super.call(this) || this;\n            _this.m_type = CircleShape.TYPE;\n            _this.m_p = Vec2.zero();\n            _this.m_radius = 1;\n            if (typeof a === \"object\" && Vec2.isValid(a)) {\n                _this.m_p.setVec2(a);\n                if (typeof b === \"number\") _this.m_radius = b;\n            } else if (typeof a === \"number\") _this.m_radius = a;\n            return _this;\n        }\n        /** @internal */ CircleShape.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                p: this.m_p,\n                radius: this.m_radius\n            };\n        };\n        /** @internal */ CircleShape._deserialize = function(data) {\n            return new CircleShape(data.p, data.radius);\n        };\n        // TODO: already defined in Shape\n        CircleShape.prototype.getRadius = function() {\n            return this.m_radius;\n        };\n        CircleShape.prototype.getCenter = function() {\n            return this.m_p;\n        };\n        CircleShape.prototype.getVertex = function(index) {\n            return this.m_p;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */ CircleShape.prototype._clone = function() {\n            var clone = new CircleShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_p = this.m_p.clone();\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */ CircleShape.prototype.getChildCount = function() {\n            return 1;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */ CircleShape.prototype.testPoint = function(xf, p) {\n            var center = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            var d = Vec2.sub(p, center);\n            return Vec2.dot(d, d) <= this.m_radius * this.m_radius;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */ CircleShape.prototype.rayCast = function(output, input, xf, childIndex) {\n            // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n            // From Section 3.1.2\n            // x = s + a * r\n            // norm(x) = radius\n            var position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            var s = Vec2.sub(input.p1, position);\n            var b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n            // Solve quadratic equation.\n            var r = Vec2.sub(input.p2, input.p1);\n            var c = Vec2.dot(s, r);\n            var rr = Vec2.dot(r, r);\n            var sigma = c * c - rr * b;\n            // Check for negative discriminant and short segment.\n            if (sigma < 0.0 || rr < math.EPSILON) return false;\n            // Find the point of intersection of the line with the circle.\n            var a = -(c + math.sqrt(sigma));\n            // Is the intersection point on the segment?\n            if (0.0 <= a && a <= input.maxFraction * rr) {\n                a /= rr;\n                output.fraction = a;\n                output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n                output.normal.normalize();\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */ CircleShape.prototype.computeAABB = function(aabb, xf, childIndex) {\n            var p = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            aabb.lowerBound.setNum(p.x - this.m_radius, p.y - this.m_radius);\n            aabb.upperBound.setNum(p.x + this.m_radius, p.y + this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */ CircleShape.prototype.computeMass = function(massData, density) {\n            massData.mass = density * math.PI * this.m_radius * this.m_radius;\n            massData.center = this.m_p;\n            // inertia about the local origin\n            massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));\n        };\n        CircleShape.prototype.computeDistanceProxy = function(proxy) {\n            proxy.m_vertices.push(this.m_p);\n            proxy.m_count = 1;\n            proxy.m_radius = this.m_radius;\n        };\n        CircleShape.TYPE = \"circle\";\n        return CircleShape;\n    }(Shape);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS$a = {\n        frequencyHz: 0.0,\n        dampingRatio: 0.0\n    };\n    /**\n     * A distance joint constrains two points on two bodies to remain at a fixed\n     * distance from each other. You can view this as a massless, rigid rod.\n     *\n     * @param anchorA Anchor A in global coordination.\n     * @param anchorB Anchor B in global coordination.\n     */ var DistanceJoint = /** @class */ function(_super) {\n        __extends(DistanceJoint, _super);\n        function DistanceJoint(def, bodyA, bodyB, anchorA, anchorB) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof DistanceJoint)) return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n            // order of constructor arguments is changed in v0.2\n            if (bodyB && anchorA && \"m_type\" in anchorA && \"x\" in bodyB && \"y\" in bodyB) {\n                var temp = bodyB;\n                bodyB = anchorA;\n                anchorA = temp;\n            }\n            def = options(def, DEFAULTS$a);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = DistanceJoint.TYPE;\n            // Solver shared\n            _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n            _this.m_length = math.isFinite(def.length) ? def.length : Vec2.distance(bodyA.getWorldPoint(_this.m_localAnchorA), bodyB.getWorldPoint(_this.m_localAnchorB));\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_impulse = 0.0;\n            _this.m_gamma = 0.0;\n            _this.m_bias = 0.0;\n            return _this;\n        // 1-D constrained system\n        // m (v2 - v1) = lambda\n        // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n        // x2 = x1 + h * v2\n        // 1-D mass-damper-spring system\n        // m (v2 - v1) + h * d * v2 + h * k *\n        // C = norm(p2 - p1) - L\n        // u = (p2 - p1) / norm(p2 - p1)\n        // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n        // J = [-u -cross(r1, u) u cross(r2, u)]\n        // K = J * invM * JT\n        // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n        }\n        /** @internal */ DistanceJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                length: this.m_length,\n                impulse: this.m_impulse,\n                gamma: this.m_gamma,\n                bias: this.m_bias\n            };\n        };\n        /** @internal */ DistanceJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new DistanceJoint(data);\n            return joint;\n        };\n        /** @internal */ DistanceJoint.prototype._setAnchors = function(def) {\n            if (def.anchorA) this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            else if (def.localAnchorA) this.m_localAnchorA.setVec2(def.localAnchorA);\n            if (def.anchorB) this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            else if (def.localAnchorB) this.m_localAnchorB.setVec2(def.localAnchorB);\n            if (def.length > 0) this.m_length = +def.length;\n            else if (def.length < 0) ;\n            else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) this.m_length = Vec2.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA), this.m_bodyB.getWorldPoint(this.m_localAnchorB));\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */ DistanceJoint.prototype.getLocalAnchorA = function() {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */ DistanceJoint.prototype.getLocalAnchorB = function() {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the natural length. Manipulating the length can lead to non-physical\n         * behavior when the frequency is zero.\n         */ DistanceJoint.prototype.setLength = function(length) {\n            this.m_length = length;\n        };\n        /**\n         * Get the natural length.\n         */ DistanceJoint.prototype.getLength = function() {\n            return this.m_length;\n        };\n        DistanceJoint.prototype.setFrequency = function(hz) {\n            this.m_frequencyHz = hz;\n        };\n        DistanceJoint.prototype.getFrequency = function() {\n            return this.m_frequencyHz;\n        };\n        DistanceJoint.prototype.setDampingRatio = function(ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        DistanceJoint.prototype.getDampingRatio = function() {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ DistanceJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ DistanceJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ DistanceJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ DistanceJoint.prototype.getReactionTorque = function(inv_dt) {\n            return 0.0;\n        };\n        DistanceJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n            // Handle singularity.\n            var length = this.m_u.length();\n            if (length > Settings.linearSlop) this.m_u.mul(1.0 / length);\n            else this.m_u.setNum(0.0, 0.0);\n            var crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n            var crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n            var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;\n            // Compute the effective mass matrix.\n            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            if (this.m_frequencyHz > 0.0) {\n                var C = length - this.m_length;\n                // Frequency\n                var omega = 2.0 * math.PI * this.m_frequencyHz;\n                // Damping coefficient\n                var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n                // Spring stiffness\n                var k = this.m_mass * omega * omega;\n                // magic formulas\n                var h = step.dt;\n                this.m_gamma = h * (d + h * k);\n                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n                this.m_bias = C * h * k * this.m_gamma;\n                invMass += this.m_gamma;\n                this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            } else {\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            if (step.warmStarting) {\n                // Scale the impulse to support a variable time step.\n                this.m_impulse *= step.dtRatio;\n                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            } else this.m_impulse = 0.0;\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        DistanceJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Cdot = dot(u, v + cross(w, r))\n            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n            var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n            var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n            this.m_impulse += impulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_u);\n            vA.subMul(this.m_invMassA, P);\n            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n            vB.addMul(this.m_invMassB, P);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ DistanceJoint.prototype.solvePositionConstraints = function(step) {\n            if (this.m_frequencyHz > 0.0) // There is no position correction for soft distance constraints.\n            return true;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            var u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n            var length = u.normalize();\n            var C = length - this.m_length;\n            C = math.clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n            var impulse = -this.m_mass * C;\n            var P = Vec2.mulNumVec2(impulse, u);\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return math.abs(C) < Settings.linearSlop;\n        };\n        DistanceJoint.TYPE = \"distance-joint\";\n        return DistanceJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS$9 = {\n        maxForce: 0.0,\n        maxTorque: 0.0\n    };\n    /**\n     * Friction joint. This is used for top-down friction. It provides 2D\n     * translational friction and angular friction.\n     *\n     * @param anchor Anchor in global coordination.\n     */ var FrictionJoint = /** @class */ function(_super) {\n        __extends(FrictionJoint, _super);\n        function FrictionJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof FrictionJoint)) return new FrictionJoint(def, bodyA, bodyB, anchor);\n            def = options(def, DEFAULTS$9);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = FrictionJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            // Solver shared\n            _this.m_linearImpulse = Vec2.zero();\n            _this.m_angularImpulse = 0.0;\n            _this.m_maxForce = def.maxForce;\n            _this.m_maxTorque = def.maxTorque;\n            return _this;\n        // Point-to-point constraint\n        // Cdot = v2 - v1\n        // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n        // J = [-I -r1_skew I r2_skew ]\n        // Identity used:\n        // w k % (rx i + ry j) = w * (-ry i + rx j)\n        // Angle constraint\n        // Cdot = w2 - w1\n        // J = [0 0 -1 0 0 1]\n        // K = invI1 + invI2\n        }\n        /** @internal */ FrictionJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                maxForce: this.m_maxForce,\n                maxTorque: this.m_maxTorque,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB\n            };\n        };\n        /** @internal */ FrictionJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new FrictionJoint(data);\n            return joint;\n        };\n        /** @internal */ FrictionJoint.prototype._setAnchors = function(def) {\n            if (def.anchorA) this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            else if (def.localAnchorA) this.m_localAnchorA.setVec2(def.localAnchorA);\n            if (def.anchorB) this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            else if (def.localAnchorB) this.m_localAnchorB.setVec2(def.localAnchorB);\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */ FrictionJoint.prototype.getLocalAnchorA = function() {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */ FrictionJoint.prototype.getLocalAnchorB = function() {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the maximum friction force in N.\n         */ FrictionJoint.prototype.setMaxForce = function(force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum friction force in N.\n         */ FrictionJoint.prototype.getMaxForce = function() {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the maximum friction torque in N*m.\n         */ FrictionJoint.prototype.setMaxTorque = function(torque) {\n            this.m_maxTorque = torque;\n        };\n        /**\n         * Get the maximum friction torque in N*m.\n         */ FrictionJoint.prototype.getMaxTorque = function() {\n            return this.m_maxTorque;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ FrictionJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ FrictionJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ FrictionJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ FrictionJoint.prototype.getReactionTorque = function(inv_dt) {\n            return inv_dt * this.m_angularImpulse;\n        };\n        FrictionJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective mass matrix.\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat22();\n            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n            this.m_linearMass = K.getInverse();\n            this.m_angularMass = iA + iB;\n            if (this.m_angularMass > 0.0) this.m_angularMass = 1.0 / this.m_angularMass;\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_linearImpulse.mul(step.dtRatio);\n                this.m_angularImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n            } else {\n                this.m_linearImpulse.setZero();\n                this.m_angularImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        FrictionJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var h = step.dt; // float\n            var Cdot = wB - wA; // float\n            var impulse = -this.m_angularMass * Cdot; // float\n            var oldImpulse = this.m_angularImpulse; // float\n            var maxImpulse = h * this.m_maxTorque; // float\n            this.m_angularImpulse = math.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n            impulse = this.m_angularImpulse - oldImpulse;\n            wA -= iA * impulse;\n            wB += iB * impulse;\n            var Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA))); // Vec2\n            var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2\n            var oldImpulse = this.m_linearImpulse; // Vec2\n            this.m_linearImpulse.add(impulse);\n            var maxImpulse = h * this.m_maxForce; // float\n            if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n                this.m_linearImpulse.normalize();\n                this.m_linearImpulse.mul(maxImpulse);\n            }\n            impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n            vA.subMul(mA, impulse);\n            wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n            vB.addMul(mB, impulse);\n            wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ FrictionJoint.prototype.solvePositionConstraints = function(step) {\n            return true;\n        };\n        FrictionJoint.TYPE = \"friction-joint\";\n        return FrictionJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ /**\n     * A 3-by-3 matrix. Stored in column-major order.\n     */ var Mat33 = /** @class */ function() {\n        function Mat33(a, b, c) {\n            if (typeof a === \"object\" && a !== null) {\n                this.ex = Vec3.clone(a);\n                this.ey = Vec3.clone(b);\n                this.ez = Vec3.clone(c);\n            } else {\n                this.ex = Vec3.zero();\n                this.ey = Vec3.zero();\n                this.ez = Vec3.zero();\n            }\n        }\n        /** @internal */ Mat33.prototype.toString = function() {\n            return JSON.stringify(this);\n        };\n        Mat33.isValid = function(obj) {\n            if (obj === null || typeof obj === \"undefined\") return false;\n            return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n        };\n        Mat33.assert = function(o) {\n            return;\n        };\n        /**\n         * Set this matrix to all zeros.\n         */ Mat33.prototype.setZero = function() {\n            this.ex.setZero();\n            this.ey.setZero();\n            this.ez.setZero();\n            return this;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases.\n         */ Mat33.prototype.solve33 = function(v) {\n            var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n            if (det !== 0.0) det = 1.0 / det;\n            var r = new Vec3();\n            r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));\n            r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));\n            r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));\n            return r;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n         * equation.\n         */ Mat33.prototype.solve22 = function(v) {\n            var a11 = this.ex.x;\n            var a12 = this.ey.x;\n            var a21 = this.ex.y;\n            var a22 = this.ey.y;\n            var det = a11 * a22 - a12 * a21;\n            if (det !== 0.0) det = 1.0 / det;\n            var r = Vec2.zero();\n            r.x = det * (a22 * v.x - a12 * v.y);\n            r.y = det * (a11 * v.y - a21 * v.x);\n            return r;\n        };\n        /**\n         * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n         * singular.\n         */ Mat33.prototype.getInverse22 = function(M) {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) det = 1.0 / det;\n            M.ex.x = det * d;\n            M.ey.x = -det * b;\n            M.ex.z = 0.0;\n            M.ex.y = -det * c;\n            M.ey.y = det * a;\n            M.ey.z = 0.0;\n            M.ez.x = 0.0;\n            M.ez.y = 0.0;\n            M.ez.z = 0.0;\n        };\n        /**\n         * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n         * if singular.\n         */ Mat33.prototype.getSymInverse33 = function(M) {\n            var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n            if (det !== 0.0) det = 1.0 / det;\n            var a11 = this.ex.x;\n            var a12 = this.ey.x;\n            var a13 = this.ez.x;\n            var a22 = this.ey.y;\n            var a23 = this.ez.y;\n            var a33 = this.ez.z;\n            M.ex.x = det * (a22 * a33 - a23 * a23);\n            M.ex.y = det * (a13 * a23 - a12 * a33);\n            M.ex.z = det * (a12 * a23 - a13 * a22);\n            M.ey.x = M.ex.y;\n            M.ey.y = det * (a11 * a33 - a13 * a13);\n            M.ey.z = det * (a13 * a12 - a11 * a23);\n            M.ez.x = M.ex.z;\n            M.ez.y = M.ey.z;\n            M.ez.z = det * (a11 * a22 - a12 * a12);\n        };\n        // tslint:disable-next-line:typedef\n        Mat33.mul = function(a, b) {\n            if (b && \"z\" in b && \"y\" in b && \"x\" in b) {\n                var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n                var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n                var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n                return new Vec3(x, y, z);\n            } else if (b && \"y\" in b && \"x\" in b) {\n                var x = a.ex.x * b.x + a.ey.x * b.y;\n                var y = a.ex.y * b.x + a.ey.y * b.y;\n                return Vec2.neo(x, y);\n            }\n        };\n        Mat33.mulVec3 = function(a, b) {\n            var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n            var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n            var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n            return new Vec3(x, y, z);\n        };\n        Mat33.mulVec2 = function(a, b) {\n            var x = a.ex.x * b.x + a.ey.x * b.y;\n            var y = a.ex.y * b.x + a.ey.y * b.y;\n            return Vec2.neo(x, y);\n        };\n        Mat33.add = function(a, b) {\n            return new Mat33(Vec3.add(a.ex, b.ex), Vec3.add(a.ey, b.ey), Vec3.add(a.ez, b.ez));\n        };\n        return Mat33;\n    }();\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var inactiveLimit$2 = 0;\n    var atLowerLimit$1 = 1;\n    var atUpperLimit$2 = 2;\n    var equalLimits$1 = 3;\n    var DEFAULTS$8 = {\n        lowerAngle: 0.0,\n        upperAngle: 0.0,\n        maxMotorTorque: 0.0,\n        motorSpeed: 0.0,\n        enableLimit: false,\n        enableMotor: false\n    };\n    /**\n     * A revolute joint constrains two bodies to share a common point while they are\n     * free to rotate about the point. The relative rotation about the shared point\n     * is the joint angle. You can limit the relative rotation with a joint limit\n     * that specifies a lower and upper angle. You can use a motor to drive the\n     * relative rotation about the shared point. A maximum motor torque is provided\n     * so that infinite forces are not generated.\n     */ var RevoluteJoint = /** @class */ function(_super) {\n        __extends(RevoluteJoint, _super);\n        // @ts-ignore\n        function RevoluteJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof RevoluteJoint)) return new RevoluteJoint(def, bodyA, bodyB, anchor);\n            def = options(def, DEFAULTS$8);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            // effective mass for point-to-point constraint.\n            /** @internal */ _this.m_mass = new Mat33();\n            /** @internal */ _this.m_limitState = inactiveLimit$2; // TODO enum\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = RevoluteJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_referenceAngle = math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_impulse = new Vec3();\n            _this.m_motorImpulse = 0.0;\n            _this.m_lowerAngle = def.lowerAngle;\n            _this.m_upperAngle = def.upperAngle;\n            _this.m_maxMotorTorque = def.maxMotorTorque;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableLimit = def.enableLimit;\n            _this.m_enableMotor = def.enableMotor;\n            return _this;\n        // Point-to-point constraint\n        // C = p2 - p1\n        // Cdot = v2 - v1\n        // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n        // J = [-I -r1_skew I r2_skew ]\n        // Identity used:\n        // w k % (rx i + ry j) = w * (-ry i + rx j)\n        // Motor constraint\n        // Cdot = w2 - w1\n        // J = [0 0 -1 0 0 1]\n        // K = invI1 + invI2\n        }\n        /** @internal */ RevoluteJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                lowerAngle: this.m_lowerAngle,\n                upperAngle: this.m_upperAngle,\n                maxMotorTorque: this.m_maxMotorTorque,\n                motorSpeed: this.m_motorSpeed,\n                enableLimit: this.m_enableLimit,\n                enableMotor: this.m_enableMotor,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                referenceAngle: this.m_referenceAngle\n            };\n        };\n        /** @internal */ RevoluteJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new RevoluteJoint(data);\n            return joint;\n        };\n        /** @internal */ RevoluteJoint.prototype._setAnchors = function(def) {\n            if (def.anchorA) this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            else if (def.localAnchorA) this.m_localAnchorA.setVec2(def.localAnchorA);\n            if (def.anchorB) this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            else if (def.localAnchorB) this.m_localAnchorB.setVec2(def.localAnchorB);\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */ RevoluteJoint.prototype.getLocalAnchorA = function() {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */ RevoluteJoint.prototype.getLocalAnchorB = function() {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Get the reference angle.\n         */ RevoluteJoint.prototype.getReferenceAngle = function() {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint angle in radians.\n         */ RevoluteJoint.prototype.getJointAngle = function() {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint angle speed in radians per second.\n         */ RevoluteJoint.prototype.getJointSpeed = function() {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            return bB.m_angularVelocity - bA.m_angularVelocity;\n        };\n        /**\n         * Is the joint motor enabled?\n         */ RevoluteJoint.prototype.isMotorEnabled = function() {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */ RevoluteJoint.prototype.enableMotor = function(flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Get the current motor torque given the inverse time step. Unit is N*m.\n         */ RevoluteJoint.prototype.getMotorTorque = function(inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Set the motor speed in radians per second.\n         */ RevoluteJoint.prototype.setMotorSpeed = function(speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Get the motor speed in radians per second.\n         */ RevoluteJoint.prototype.getMotorSpeed = function() {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Set the maximum motor torque, usually in N-m.\n         */ RevoluteJoint.prototype.setMaxMotorTorque = function(torque) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorTorque = torque;\n        };\n        RevoluteJoint.prototype.getMaxMotorTorque = function() {\n            return this.m_maxMotorTorque;\n        };\n        /**\n         * Is the joint limit enabled?\n         */ RevoluteJoint.prototype.isLimitEnabled = function() {\n            return this.m_enableLimit;\n        };\n        /**\n         * Enable/disable the joint limit.\n         */ RevoluteJoint.prototype.enableLimit = function(flag) {\n            if (flag != this.m_enableLimit) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_enableLimit = flag;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Get the lower joint limit in radians.\n         */ RevoluteJoint.prototype.getLowerLimit = function() {\n            return this.m_lowerAngle;\n        };\n        /**\n         * Get the upper joint limit in radians.\n         */ RevoluteJoint.prototype.getUpperLimit = function() {\n            return this.m_upperAngle;\n        };\n        /**\n         * Set the joint limits in radians.\n         */ RevoluteJoint.prototype.setLimits = function(lower, upper) {\n            if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_impulse.z = 0.0;\n                this.m_lowerAngle = lower;\n                this.m_upperAngle = upper;\n            }\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ RevoluteJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ RevoluteJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force given the inverse time step. Unit is N.\n         */ RevoluteJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque due to the joint limit given the inverse time step.\n         * Unit is N*m.\n         */ RevoluteJoint.prototype.getReactionTorque = function(inv_dt) {\n            return inv_dt * this.m_impulse.z;\n        };\n        RevoluteJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var fixedRotation = iA + iB === 0.0; // bool\n            this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\n            this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n            this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n            this.m_mass.ex.y = this.m_mass.ey.x;\n            this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\n            this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n            this.m_mass.ex.z = this.m_mass.ez.x;\n            this.m_mass.ey.z = this.m_mass.ez.y;\n            this.m_mass.ez.z = iA + iB;\n            this.m_motorMass = iA + iB;\n            if (this.m_motorMass > 0.0) this.m_motorMass = 1.0 / this.m_motorMass;\n            if (this.m_enableMotor == false || fixedRotation) this.m_motorImpulse = 0.0;\n            if (this.m_enableLimit && fixedRotation == false) {\n                var jointAngle = aB - aA - this.m_referenceAngle; // float\n                if (math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) this.m_limitState = equalLimits$1;\n                else if (jointAngle <= this.m_lowerAngle) {\n                    if (this.m_limitState != atLowerLimit$1) this.m_impulse.z = 0.0;\n                    this.m_limitState = atLowerLimit$1;\n                } else if (jointAngle >= this.m_upperAngle) {\n                    if (this.m_limitState != atUpperLimit$2) this.m_impulse.z = 0.0;\n                    this.m_limitState = atUpperLimit$2;\n                } else {\n                    this.m_limitState = inactiveLimit$2;\n                    this.m_impulse.z = 0.0;\n                }\n            } else this.m_limitState = inactiveLimit$2;\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n            } else {\n                this.m_impulse.setZero();\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        RevoluteJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var fixedRotation = iA + iB === 0.0; // bool\n            // Solve motor constraint.\n            if (this.m_enableMotor && this.m_limitState != equalLimits$1 && fixedRotation == false) {\n                var Cdot = wB - wA - this.m_motorSpeed; // float\n                var impulse = -this.m_motorMass * Cdot; // float\n                var oldImpulse = this.m_motorImpulse; // float\n                var maxImpulse = step.dt * this.m_maxMotorTorque; // float\n                this.m_motorImpulse = math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve limit constraint.\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$2 && fixedRotation == false) {\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                var Cdot2 = wB - wA; // float\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n                var impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3\n                if (this.m_limitState == equalLimits$1) this.m_impulse.add(impulse);\n                else if (this.m_limitState == atLowerLimit$1) {\n                    var newImpulse = this.m_impulse.z + impulse.z; // float\n                    if (newImpulse < 0.0) {\n                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n                        var reduced = this.m_mass.solve22(rhs); // Vec2\n                        impulse.x = reduced.x;\n                        impulse.y = reduced.y;\n                        impulse.z = -this.m_impulse.z;\n                        this.m_impulse.x += reduced.x;\n                        this.m_impulse.y += reduced.y;\n                        this.m_impulse.z = 0.0;\n                    } else this.m_impulse.add(impulse);\n                } else if (this.m_limitState == atUpperLimit$2) {\n                    var newImpulse = this.m_impulse.z + impulse.z; // float\n                    if (newImpulse > 0.0) {\n                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n                        var reduced = this.m_mass.solve22(rhs); // Vec2\n                        impulse.x = reduced.x;\n                        impulse.y = reduced.y;\n                        impulse.z = -this.m_impulse.z;\n                        this.m_impulse.x += reduced.x;\n                        this.m_impulse.y += reduced.y;\n                        this.m_impulse.z = 0.0;\n                    } else this.m_impulse.add(impulse);\n                }\n                var P = Vec2.neo(impulse.x, impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n            } else {\n                // Solve point-to-point constraint\n                var Cdot = Vec2.zero();\n                Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                var impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2\n                this.m_impulse.x += impulse.x;\n                this.m_impulse.y += impulse.y;\n                vA.subMul(mA, impulse);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n                vB.addMul(mB, impulse);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ RevoluteJoint.prototype.solvePositionConstraints = function(step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var angularError = 0.0; // float\n            var positionError = 0.0; // float\n            var fixedRotation = this.m_invIA + this.m_invIB == 0.0; // bool\n            // Solve angular limit constraint.\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$2 && fixedRotation == false) {\n                var angle = aB - aA - this.m_referenceAngle; // float\n                var limitImpulse = 0.0; // float\n                if (this.m_limitState == equalLimits$1) {\n                    // Prevent large angular corrections\n                    var C = math.clamp(angle - this.m_lowerAngle, -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float\n                    limitImpulse = -this.m_motorMass * C;\n                    angularError = math.abs(C);\n                } else if (this.m_limitState == atLowerLimit$1) {\n                    var C = angle - this.m_lowerAngle; // float\n                    angularError = -C;\n                    // Prevent large angular corrections and allow some slop.\n                    C = math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection, 0.0);\n                    limitImpulse = -this.m_motorMass * C;\n                } else if (this.m_limitState == atUpperLimit$2) {\n                    var C = angle - this.m_upperAngle; // float\n                    angularError = C;\n                    // Prevent large angular corrections and allow some slop.\n                    C = math.clamp(C - Settings.angularSlop, 0.0, Settings.maxAngularCorrection);\n                    limitImpulse = -this.m_motorMass * C;\n                }\n                aA -= this.m_invIA * limitImpulse;\n                aB += this.m_invIB * limitImpulse;\n            }\n            qA.setAngle(aA);\n            qB.setAngle(aB);\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n            var C = Vec2.zero();\n            C.addCombine(1, cB, 1, rB);\n            C.subCombine(1, cA, 1, rA);\n            positionError = C.length();\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var K = new Mat22();\n            K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n            K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n            var impulse = Vec2.neg(K.solve(C)); // Vec2\n            cA.subMul(mA, impulse);\n            aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n            cB.addMul(mB, impulse);\n            aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n        };\n        RevoluteJoint.TYPE = \"revolute-joint\";\n        return RevoluteJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var inactiveLimit$1 = 0;\n    var atLowerLimit = 1;\n    var atUpperLimit$1 = 2;\n    var equalLimits = 3;\n    var DEFAULTS$7 = {\n        enableLimit: false,\n        lowerTranslation: 0.0,\n        upperTranslation: 0.0,\n        enableMotor: false,\n        maxMotorForce: 0.0,\n        motorSpeed: 0.0\n    };\n    /**\n     * A prismatic joint. This joint provides one degree of freedom: translation\n     * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n     * joint limit to restrict the range of motion and a joint motor to drive the\n     * motion or to model joint friction.\n     */ var PrismaticJoint = /** @class */ function(_super) {\n        __extends(PrismaticJoint, _super);\n        function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PrismaticJoint)) return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n            def = options(def, DEFAULTS$7);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = PrismaticJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n            _this.m_localXAxisA.normalize();\n            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);\n            _this.m_referenceAngle = math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_impulse = new Vec3();\n            _this.m_motorMass = 0.0;\n            _this.m_motorImpulse = 0.0;\n            _this.m_lowerTranslation = def.lowerTranslation;\n            _this.m_upperTranslation = def.upperTranslation;\n            _this.m_maxMotorForce = def.maxMotorForce;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableLimit = def.enableLimit;\n            _this.m_enableMotor = def.enableMotor;\n            _this.m_limitState = inactiveLimit$1;\n            _this.m_axis = Vec2.zero();\n            _this.m_perp = Vec2.zero();\n            _this.m_K = new Mat33();\n            return _this;\n        // Linear constraint (point-to-line)\n        // d = p2 - p1 = x2 + r2 - x1 - r1\n        // C = dot(perp, d)\n        // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n        // cross(w1, r1))\n        // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n        // dot(cross(r2, perp), v2)\n        // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n        //\n        // Angular constraint\n        // C = a2 - a1 + a_initial\n        // Cdot = w2 - w1\n        // J = [0 0 -1 0 0 1]\n        //\n        // K = J * invM * JT\n        //\n        // J = [-a -s1 a s2]\n        // [0 -1 0 1]\n        // a = perp\n        // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n        // s2 = cross(r2, a) = cross(p2 - x2, a)\n        // Motor/Limit linear constraint\n        // C = dot(ax1, d)\n        // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n        // dot(cross(r2, ax1), v2)\n        // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n        // Block Solver\n        // We develop a block solver that includes the joint limit. This makes the\n        // limit stiff (inelastic) even\n        // when the mass has poor distribution (leading to large torques about the\n        // joint anchor points).\n        //\n        // The Jacobian has 3 rows:\n        // J = [-uT -s1 uT s2] // linear\n        // [0 -1 0 1] // angular\n        // [-vT -a1 vT a2] // limit\n        //\n        // u = perp\n        // v = axis\n        // s1 = cross(d + r1, u), s2 = cross(r2, u)\n        // a1 = cross(d + r1, v), a2 = cross(r2, v)\n        // M * (v2 - v1) = JT * df\n        // J * v2 = bias\n        //\n        // v2 = v1 + invM * JT * df\n        // J * (v1 + invM * JT * df) = bias\n        // K * df = bias - J * v1 = -Cdot\n        // K = J * invM * JT\n        // Cdot = J * v1 - bias\n        //\n        // Now solve for f2.\n        // df = f2 - f1\n        // K * (f2 - f1) = -Cdot\n        // f2 = invK * (-Cdot) + f1\n        //\n        // Clamp accumulated limit impulse.\n        // lower: f2(3) = max(f2(3), 0)\n        // upper: f2(3) = min(f2(3), 0)\n        //\n        // Solve for correct f2(1:2)\n        // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n        // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n        // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n        // K(1:2,1:2) * f1(1:2)\n        // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n        // f1(1:2)\n        //\n        // Now compute impulse to be applied:\n        // df = f2 - f1\n        }\n        /** @internal */ PrismaticJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                lowerTranslation: this.m_lowerTranslation,\n                upperTranslation: this.m_upperTranslation,\n                maxMotorForce: this.m_maxMotorForce,\n                motorSpeed: this.m_motorSpeed,\n                enableLimit: this.m_enableLimit,\n                enableMotor: this.m_enableMotor,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                localAxisA: this.m_localXAxisA,\n                referenceAngle: this.m_referenceAngle\n            };\n        };\n        /** @internal */ PrismaticJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.localAxisA = Vec2.clone(data.localAxisA);\n            var joint = new PrismaticJoint(data);\n            return joint;\n        };\n        /** @internal */ PrismaticJoint.prototype._setAnchors = function(def) {\n            if (def.anchorA) this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            else if (def.localAnchorA) this.m_localAnchorA.setVec2(def.localAnchorA);\n            if (def.anchorB) this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            else if (def.localAnchorB) this.m_localAnchorB.setVec2(def.localAnchorB);\n            if (def.localAxisA) {\n                this.m_localXAxisA.setVec2(def.localAxisA);\n                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */ PrismaticJoint.prototype.getLocalAnchorA = function() {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */ PrismaticJoint.prototype.getLocalAnchorB = function() {\n            return this.m_localAnchorB;\n        };\n        /**\n         * The local joint axis relative to bodyA.\n         */ PrismaticJoint.prototype.getLocalAxisA = function() {\n            return this.m_localXAxisA;\n        };\n        /**\n         * Get the reference angle.\n         */ PrismaticJoint.prototype.getReferenceAngle = function() {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint translation, usually in meters.\n         */ PrismaticJoint.prototype.getJointTranslation = function() {\n            var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n            var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n            var d = Vec2.sub(pB, pA);\n            var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n            var translation = Vec2.dot(d, axis);\n            return translation;\n        };\n        /**\n         * Get the current joint translation speed, usually in meters per second.\n         */ PrismaticJoint.prototype.getJointSpeed = function() {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            var rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2\n            var rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2\n            var p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2\n            var p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2\n            var d = Vec2.sub(p2, p1); // Vec2\n            var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2\n            var vA = bA.m_linearVelocity; // Vec2\n            var vB = bB.m_linearVelocity; // Vec2\n            var wA = bA.m_angularVelocity; // float\n            var wB = bB.m_angularVelocity; // float\n            var speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis)) + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA))); // float\n            return speed;\n        };\n        /**\n         * Is the joint limit enabled?\n         */ PrismaticJoint.prototype.isLimitEnabled = function() {\n            return this.m_enableLimit;\n        };\n        /**\n         * Enable/disable the joint limit.\n         */ PrismaticJoint.prototype.enableLimit = function(flag) {\n            if (flag != this.m_enableLimit) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_enableLimit = flag;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Get the lower joint limit, usually in meters.\n         */ PrismaticJoint.prototype.getLowerLimit = function() {\n            return this.m_lowerTranslation;\n        };\n        /**\n         * Get the upper joint limit, usually in meters.\n         */ PrismaticJoint.prototype.getUpperLimit = function() {\n            return this.m_upperTranslation;\n        };\n        /**\n         * Set the joint limits, usually in meters.\n         */ PrismaticJoint.prototype.setLimits = function(lower, upper) {\n            if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_lowerTranslation = lower;\n                this.m_upperTranslation = upper;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Is the joint motor enabled?\n         */ PrismaticJoint.prototype.isMotorEnabled = function() {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */ PrismaticJoint.prototype.enableMotor = function(flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Set the motor speed, usually in meters per second.\n         */ PrismaticJoint.prototype.setMotorSpeed = function(speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Set the maximum motor force, usually in N.\n         */ PrismaticJoint.prototype.setMaxMotorForce = function(force) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorForce = force;\n        };\n        PrismaticJoint.prototype.getMaxMotorForce = function() {\n            return this.m_maxMotorForce;\n        };\n        /**\n         * Get the motor speed, usually in meters per second.\n         */ PrismaticJoint.prototype.getMotorSpeed = function() {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Get the current motor force given the inverse time step, usually in N.\n         */ PrismaticJoint.prototype.getMotorForce = function(inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ PrismaticJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ PrismaticJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ PrismaticJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ PrismaticJoint.prototype.getReactionTorque = function(inv_dt) {\n            return inv_dt * this.m_impulse.y;\n        };\n        PrismaticJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective masses.\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n            this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n            this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n            this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n            if (this.m_motorMass > 0.0) this.m_motorMass = 1.0 / this.m_motorMass;\n            this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n            this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n            this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n            Vec2.crossVec2Vec2(rA, this.m_perp);\n            var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n            var k12 = iA * this.m_s1 + iB * this.m_s2;\n            var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n            var k22 = iA + iB;\n            if (k22 == 0.0) // For bodies with fixed rotation.\n            k22 = 1.0;\n            var k23 = iA * this.m_a1 + iB * this.m_a2;\n            var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n            this.m_K.ex.set(k11, k12, k13);\n            this.m_K.ey.set(k12, k22, k23);\n            this.m_K.ez.set(k13, k23, k33);\n            // Compute motor and limit terms.\n            if (this.m_enableLimit) {\n                var jointTranslation = Vec2.dot(this.m_axis, d); // float\n                if (math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) this.m_limitState = equalLimits;\n                else if (jointTranslation <= this.m_lowerTranslation) {\n                    if (this.m_limitState != atLowerLimit) {\n                        this.m_limitState = atLowerLimit;\n                        this.m_impulse.z = 0.0;\n                    }\n                } else if (jointTranslation >= this.m_upperTranslation) {\n                    if (this.m_limitState != atUpperLimit$1) {\n                        this.m_limitState = atUpperLimit$1;\n                        this.m_impulse.z = 0.0;\n                    }\n                } else {\n                    this.m_limitState = inactiveLimit$1;\n                    this.m_impulse.z = 0.0;\n                }\n            } else {\n                this.m_limitState = inactiveLimit$1;\n                this.m_impulse.z = 0.0;\n            }\n            if (this.m_enableMotor == false) this.m_motorImpulse = 0.0;\n            if (step.warmStarting) {\n                // Account for variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis);\n                var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n                var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            } else {\n                this.m_impulse.setZero();\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        PrismaticJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Solve linear motor constraint.\n            if (this.m_enableMotor && this.m_limitState != equalLimits) {\n                var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB - this.m_a1 * wA;\n                var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n                var oldImpulse = this.m_motorImpulse;\n                var maxImpulse = step.dt * this.m_maxMotorForce;\n                this.m_motorImpulse = math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                var P = Vec2.mulNumVec2(impulse, this.m_axis);\n                var LA = impulse * this.m_a1;\n                var LB = impulse * this.m_a2;\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            var Cdot1 = Vec2.zero();\n            Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n            Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n            Cdot1.y = wB - wA;\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$1) {\n                // Solve prismatic and limit constraint in block form.\n                var Cdot2 = 0;\n                Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n                Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n                var f1 = Vec3.clone(this.m_impulse);\n                var df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3\n                this.m_impulse.add(df);\n                if (this.m_limitState == atLowerLimit) this.m_impulse.z = math.max(this.m_impulse.z, 0.0);\n                else if (this.m_limitState == atUpperLimit$1) this.m_impulse.z = math.min(this.m_impulse.z, 0.0);\n                // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n                // f1(1:2)\n                var b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2\n                var f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2\n                this.m_impulse.x = f2r.x;\n                this.m_impulse.y = f2r.y;\n                df = Vec3.sub(this.m_impulse, f1);\n                var P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2\n                var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float\n                var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            } else {\n                // Limit is inactive, just solve the prismatic constraint in block form.\n                var df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2\n                this.m_impulse.x += df.x;\n                this.m_impulse.y += df.y;\n                var P = Vec2.mulNumVec2(df.x, this.m_perp); // Vec2\n                var LA = df.x * this.m_s1 + df.y; // float\n                var LB = df.x * this.m_s2 + df.y; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ PrismaticJoint.prototype.solvePositionConstraints = function(step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Compute fresh Jacobians\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n            var d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2\n            var axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2\n            var a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis); // float\n            var a2 = Vec2.crossVec2Vec2(rB, axis); // float\n            var perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2\n            var s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp); // float\n            var s2 = Vec2.crossVec2Vec2(rB, perp); // float\n            var impulse = new Vec3();\n            var C1 = Vec2.zero(); // Vec2\n            C1.x = Vec2.dot(perp, d);\n            C1.y = aB - aA - this.m_referenceAngle;\n            var linearError = math.abs(C1.x); // float\n            var angularError = math.abs(C1.y); // float\n            var linearSlop = Settings.linearSlop;\n            var maxLinearCorrection = Settings.maxLinearCorrection;\n            var active = false; // bool\n            var C2 = 0.0; // float\n            if (this.m_enableLimit) {\n                var translation = Vec2.dot(axis, d); // float\n                if (math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n                    // Prevent large angular corrections\n                    C2 = math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n                    linearError = math.max(linearError, math.abs(translation));\n                    active = true;\n                } else if (translation <= this.m_lowerTranslation) {\n                    // Prevent large linear corrections and allow some slop.\n                    C2 = math.clamp(translation - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0.0);\n                    linearError = math.max(linearError, this.m_lowerTranslation - translation);\n                    active = true;\n                } else if (translation >= this.m_upperTranslation) {\n                    // Prevent large linear corrections and allow some slop.\n                    C2 = math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0, maxLinearCorrection);\n                    linearError = math.max(linearError, translation - this.m_upperTranslation);\n                    active = true;\n                }\n            }\n            if (active) {\n                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n                var k12 = iA * s1 + iB * s2; // float\n                var k13 = iA * s1 * a1 + iB * s2 * a2; // float\n                var k22 = iA + iB; // float\n                if (k22 == 0.0) // For fixed rotation\n                k22 = 1.0;\n                var k23 = iA * a1 + iB * a2; // float\n                var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float\n                var K = new Mat33();\n                K.ex.set(k11, k12, k13);\n                K.ey.set(k12, k22, k23);\n                K.ez.set(k13, k23, k33);\n                var C = new Vec3();\n                C.x = C1.x;\n                C.y = C1.y;\n                C.z = C2;\n                impulse = K.solve33(Vec3.neg(C));\n            } else {\n                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n                var k12 = iA * s1 + iB * s2; // float\n                var k22 = iA + iB; // float\n                if (k22 == 0.0) k22 = 1.0;\n                var K = new Mat22();\n                K.ex.setNum(k11, k12);\n                K.ey.setNum(k12, k22);\n                var impulse1 = K.solve(Vec2.neg(C1)); // Vec2\n                impulse.x = impulse1.x;\n                impulse.y = impulse1.y;\n                impulse.z = 0.0;\n            }\n            var P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2\n            var LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float\n            var LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float\n            cA.subMul(mA, P);\n            aA -= iA * LA;\n            cB.addMul(mB, P);\n            aB += iB * LB;\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return linearError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n        };\n        PrismaticJoint.TYPE = \"prismatic-joint\";\n        return PrismaticJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS$6 = {\n        ratio: 1.0\n    };\n    /**\n     * A gear joint is used to connect two joints together. Either joint can be a\n     * revolute or prismatic joint. You specify a gear ratio to bind the motions\n     * together: coordinate1 + ratio * coordinate2 = constant\n     *\n     * The ratio can be negative or positive. If one joint is a revolute joint and\n     * the other joint is a prismatic joint, then the ratio will have units of\n     * length or units of 1/length. Warning: You have to manually destroy the gear\n     * joint if joint1 or joint2 is destroyed.\n     *\n     * This definition requires two existing revolute or prismatic joints (any\n     * combination will work).\n     */ var GearJoint = /** @class */ function(_super) {\n        __extends(GearJoint, _super);\n        function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof GearJoint)) return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n            def = options(def, DEFAULTS$6);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = GearJoint.TYPE;\n            _this.m_joint1 = joint1 ? joint1 : def.joint1;\n            _this.m_joint2 = joint2 ? joint2 : def.joint2;\n            _this.m_ratio = math.isFinite(ratio) ? ratio : def.ratio;\n            _this.m_type1 = _this.m_joint1.getType();\n            _this.m_type2 = _this.m_joint2.getType();\n            // joint1 connects body A to body C\n            // joint2 connects body B to body D\n            var coordinateA;\n            var coordinateB;\n            // TODO_ERIN there might be some problem with the joint edges in Joint.\n            _this.m_bodyC = _this.m_joint1.getBodyA();\n            _this.m_bodyA = _this.m_joint1.getBodyB();\n            // Get geometry of joint1\n            var xfA = _this.m_bodyA.m_xf;\n            var aA = _this.m_bodyA.m_sweep.a;\n            var xfC = _this.m_bodyC.m_xf;\n            var aC = _this.m_bodyC.m_sweep.a;\n            if (_this.m_type1 === RevoluteJoint.TYPE) {\n                var revolute = _this.m_joint1;\n                _this.m_localAnchorC = revolute.m_localAnchorA;\n                _this.m_localAnchorA = revolute.m_localAnchorB;\n                _this.m_referenceAngleA = revolute.m_referenceAngle;\n                _this.m_localAxisC = Vec2.zero();\n                coordinateA = aA - aC - _this.m_referenceAngleA;\n            } else {\n                var prismatic = _this.m_joint1;\n                _this.m_localAnchorC = prismatic.m_localAnchorA;\n                _this.m_localAnchorA = prismatic.m_localAnchorB;\n                _this.m_referenceAngleA = prismatic.m_referenceAngle;\n                _this.m_localAxisC = prismatic.m_localXAxisA;\n                var pC = _this.m_localAnchorC;\n                var pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, _this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n                coordinateA = Vec2.dot(pA, _this.m_localAxisC) - Vec2.dot(pC, _this.m_localAxisC);\n            }\n            _this.m_bodyD = _this.m_joint2.getBodyA();\n            _this.m_bodyB = _this.m_joint2.getBodyB();\n            // Get geometry of joint2\n            var xfB = _this.m_bodyB.m_xf;\n            var aB = _this.m_bodyB.m_sweep.a;\n            var xfD = _this.m_bodyD.m_xf;\n            var aD = _this.m_bodyD.m_sweep.a;\n            if (_this.m_type2 === RevoluteJoint.TYPE) {\n                var revolute = _this.m_joint2;\n                _this.m_localAnchorD = revolute.m_localAnchorA;\n                _this.m_localAnchorB = revolute.m_localAnchorB;\n                _this.m_referenceAngleB = revolute.m_referenceAngle;\n                _this.m_localAxisD = Vec2.zero();\n                coordinateB = aB - aD - _this.m_referenceAngleB;\n            } else {\n                var prismatic = _this.m_joint2;\n                _this.m_localAnchorD = prismatic.m_localAnchorA;\n                _this.m_localAnchorB = prismatic.m_localAnchorB;\n                _this.m_referenceAngleB = prismatic.m_referenceAngle;\n                _this.m_localAxisD = prismatic.m_localXAxisA;\n                var pD = _this.m_localAnchorD;\n                var pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, _this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n                coordinateB = Vec2.dot(pB, _this.m_localAxisD) - Vec2.dot(pD, _this.m_localAxisD);\n            }\n            _this.m_constant = coordinateA + _this.m_ratio * coordinateB;\n            _this.m_impulse = 0.0;\n            return _this;\n        // Gear Joint:\n        // C0 = (coordinate1 + ratio * coordinate2)_initial\n        // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n        // J = [J1 ratio * J2]\n        // K = J * invM * JT\n        // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n        //\n        // Revolute:\n        // coordinate = rotation\n        // Cdot = angularVelocity\n        // J = [0 0 1]\n        // K = J * invM * JT = invI\n        //\n        // Prismatic:\n        // coordinate = dot(p - pg, ug)\n        // Cdot = dot(v + cross(w, r), ug)\n        // J = [ug cross(r, ug)]\n        // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n        }\n        /** @internal */ GearJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                joint1: this.m_joint1,\n                joint2: this.m_joint2,\n                ratio: this.m_ratio\n            };\n        };\n        /** @internal */ GearJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.joint1 = restore(Joint, data.joint1, world);\n            data.joint2 = restore(Joint, data.joint2, world);\n            var joint = new GearJoint(data);\n            // if (data._constant) joint.m_constant = data._constant;\n            return joint;\n        };\n        /**\n         * Get the first joint.\n         */ GearJoint.prototype.getJoint1 = function() {\n            return this.m_joint1;\n        };\n        /**\n         * Get the second joint.\n         */ GearJoint.prototype.getJoint2 = function() {\n            return this.m_joint2;\n        };\n        /**\n         * Set the gear ratio.\n         */ GearJoint.prototype.setRatio = function(ratio) {\n            this.m_ratio = ratio;\n        };\n        /**\n         * Get the gear ratio.\n         */ GearJoint.prototype.getRatio = function() {\n            return this.m_ratio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ GearJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ GearJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ GearJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ GearJoint.prototype.getReactionTorque = function(inv_dt) {\n            var L = this.m_impulse * this.m_JwA; // float\n            return inv_dt * L;\n        };\n        GearJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n            this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n            this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n            this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n            this.m_mA = this.m_bodyA.m_invMass;\n            this.m_mB = this.m_bodyB.m_invMass;\n            this.m_mC = this.m_bodyC.m_invMass;\n            this.m_mD = this.m_bodyD.m_invMass;\n            this.m_iA = this.m_bodyA.m_invI;\n            this.m_iB = this.m_bodyB.m_invI;\n            this.m_iC = this.m_bodyC.m_invI;\n            this.m_iD = this.m_bodyD.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var aC = this.m_bodyC.c_position.a;\n            var vC = this.m_bodyC.c_velocity.v;\n            var wC = this.m_bodyC.c_velocity.w;\n            var aD = this.m_bodyD.c_position.a;\n            var vD = this.m_bodyD.c_velocity.v;\n            var wD = this.m_bodyD.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var qC = Rot.neo(aC);\n            var qD = Rot.neo(aD);\n            this.m_mass = 0.0;\n            if (this.m_type1 == RevoluteJoint.TYPE) {\n                this.m_JvAC = Vec2.zero();\n                this.m_JwA = 1.0;\n                this.m_JwC = 1.0;\n                this.m_mass += this.m_iA + this.m_iC;\n            } else {\n                var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n                this.m_JvAC = u;\n                this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n                this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n                this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n            }\n            if (this.m_type2 == RevoluteJoint.TYPE) {\n                this.m_JvBD = Vec2.zero();\n                this.m_JwB = this.m_ratio;\n                this.m_JwD = this.m_ratio;\n                this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n            } else {\n                var u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2\n                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2\n                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2\n                this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n                this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n                this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n                this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n            }\n            // Compute effective mass.\n            this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n            if (step.warmStarting) {\n                vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n                wA += this.m_iA * this.m_impulse * this.m_JwA;\n                vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n                wB += this.m_iB * this.m_impulse * this.m_JwB;\n                vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n                wC -= this.m_iC * this.m_impulse * this.m_JwC;\n                vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n                wD -= this.m_iD * this.m_impulse * this.m_JwD;\n            } else this.m_impulse = 0.0;\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n            this.m_bodyC.c_velocity.v.setVec2(vC);\n            this.m_bodyC.c_velocity.w = wC;\n            this.m_bodyD.c_velocity.v.setVec2(vD);\n            this.m_bodyD.c_velocity.w = wD;\n        };\n        GearJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var vC = this.m_bodyC.c_velocity.v;\n            var wC = this.m_bodyC.c_velocity.w;\n            var vD = this.m_bodyD.c_velocity.v;\n            var wD = this.m_bodyD.c_velocity.w;\n            var Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float\n            Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);\n            var impulse = -this.m_mass * Cdot; // float\n            this.m_impulse += impulse;\n            vA.addMul(this.m_mA * impulse, this.m_JvAC);\n            wA += this.m_iA * impulse * this.m_JwA;\n            vB.addMul(this.m_mB * impulse, this.m_JvBD);\n            wB += this.m_iB * impulse * this.m_JwB;\n            vC.subMul(this.m_mC * impulse, this.m_JvAC);\n            wC -= this.m_iC * impulse * this.m_JwC;\n            vD.subMul(this.m_mD * impulse, this.m_JvBD);\n            wD -= this.m_iD * impulse * this.m_JwD;\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n            this.m_bodyC.c_velocity.v.setVec2(vC);\n            this.m_bodyC.c_velocity.w = wC;\n            this.m_bodyD.c_velocity.v.setVec2(vD);\n            this.m_bodyD.c_velocity.w = wD;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ GearJoint.prototype.solvePositionConstraints = function(step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var cC = this.m_bodyC.c_position.c;\n            var aC = this.m_bodyC.c_position.a;\n            var cD = this.m_bodyD.c_position.c;\n            var aD = this.m_bodyD.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var qC = Rot.neo(aC);\n            var qD = Rot.neo(aD);\n            var linearError = 0.0;\n            var coordinateA;\n            var coordinateB;\n            var JvAC;\n            var JvBD;\n            var JwA;\n            var JwB;\n            var JwC;\n            var JwD;\n            var mass = 0.0;\n            if (this.m_type1 == RevoluteJoint.TYPE) {\n                JvAC = Vec2.zero();\n                JwA = 1.0;\n                JwC = 1.0;\n                mass += this.m_iA + this.m_iC;\n                coordinateA = aA - aC - this.m_referenceAngleA;\n            } else {\n                var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n                JvAC = u;\n                JwC = Vec2.crossVec2Vec2(rC, u);\n                JwA = Vec2.crossVec2Vec2(rA, u);\n                mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n                var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2\n                var pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2\n                coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n            }\n            if (this.m_type2 == RevoluteJoint.TYPE) {\n                JvBD = Vec2.zero();\n                JwB = this.m_ratio;\n                JwD = this.m_ratio;\n                mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n                coordinateB = aB - aD - this.m_referenceAngleB;\n            } else {\n                var u = Rot.mulVec2(qD, this.m_localAxisD);\n                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n                JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n                JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n                JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n                mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;\n                var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2\n                var pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2\n                coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n            }\n            var C = coordinateA + this.m_ratio * coordinateB - this.m_constant; // float\n            var impulse = 0.0; // float\n            if (mass > 0.0) impulse = -C / mass;\n            cA.addMul(this.m_mA * impulse, JvAC);\n            aA += this.m_iA * impulse * JwA;\n            cB.addMul(this.m_mB * impulse, JvBD);\n            aB += this.m_iB * impulse * JwB;\n            cC.subMul(this.m_mC * impulse, JvAC);\n            aC -= this.m_iC * impulse * JwC;\n            cD.subMul(this.m_mD * impulse, JvBD);\n            aD -= this.m_iD * impulse * JwD;\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            this.m_bodyC.c_position.c.setVec2(cC);\n            this.m_bodyC.c_position.a = aC;\n            this.m_bodyD.c_position.c.setVec2(cD);\n            this.m_bodyD.c_position.a = aD;\n            // TODO_ERIN not implemented\n            return linearError < Settings.linearSlop;\n        };\n        GearJoint.TYPE = \"gear-joint\";\n        return GearJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS$5 = {\n        maxForce: 1.0,\n        maxTorque: 1.0,\n        correctionFactor: 0.3\n    };\n    /**\n     * A motor joint is used to control the relative motion between two bodies. A\n     * typical usage is to control the movement of a dynamic body with respect to\n     * the ground.\n     */ var MotorJoint = /** @class */ function(_super) {\n        __extends(MotorJoint, _super);\n        function MotorJoint(def, bodyA, bodyB) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof MotorJoint)) return new MotorJoint(def, bodyA, bodyB);\n            def = options(def, DEFAULTS$5);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = MotorJoint.TYPE;\n            _this.m_linearOffset = math.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());\n            _this.m_angularOffset = math.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_linearImpulse = Vec2.zero();\n            _this.m_angularImpulse = 0.0;\n            _this.m_maxForce = def.maxForce;\n            _this.m_maxTorque = def.maxTorque;\n            _this.m_correctionFactor = def.correctionFactor;\n            return _this;\n        // Point-to-point constraint\n        // Cdot = v2 - v1\n        // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n        // J = [-I -r1_skew I r2_skew ]\n        // Identity used:\n        // w k % (rx i + ry j) = w * (-ry i + rx j)\n        // Angle constraint\n        // Cdot = w2 - w1\n        // J = [0 0 -1 0 0 1]\n        // K = invI1 + invI2\n        }\n        /** @internal */ MotorJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                maxForce: this.m_maxForce,\n                maxTorque: this.m_maxTorque,\n                correctionFactor: this.m_correctionFactor,\n                linearOffset: this.m_linearOffset,\n                angularOffset: this.m_angularOffset\n            };\n        };\n        /** @internal */ MotorJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new MotorJoint(data);\n            return joint;\n        };\n        /** @internal */ MotorJoint.prototype._setAnchors = function(def) {};\n        /**\n         * Set the maximum friction force in N.\n         */ MotorJoint.prototype.setMaxForce = function(force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum friction force in N.\n         */ MotorJoint.prototype.getMaxForce = function() {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the maximum friction torque in N*m.\n         */ MotorJoint.prototype.setMaxTorque = function(torque) {\n            this.m_maxTorque = torque;\n        };\n        /**\n         * Get the maximum friction torque in N*m.\n         */ MotorJoint.prototype.getMaxTorque = function() {\n            return this.m_maxTorque;\n        };\n        /**\n         * Set the position correction factor in the range [0,1].\n         */ MotorJoint.prototype.setCorrectionFactor = function(factor) {\n            this.m_correctionFactor = factor;\n        };\n        /**\n         * Get the position correction factor in the range [0,1].\n         */ MotorJoint.prototype.getCorrectionFactor = function() {\n            return this.m_correctionFactor;\n        };\n        /**\n         * Set/get the target linear offset, in frame A, in meters.\n         */ MotorJoint.prototype.setLinearOffset = function(linearOffset) {\n            if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_linearOffset = linearOffset;\n            }\n        };\n        MotorJoint.prototype.getLinearOffset = function() {\n            return this.m_linearOffset;\n        };\n        /**\n         * Set/get the target angular offset, in radians.\n         */ MotorJoint.prototype.setAngularOffset = function(angularOffset) {\n            if (angularOffset != this.m_angularOffset) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_angularOffset = angularOffset;\n            }\n        };\n        MotorJoint.prototype.getAngularOffset = function() {\n            return this.m_angularOffset;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ MotorJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getPosition();\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ MotorJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getPosition();\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ MotorJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ MotorJoint.prototype.getReactionTorque = function(inv_dt) {\n            return inv_dt * this.m_angularImpulse;\n        };\n        MotorJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective mass matrix.\n            this.m_rA = Rot.mulVec2(qA, Vec2.neg(this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat22();\n            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n            this.m_linearMass = K.getInverse();\n            this.m_angularMass = iA + iB;\n            if (this.m_angularMass > 0.0) this.m_angularMass = 1.0 / this.m_angularMass;\n            this.m_linearError = Vec2.zero();\n            this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n            this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n            this.m_linearError.sub(Rot.mulVec2(qA, this.m_linearOffset));\n            this.m_angularError = aB - aA - this.m_angularOffset;\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_linearImpulse.mul(step.dtRatio);\n                this.m_angularImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n            } else {\n                this.m_linearImpulse.setZero();\n                this.m_angularImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        MotorJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var h = step.dt;\n            var inv_h = step.inv_dt;\n            var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n            var impulse = -this.m_angularMass * Cdot;\n            var oldImpulse = this.m_angularImpulse;\n            var maxImpulse = h * this.m_maxTorque;\n            this.m_angularImpulse = math.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n            impulse = this.m_angularImpulse - oldImpulse;\n            wA -= iA * impulse;\n            wB += iB * impulse;\n            var Cdot = Vec2.zero();\n            Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n            Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n            Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n            var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n            var oldImpulse = Vec2.clone(this.m_linearImpulse);\n            this.m_linearImpulse.add(impulse);\n            var maxImpulse = h * this.m_maxForce;\n            this.m_linearImpulse.clamp(maxImpulse);\n            impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n            vA.subMul(mA, impulse);\n            wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n            vB.addMul(mB, impulse);\n            wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ MotorJoint.prototype.solvePositionConstraints = function(step) {\n            return true;\n        };\n        MotorJoint.TYPE = \"motor-joint\";\n        return MotorJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS$4 = {\n        maxForce: 0.0,\n        frequencyHz: 5.0,\n        dampingRatio: 0.7\n    };\n    /**\n     * A mouse joint is used to make a point on a body track a specified world\n     * point. This a soft constraint with a maximum force. This allows the\n     * constraint to stretch and without applying huge forces.\n     *\n     * NOTE: this joint is not documented in the manual because it was developed to\n     * be used in the testbed. If you want to learn how to use the mouse joint, look\n     * at the testbed.\n     */ var MouseJoint = /** @class */ function(_super) {\n        __extends(MouseJoint, _super);\n        function MouseJoint(def, bodyA, bodyB, target) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof MouseJoint)) return new MouseJoint(def, bodyA, bodyB, target);\n            def = options(def, DEFAULTS$4);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = MouseJoint.TYPE;\n            _this.m_targetA = target ? Vec2.clone(target) : def.target || Vec2.zero();\n            _this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), _this.m_targetA);\n            _this.m_maxForce = def.maxForce;\n            _this.m_impulse = Vec2.zero();\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_beta = 0.0;\n            _this.m_gamma = 0.0;\n            // Solver temp\n            _this.m_rB = Vec2.zero();\n            _this.m_localCenterB = Vec2.zero();\n            _this.m_invMassB = 0.0;\n            _this.m_invIB = 0.0;\n            _this.m_mass = new Mat22();\n            _this.m_C = Vec2.zero();\n            return _this;\n        // p = attached point, m = mouse point\n        // C = p - m\n        // Cdot = v\n        // = v + cross(w, r)\n        // J = [I r_skew]\n        // Identity used:\n        // w k % (rx i + ry j) = w * (-ry i + rx j)\n        }\n        /** @internal */ MouseJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                target: this.m_targetA,\n                maxForce: this.m_maxForce,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                _localAnchorB: this.m_localAnchorB\n            };\n        };\n        /** @internal */ MouseJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.target = Vec2.clone(data.target);\n            var joint = new MouseJoint(data);\n            if (data._localAnchorB) joint.m_localAnchorB = data._localAnchorB;\n            return joint;\n        };\n        /**\n         * Use this to update the target point.\n         */ MouseJoint.prototype.setTarget = function(target) {\n            if (this.m_bodyB.isAwake() == false) this.m_bodyB.setAwake(true);\n            this.m_targetA = Vec2.clone(target);\n        };\n        MouseJoint.prototype.getTarget = function() {\n            return this.m_targetA;\n        };\n        /**\n         * Set the maximum force in Newtons.\n         */ MouseJoint.prototype.setMaxForce = function(force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum force in Newtons.\n         */ MouseJoint.prototype.getMaxForce = function() {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the frequency in Hertz.\n         */ MouseJoint.prototype.setFrequency = function(hz) {\n            this.m_frequencyHz = hz;\n        };\n        /**\n         * Get the frequency in Hertz.\n         */ MouseJoint.prototype.getFrequency = function() {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set the damping ratio (dimensionless).\n         */ MouseJoint.prototype.setDampingRatio = function(ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        /**\n         * Get the damping ratio (dimensionless).\n         */ MouseJoint.prototype.getDampingRatio = function() {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ MouseJoint.prototype.getAnchorA = function() {\n            return Vec2.clone(this.m_targetA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ MouseJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ MouseJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ MouseJoint.prototype.getReactionTorque = function(inv_dt) {\n            return inv_dt * 0.0;\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         */ MouseJoint.prototype.shiftOrigin = function(newOrigin) {\n            this.m_targetA.sub(newOrigin);\n        };\n        MouseJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var position = this.m_bodyB.c_position;\n            var velocity = this.m_bodyB.c_velocity;\n            var cB = position.c;\n            var aB = position.a;\n            var vB = velocity.v;\n            var wB = velocity.w;\n            var qB = Rot.neo(aB);\n            var mass = this.m_bodyB.getMass();\n            // Frequency\n            var omega = 2.0 * math.PI * this.m_frequencyHz;\n            // Damping coefficient\n            var d = 2.0 * mass * this.m_dampingRatio * omega;\n            // Spring stiffness\n            var k = mass * (omega * omega);\n            // magic formulas\n            // gamma has units of inverse mass.\n            // beta has units of inverse time.\n            var h = step.dt;\n            this.m_gamma = h * (d + h * k);\n            if (this.m_gamma != 0.0) this.m_gamma = 1.0 / this.m_gamma;\n            this.m_beta = h * k * this.m_gamma;\n            // Compute the effective mass matrix.\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n            // invI2 * skew(r2)]\n            // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n            // -r1.x*r1.y]\n            // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n            var K = new Mat22();\n            K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;\n            K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;\n            this.m_mass = K.getInverse();\n            this.m_C.setVec2(cB);\n            this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n            this.m_C.mul(this.m_beta);\n            // Cheat with some damping\n            wB *= 0.98;\n            if (step.warmStarting) {\n                this.m_impulse.mul(step.dtRatio);\n                vB.addMul(this.m_invMassB, this.m_impulse);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n            } else this.m_impulse.setZero();\n            velocity.v.setVec2(vB);\n            velocity.w = wB;\n        };\n        MouseJoint.prototype.solveVelocityConstraints = function(step) {\n            var velocity = this.m_bodyB.c_velocity;\n            var vB = Vec2.clone(velocity.v);\n            var wB = velocity.w;\n            // Cdot = v + cross(w, r)\n            var Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n            Cdot.add(vB);\n            Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n            Cdot.neg();\n            var impulse = Mat22.mulVec2(this.m_mass, Cdot);\n            var oldImpulse = Vec2.clone(this.m_impulse);\n            this.m_impulse.add(impulse);\n            var maxImpulse = step.dt * this.m_maxForce;\n            this.m_impulse.clamp(maxImpulse);\n            impulse = Vec2.sub(this.m_impulse, oldImpulse);\n            vB.addMul(this.m_invMassB, impulse);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            velocity.v.setVec2(vB);\n            velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ MouseJoint.prototype.solvePositionConstraints = function(step) {\n            return true;\n        };\n        MouseJoint.TYPE = \"mouse-joint\";\n        return MouseJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS$3 = {\n        collideConnected: true\n    };\n    /**\n     * The pulley joint is connected to two bodies and two fixed ground points. The\n     * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n     *\n     * Yes, the force transmitted is scaled by the ratio.\n     *\n     * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n     * better when combined with prismatic joints. You should also cover the the\n     * anchor points with static shapes to prevent one side from going to zero\n     * length.\n     */ var PulleyJoint = /** @class */ function(_super) {\n        __extends(PulleyJoint, _super);\n        function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PulleyJoint)) return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n            def = options(def, DEFAULTS$3);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = PulleyJoint.TYPE;\n            _this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1, 1.0);\n            _this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);\n            _this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1, 0.0);\n            _this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n            _this.m_lengthA = math.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n            _this.m_lengthB = math.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n            _this.m_ratio = math.isFinite(ratio) ? ratio : def.ratio;\n            _this.m_constant = _this.m_lengthA + _this.m_ratio * _this.m_lengthB;\n            _this.m_impulse = 0.0;\n            return _this;\n        // Pulley:\n        // length1 = norm(p1 - s1)\n        // length2 = norm(p2 - s2)\n        // C0 = (length1 + ratio * length2)_initial\n        // C = C0 - (length1 + ratio * length2)\n        // u1 = (p1 - s1) / norm(p1 - s1)\n        // u2 = (p2 - s2) / norm(p2 - s2)\n        // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n        // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n        // K = J * invM * JT\n        // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n        // cross(r2, u2)^2)\n        }\n        PulleyJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                groundAnchorA: this.m_groundAnchorA,\n                groundAnchorB: this.m_groundAnchorB,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                lengthA: this.m_lengthA,\n                lengthB: this.m_lengthB,\n                ratio: this.m_ratio\n            };\n        };\n        /** @internal */ PulleyJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new PulleyJoint(data);\n            return joint;\n        };\n        /**\n         * Get the first ground anchor.\n         */ PulleyJoint.prototype.getGroundAnchorA = function() {\n            return this.m_groundAnchorA;\n        };\n        /**\n         * Get the second ground anchor.\n         */ PulleyJoint.prototype.getGroundAnchorB = function() {\n            return this.m_groundAnchorB;\n        };\n        /**\n         * Get the current length of the segment attached to bodyA.\n         */ PulleyJoint.prototype.getLengthA = function() {\n            return this.m_lengthA;\n        };\n        /**\n         * Get the current length of the segment attached to bodyB.\n         */ PulleyJoint.prototype.getLengthB = function() {\n            return this.m_lengthB;\n        };\n        /**\n         * Get the pulley ratio.\n         */ PulleyJoint.prototype.getRatio = function() {\n            return this.m_ratio;\n        };\n        /**\n         * Get the current length of the segment attached to bodyA.\n         */ PulleyJoint.prototype.getCurrentLengthA = function() {\n            var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n            var s = this.m_groundAnchorA;\n            return Vec2.distance(p, s);\n        };\n        /**\n         * Get the current length of the segment attached to bodyB.\n         */ PulleyJoint.prototype.getCurrentLengthB = function() {\n            var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n            var s = this.m_groundAnchorB;\n            return Vec2.distance(p, s);\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         *\n         * @param newOrigin\n         */ PulleyJoint.prototype.shiftOrigin = function(newOrigin) {\n            this.m_groundAnchorA.sub(newOrigin);\n            this.m_groundAnchorB.sub(newOrigin);\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ PulleyJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ PulleyJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ PulleyJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ PulleyJoint.prototype.getReactionTorque = function(inv_dt) {\n            return 0.0;\n        };\n        PulleyJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // Get the pulley axes.\n            this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n            this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n            var lengthA = this.m_uA.length();\n            var lengthB = this.m_uB.length();\n            if (lengthA > 10.0 * Settings.linearSlop) this.m_uA.mul(1.0 / lengthA);\n            else this.m_uA.setZero();\n            if (lengthB > 10.0 * Settings.linearSlop) this.m_uB.mul(1.0 / lengthB);\n            else this.m_uB.setZero();\n            // Compute effective mass.\n            var ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA); // float\n            var ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB); // float\n            var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n            var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n            this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n            if (this.m_mass > 0.0) this.m_mass = 1.0 / this.m_mass;\n            if (step.warmStarting) {\n                // Scale impulses to support variable time steps.\n                this.m_impulse *= step.dtRatio;\n                // Warm starting.\n                var PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n                var PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n                vA.addMul(this.m_invMassA, PA);\n                wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n                vB.addMul(this.m_invMassB, PB);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n            } else this.m_impulse = 0.0;\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        PulleyJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n            var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB); // float\n            var impulse = -this.m_mass * Cdot; // float\n            this.m_impulse += impulse;\n            var PA = Vec2.mulNumVec2(-impulse, this.m_uA); // Vec2\n            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB); // Vec2\n            vA.addMul(this.m_invMassA, PA);\n            wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n            vB.addMul(this.m_invMassB, PB);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ PulleyJoint.prototype.solvePositionConstraints = function(step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // Get the pulley axes.\n            var uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n            var uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n            var lengthA = uA.length();\n            var lengthB = uB.length();\n            if (lengthA > 10.0 * Settings.linearSlop) uA.mul(1.0 / lengthA);\n            else uA.setZero();\n            if (lengthB > 10.0 * Settings.linearSlop) uB.mul(1.0 / lengthB);\n            else uB.setZero();\n            // Compute effective mass.\n            var ruA = Vec2.crossVec2Vec2(rA, uA);\n            var ruB = Vec2.crossVec2Vec2(rB, uB);\n            var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n            var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n            var mass = mA + this.m_ratio * this.m_ratio * mB; // float\n            if (mass > 0.0) mass = 1.0 / mass;\n            var C = this.m_constant - lengthA - this.m_ratio * lengthB; // float\n            var linearError = math.abs(C); // float\n            var impulse = -mass * C; // float\n            var PA = Vec2.mulNumVec2(-impulse, uA); // Vec2\n            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB); // Vec2\n            cA.addMul(this.m_invMassA, PA);\n            aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n            cB.addMul(this.m_invMassB, PB);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return linearError < Settings.linearSlop;\n        };\n        PulleyJoint.TYPE = \"pulley-joint\";\n        return PulleyJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var inactiveLimit = 0;\n    var atUpperLimit = 2;\n    var DEFAULTS$2 = {\n        maxLength: 0.0\n    };\n    /**\n     * A rope joint enforces a maximum distance between two points on two bodies. It\n     * has no other effect.\n     *\n     * Warning: if you attempt to change the maximum length during the simulation\n     * you will get some non-physical behavior.\n     *\n     * A model that would allow you to dynamically modify the length would have some\n     * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n     * want to dynamically control length.\n     */ var RopeJoint = /** @class */ function(_super) {\n        __extends(RopeJoint, _super);\n        function RopeJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof RopeJoint)) return new RopeJoint(def, bodyA, bodyB, anchor);\n            def = options(def, DEFAULTS$2);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = RopeJoint.TYPE;\n            _this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1, 0.0);\n            _this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n            _this.m_maxLength = def.maxLength;\n            _this.m_mass = 0.0;\n            _this.m_impulse = 0.0;\n            _this.m_length = 0.0;\n            _this.m_state = inactiveLimit;\n            return _this;\n        // Limit:\n        // C = norm(pB - pA) - L\n        // u = (pB - pA) / norm(pB - pA)\n        // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n        // J = [-u -cross(rA, u) u cross(rB, u)]\n        // K = J * invM * JT\n        // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n        }\n        /** @internal */ RopeJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                maxLength: this.m_maxLength\n            };\n        };\n        /** @internal */ RopeJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new RopeJoint(data);\n            return joint;\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */ RopeJoint.prototype.getLocalAnchorA = function() {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */ RopeJoint.prototype.getLocalAnchorB = function() {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the maximum length of the rope.\n         */ RopeJoint.prototype.setMaxLength = function(length) {\n            this.m_maxLength = length;\n        };\n        /**\n         * Get the maximum length of the rope.\n         */ RopeJoint.prototype.getMaxLength = function() {\n            return this.m_maxLength;\n        };\n        RopeJoint.prototype.getLimitState = function() {\n            // TODO LimitState\n            return this.m_state;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ RopeJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ RopeJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ RopeJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ RopeJoint.prototype.getReactionTorque = function(inv_dt) {\n            return 0.0;\n        };\n        RopeJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            this.m_u = Vec2.zero();\n            this.m_u.addCombine(1, cB, 1, this.m_rB);\n            this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2\n            this.m_length = this.m_u.length();\n            var C = this.m_length - this.m_maxLength; // float\n            if (C > 0.0) this.m_state = atUpperLimit;\n            else this.m_state = inactiveLimit;\n            if (this.m_length > Settings.linearSlop) this.m_u.mul(1.0 / this.m_length);\n            else {\n                this.m_u.setZero();\n                this.m_mass = 0.0;\n                this.m_impulse = 0.0;\n                return;\n            }\n            // Compute effective mass.\n            var crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u); // float\n            var crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u); // float\n            var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB; // float\n            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            if (step.warmStarting) {\n                // Scale the impulse to support a variable time step.\n                this.m_impulse *= step.dtRatio;\n                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            } else this.m_impulse = 0.0;\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        RopeJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Cdot = dot(u, v + cross(w, r))\n            var vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA); // Vec2\n            var vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB); // Vec2\n            var C = this.m_length - this.m_maxLength; // float\n            var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float\n            // Predictive constraint.\n            if (C < 0.0) Cdot += step.inv_dt * C;\n            var impulse = -this.m_mass * Cdot; // float\n            var oldImpulse = this.m_impulse; // float\n            this.m_impulse = math.min(0.0, this.m_impulse + impulse);\n            impulse = this.m_impulse - oldImpulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_u); // Vec2\n            vA.subMul(this.m_invMassA, P);\n            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n            vB.addMul(this.m_invMassB, P);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ RopeJoint.prototype.solvePositionConstraints = function(step) {\n            var cA = this.m_bodyA.c_position.c; // Vec2\n            var aA = this.m_bodyA.c_position.a; // float\n            var cB = this.m_bodyB.c_position.c; // Vec2\n            var aB = this.m_bodyB.c_position.a; // float\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            var u = Vec2.zero();\n            u.addCombine(1, cB, 1, rB);\n            u.subCombine(1, cA, 1, rA); // Vec2\n            var length = u.normalize(); // float\n            var C = length - this.m_maxLength; // float\n            C = math.clamp(C, 0.0, Settings.maxLinearCorrection);\n            var impulse = -this.m_mass * C; // float\n            var P = Vec2.mulNumVec2(impulse, u); // Vec2\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return length - this.m_maxLength < Settings.linearSlop;\n        };\n        RopeJoint.TYPE = \"rope-joint\";\n        return RopeJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS$1 = {\n        frequencyHz: 0.0,\n        dampingRatio: 0.0\n    };\n    /**\n     * A weld joint essentially glues two bodies together. A weld joint may distort\n     * somewhat because the island constraint solver is approximate.\n     */ var WeldJoint = /** @class */ function(_super) {\n        __extends(WeldJoint, _super);\n        function WeldJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof WeldJoint)) return new WeldJoint(def, bodyA, bodyB, anchor);\n            def = options(def, DEFAULTS$1);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = WeldJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_referenceAngle = math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_impulse = new Vec3();\n            _this.m_bias = 0.0;\n            _this.m_gamma = 0.0;\n            // Solver temp\n            _this.m_rA; // Vec2\n            _this.m_rB; // Vec2\n            _this.m_localCenterA; // Vec2\n            _this.m_localCenterB; // Vec2\n            _this.m_invMassA; // float\n            _this.m_invMassB; // float\n            _this.m_invIA; // float\n            _this.m_invIB; // float\n            _this.m_mass = new Mat33();\n            return _this;\n        // Point-to-point constraint\n        // C = p2 - p1\n        // Cdot = v2 - v1\n        // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n        // J = [-I -r1_skew I r2_skew ]\n        // Identity used:\n        // w k % (rx i + ry j) = w * (-ry i + rx j)\n        // Angle constraint\n        // C = angle2 - angle1 - referenceAngle\n        // Cdot = w2 - w1\n        // J = [0 0 -1 0 0 1]\n        // K = invI1 + invI2\n        }\n        /** @internal */ WeldJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                referenceAngle: this.m_referenceAngle\n            };\n        };\n        /** @internal */ WeldJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new WeldJoint(data);\n            return joint;\n        };\n        /** @internal */ WeldJoint.prototype._setAnchors = function(def) {\n            if (def.anchorA) this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            else if (def.localAnchorA) this.m_localAnchorA.setVec2(def.localAnchorA);\n            if (def.anchorB) this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            else if (def.localAnchorB) this.m_localAnchorB.setVec2(def.localAnchorB);\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */ WeldJoint.prototype.getLocalAnchorA = function() {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */ WeldJoint.prototype.getLocalAnchorB = function() {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Get the reference angle.\n         */ WeldJoint.prototype.getReferenceAngle = function() {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Set frequency in Hz.\n         */ WeldJoint.prototype.setFrequency = function(hz) {\n            this.m_frequencyHz = hz;\n        };\n        /**\n         * Get frequency in Hz.\n         */ WeldJoint.prototype.getFrequency = function() {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set damping ratio.\n         */ WeldJoint.prototype.setDampingRatio = function(ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        /**\n         * Get damping ratio.\n         */ WeldJoint.prototype.getDampingRatio = function() {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ WeldJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ WeldJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ WeldJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ WeldJoint.prototype.getReactionTorque = function(inv_dt) {\n            return inv_dt * this.m_impulse.z;\n        };\n        WeldJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat33();\n            K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\n            K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n            K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n            K.ex.y = K.ey.x;\n            K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\n            K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n            K.ex.z = K.ez.x;\n            K.ey.z = K.ez.y;\n            K.ez.z = iA + iB;\n            if (this.m_frequencyHz > 0.0) {\n                K.getInverse22(this.m_mass);\n                var invM = iA + iB; // float\n                var m = invM > 0.0 ? 1.0 / invM : 0.0; // float\n                var C = aB - aA - this.m_referenceAngle; // float\n                // Frequency\n                var omega = 2.0 * math.PI * this.m_frequencyHz; // float\n                // Damping coefficient\n                var d = 2.0 * m * this.m_dampingRatio * omega; // float\n                // Spring stiffness\n                var k = m * omega * omega; // float\n                // magic formulas\n                var h = step.dt; // float\n                this.m_gamma = h * (d + h * k);\n                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n                this.m_bias = C * h * k * this.m_gamma;\n                invM += this.m_gamma;\n                this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n            } else if (K.ez.z == 0.0) {\n                K.getInverse22(this.m_mass);\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            } else {\n                K.getSymInverse33(this.m_mass);\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n            } else this.m_impulse.setZero();\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        WeldJoint.prototype.solveVelocityConstraints = function(step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            if (this.m_frequencyHz > 0.0) {\n                var Cdot2 = wB - wA; // float\n                var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float\n                this.m_impulse.z += impulse2;\n                wA -= iA * impulse2;\n                wB += iB * impulse2;\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n                var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2\n                this.m_impulse.x += impulse1.x;\n                this.m_impulse.y += impulse1.y;\n                var P = Vec2.clone(impulse1); // Vec2\n                vA.subMul(mA, P);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(mB, P);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n            } else {\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n                var Cdot2 = wB - wA; // float\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3\n                var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3\n                this.m_impulse.add(impulse);\n                var P = Vec2.neo(impulse.x, impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ WeldJoint.prototype.solvePositionConstraints = function(step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var positionError;\n            var angularError;\n            var K = new Mat33();\n            K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n            K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n            K.ez.x = -rA.y * iA - rB.y * iB;\n            K.ex.y = K.ey.x;\n            K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n            K.ez.y = rA.x * iA + rB.x * iB;\n            K.ex.z = K.ez.x;\n            K.ey.z = K.ez.y;\n            K.ez.z = iA + iB;\n            if (this.m_frequencyHz > 0.0) {\n                var C1 = Vec2.zero();\n                C1.addCombine(1, cB, 1, rB);\n                C1.subCombine(1, cA, 1, rA); // Vec2\n                positionError = C1.length();\n                angularError = 0.0;\n                var P = Vec2.neg(K.solve22(C1)); // Vec2\n                cA.subMul(mA, P);\n                aA -= iA * Vec2.crossVec2Vec2(rA, P);\n                cB.addMul(mB, P);\n                aB += iB * Vec2.crossVec2Vec2(rB, P);\n            } else {\n                var C1 = Vec2.zero();\n                C1.addCombine(1, cB, 1, rB);\n                C1.subCombine(1, cA, 1, rA);\n                var C2 = aB - aA - this.m_referenceAngle; // float\n                positionError = C1.length();\n                angularError = math.abs(C2);\n                var C = new Vec3(C1.x, C1.y, C2);\n                var impulse = new Vec3();\n                if (K.ez.z > 0.0) impulse = Vec3.neg(K.solve33(C));\n                else {\n                    var impulse2 = Vec2.neg(K.solve22(C1));\n                    impulse.set(impulse2.x, impulse2.y, 0.0);\n                }\n                var P = Vec2.neo(impulse.x, impulse.y);\n                cA.subMul(mA, P);\n                aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n                cB.addMul(mB, P);\n                aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n            }\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n        };\n        WeldJoint.TYPE = \"weld-joint\";\n        return WeldJoint;\n    }(Joint);\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ var DEFAULTS = {\n        enableMotor: false,\n        maxMotorTorque: 0.0,\n        motorSpeed: 0.0,\n        frequencyHz: 2.0,\n        dampingRatio: 0.7\n    };\n    /**\n     * A wheel joint. This joint provides two degrees of freedom: translation along\n     * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n     * point to line constraint with a rotational motor and a linear spring/damper.\n     * This joint is designed for vehicle suspensions.\n     */ var WheelJoint = /** @class */ function(_super) {\n        __extends(WheelJoint, _super);\n        // @ts-ignore\n        function WheelJoint(def, bodyA, bodyB, anchor, axis) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof WheelJoint)) return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n            def = options(def, DEFAULTS);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            /** @internal */ _this.m_ax = Vec2.zero();\n            /** @internal */ _this.m_ay = Vec2.zero();\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = WheelJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            // @ts-ignore localAxis\n            _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));\n            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);\n            _this.m_mass = 0.0;\n            _this.m_impulse = 0.0;\n            _this.m_motorMass = 0.0;\n            _this.m_motorImpulse = 0.0;\n            _this.m_springMass = 0.0;\n            _this.m_springImpulse = 0.0;\n            _this.m_maxMotorTorque = def.maxMotorTorque;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableMotor = def.enableMotor;\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_bias = 0.0;\n            _this.m_gamma = 0.0;\n            return _this;\n        // Linear constraint (point-to-line)\n        // d = pB - pA = xB + rB - xA - rA\n        // C = dot(ay, d)\n        // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n        // rA))\n        // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n        // ay), vB)\n        // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n        // Spring linear constraint\n        // C = dot(ax, d)\n        // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n        // dot(cross(rB, ax), vB)\n        // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n        // Motor rotational constraint\n        // Cdot = wB - wA\n        // J = [0 0 -1 0 0 1]\n        }\n        /** @internal */ WheelJoint.prototype._serialize = function() {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                enableMotor: this.m_enableMotor,\n                maxMotorTorque: this.m_maxMotorTorque,\n                motorSpeed: this.m_motorSpeed,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                localAxisA: this.m_localXAxisA\n            };\n        };\n        /** @internal */ WheelJoint._deserialize = function(data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new WheelJoint(data);\n            return joint;\n        };\n        /** @internal */ WheelJoint.prototype._setAnchors = function(def) {\n            if (def.anchorA) this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            else if (def.localAnchorA) this.m_localAnchorA.setVec2(def.localAnchorA);\n            if (def.anchorB) this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            else if (def.localAnchorB) this.m_localAnchorB.setVec2(def.localAnchorB);\n            if (def.localAxisA) {\n                this.m_localXAxisA.setVec2(def.localAxisA);\n                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */ WheelJoint.prototype.getLocalAnchorA = function() {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */ WheelJoint.prototype.getLocalAnchorB = function() {\n            return this.m_localAnchorB;\n        };\n        /**\n         * The local joint axis relative to bodyA.\n         */ WheelJoint.prototype.getLocalAxisA = function() {\n            return this.m_localXAxisA;\n        };\n        /**\n         * Get the current joint translation, usually in meters.\n         */ WheelJoint.prototype.getJointTranslation = function() {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            var pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2\n            var pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2\n            var d = Vec2.sub(pB, pA); // Vec2\n            var axis = bA.getWorldVector(this.m_localXAxisA); // Vec2\n            var translation = Vec2.dot(d, axis); // float\n            return translation;\n        };\n        /**\n         * Get the current joint translation speed, usually in meters per second.\n         */ WheelJoint.prototype.getJointSpeed = function() {\n            var wA = this.m_bodyA.m_angularVelocity;\n            var wB = this.m_bodyB.m_angularVelocity;\n            return wB - wA;\n        };\n        /**\n         * Is the joint motor enabled?\n         */ WheelJoint.prototype.isMotorEnabled = function() {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */ WheelJoint.prototype.enableMotor = function(flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Set the motor speed, usually in radians per second.\n         */ WheelJoint.prototype.setMotorSpeed = function(speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Get the motor speed, usually in radians per second.\n         */ WheelJoint.prototype.getMotorSpeed = function() {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Set/Get the maximum motor force, usually in N-m.\n         */ WheelJoint.prototype.setMaxMotorTorque = function(torque) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorTorque = torque;\n        };\n        WheelJoint.prototype.getMaxMotorTorque = function() {\n            return this.m_maxMotorTorque;\n        };\n        /**\n         * Get the current motor torque given the inverse time step, usually in N-m.\n         */ WheelJoint.prototype.getMotorTorque = function(inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n         * the spring.\n         */ WheelJoint.prototype.setSpringFrequencyHz = function(hz) {\n            this.m_frequencyHz = hz;\n        };\n        WheelJoint.prototype.getSpringFrequencyHz = function() {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set/Get the spring damping ratio\n         */ WheelJoint.prototype.setSpringDampingRatio = function(ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        WheelJoint.prototype.getSpringDampingRatio = function() {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */ WheelJoint.prototype.getAnchorA = function() {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */ WheelJoint.prototype.getAnchorB = function() {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */ WheelJoint.prototype.getReactionForce = function(inv_dt) {\n            return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */ WheelJoint.prototype.getReactionTorque = function(inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        WheelJoint.prototype.initVelocityConstraints = function(step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective masses.\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA); // Vec2\n            this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n            this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n            this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n            this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;\n            if (this.m_mass > 0.0) this.m_mass = 1.0 / this.m_mass;\n            // Spring constraint\n            this.m_springMass = 0.0;\n            this.m_bias = 0.0;\n            this.m_gamma = 0.0;\n            if (this.m_frequencyHz > 0.0) {\n                this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n                this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n                this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n                var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx; // float\n                if (invMass > 0.0) {\n                    this.m_springMass = 1.0 / invMass;\n                    var C = Vec2.dot(d, this.m_ax); // float\n                    // Frequency\n                    var omega = 2.0 * math.PI * this.m_frequencyHz; // float\n                    // Damping coefficient\n                    var damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float\n                    // Spring stiffness\n                    var k = this.m_springMass * omega * omega; // float\n                    // magic formulas\n                    var h = step.dt; // float\n                    this.m_gamma = h * (damp + h * k);\n                    if (this.m_gamma > 0.0) this.m_gamma = 1.0 / this.m_gamma;\n                    this.m_bias = C * h * k * this.m_gamma;\n                    this.m_springMass = invMass + this.m_gamma;\n                    if (this.m_springMass > 0.0) this.m_springMass = 1.0 / this.m_springMass;\n                }\n            } else this.m_springImpulse = 0.0;\n            // Rotational motor\n            if (this.m_enableMotor) {\n                this.m_motorMass = iA + iB;\n                if (this.m_motorMass > 0.0) this.m_motorMass = 1.0 / this.m_motorMass;\n            } else {\n                this.m_motorMass = 0.0;\n                this.m_motorImpulse = 0.0;\n            }\n            if (step.warmStarting) {\n                // Account for variable time step.\n                this.m_impulse *= step.dtRatio;\n                this.m_springImpulse *= step.dtRatio;\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n                var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n                var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * LA;\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * LB;\n            } else {\n                this.m_impulse = 0.0;\n                this.m_springImpulse = 0.0;\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        WheelJoint.prototype.solveVelocityConstraints = function(step) {\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx * wB - this.m_sAx * wA; // float\n            var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float\n            this.m_springImpulse += impulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_ax); // Vec2\n            var LA = impulse * this.m_sAx; // float\n            var LB = impulse * this.m_sBx; // float\n            vA.subMul(mA, P);\n            wA -= iA * LA;\n            vB.addMul(mB, P);\n            wB += iB * LB;\n            var Cdot = wB - wA - this.m_motorSpeed; // float\n            var impulse = -this.m_motorMass * Cdot; // float\n            var oldImpulse = this.m_motorImpulse; // float\n            var maxImpulse = step.dt * this.m_maxMotorTorque; // float\n            this.m_motorImpulse = math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n            impulse = this.m_motorImpulse - oldImpulse;\n            wA -= iA * impulse;\n            wB += iB * impulse;\n            var Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy * wB - this.m_sAy * wA; // float\n            var impulse = -this.m_mass * Cdot; // float\n            this.m_impulse += impulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_ay); // Vec2\n            var LA = impulse * this.m_sAy; // float\n            var LB = impulse * this.m_sBy; // float\n            vA.subMul(mA, P);\n            wA -= iA * LA;\n            vB.addMul(mB, P);\n            wB += iB * LB;\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */ WheelJoint.prototype.solvePositionConstraints = function(step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA);\n            var ay = Rot.mulVec2(qA, this.m_localYAxisA);\n            var sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay); // float\n            var sBy = Vec2.crossVec2Vec2(rB, ay); // float\n            var C = Vec2.dot(d, ay); // float\n            var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float\n            var impulse; // float\n            if (k != 0.0) impulse = -C / k;\n            else impulse = 0.0;\n            var P = Vec2.mulNumVec2(impulse, ay); // Vec2\n            var LA = impulse * sAy; // float\n            var LB = impulse * sBy; // float\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * LA;\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * LB;\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return math.abs(C) <= Settings.linearSlop;\n        };\n        WheelJoint.TYPE = \"wheel-joint\";\n        return WheelJoint;\n    }(Joint);\n    var SID = 0;\n    function Serializer(opts) {\n        var _a;\n        opts = opts || {};\n        var rootClass = opts.rootClass || World;\n        var preSerialize = opts.preSerialize || function(obj) {\n            return obj;\n        };\n        var postSerialize = opts.postSerialize || function(data, obj) {\n            return data;\n        };\n        var preDeserialize = opts.preDeserialize || function(data) {\n            return data;\n        };\n        var postDeserialize = opts.postDeserialize || function(obj, data) {\n            return obj;\n        };\n        // This is used to create ref objects during serialize\n        var refTypes = {\n            World: World,\n            Body: Body,\n            Joint: Joint,\n            Fixture: Fixture,\n            Shape: Shape\n        };\n        // This is used by restore to deserialize objects and refs\n        var restoreTypes = __assign({\n            Vec2: Vec2,\n            Vec3: Vec3\n        }, refTypes);\n        var CLASS_BY_TYPE_PROP = (_a = {}, _a[Body.STATIC] = Body, _a[Body.DYNAMIC] = Body, _a[Body.KINEMATIC] = Body, _a[ChainShape.TYPE] = ChainShape, _a[BoxShape.TYPE] = BoxShape, _a[EdgeShape.TYPE] = EdgeShape, _a[PolygonShape.TYPE] = PolygonShape, _a[CircleShape.TYPE] = CircleShape, _a[DistanceJoint.TYPE] = DistanceJoint, _a[FrictionJoint.TYPE] = FrictionJoint, _a[GearJoint.TYPE] = GearJoint, _a[MotorJoint.TYPE] = MotorJoint, _a[MouseJoint.TYPE] = MouseJoint, _a[PrismaticJoint.TYPE] = PrismaticJoint, _a[PulleyJoint.TYPE] = PulleyJoint, _a[RevoluteJoint.TYPE] = RevoluteJoint, _a[RopeJoint.TYPE] = RopeJoint, _a[WeldJoint.TYPE] = WeldJoint, _a[WheelJoint.TYPE] = WheelJoint, _a);\n        this.toJson = function(root) {\n            var json = [];\n            var queue = [\n                root\n            ];\n            var refMap = {};\n            function storeRef(value, typeName) {\n                value.__sid = value.__sid || ++SID;\n                if (!refMap[value.__sid]) {\n                    queue.push(value);\n                    var index = json.length + queue.length;\n                    var ref = {\n                        refIndex: index,\n                        refType: typeName\n                    };\n                    refMap[value.__sid] = ref;\n                }\n                return refMap[value.__sid];\n            }\n            function serialize(obj) {\n                obj = preSerialize(obj);\n                var data = obj._serialize();\n                data = postSerialize(data, obj);\n                return data;\n            }\n            function toJson(value, top) {\n                if (typeof value !== \"object\" || value === null) return value;\n                if (typeof value._serialize === \"function\") {\n                    if (value !== top) // tslint:disable-next-line:no-for-in\n                    for(var typeName in refTypes){\n                        if (value instanceof refTypes[typeName]) return storeRef(value, typeName);\n                    }\n                    value = serialize(value);\n                }\n                if (Array.isArray(value)) {\n                    var newValue = [];\n                    for(var key = 0; key < value.length; key++)newValue[key] = toJson(value[key]);\n                    value = newValue;\n                } else {\n                    var newValue = {};\n                    // tslint:disable-next-line:no-for-in\n                    for(var key in value)if (value.hasOwnProperty(key)) newValue[key] = toJson(value[key]);\n                    value = newValue;\n                }\n                return value;\n            }\n            while(queue.length){\n                var obj = queue.shift();\n                var str = toJson(obj, obj);\n                json.push(str);\n            }\n            return json;\n        };\n        this.fromJson = function(json) {\n            var refMap = {};\n            function findDeserilizer(data, cls) {\n                if (!cls || !cls._deserialize) cls = CLASS_BY_TYPE_PROP[data.type];\n                return cls && cls._deserialize;\n            }\n            /**\n             * Deserialize a data object.\n             */ function deserialize(cls, data, ctx) {\n                var deserializer = findDeserilizer(data, cls);\n                if (!deserializer) return;\n                data = preDeserialize(data);\n                var obj = deserializer(data, ctx, restoreRef);\n                obj = postDeserialize(obj, data);\n                return obj;\n            }\n            /**\n             * Restore a ref object or deserialize a data object.\n             *\n             * This is passed as callback to class deserializers.\n             */ function restoreRef(cls, ref, ctx) {\n                if (!ref.refIndex) return cls && cls._deserialize && deserialize(cls, ref, ctx);\n                cls = restoreTypes[ref.refType] || cls;\n                var index = ref.refIndex;\n                if (!refMap[index]) {\n                    var data = json[index];\n                    var obj = deserialize(cls, data, ctx);\n                    refMap[index] = obj;\n                }\n                return refMap[index];\n            }\n            var root = rootClass._deserialize(json[0], null, restoreRef);\n            return root;\n        };\n    }\n    var serializer = new Serializer();\n    Serializer.toJson = serializer.toJson;\n    Serializer.fromJson = serializer.fromJson;\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n    function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    function CollideCircles(manifold, circleA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        var pA = Transform.mulVec2(xfA, circleA.m_p);\n        var pB = Transform.mulVec2(xfB, circleB.m_p);\n        var distSqr = Vec2.distanceSquared(pB, pA);\n        var rA = circleA.m_radius;\n        var rB = circleB.m_radius;\n        var radius = rA + rB;\n        if (distSqr > radius * radius) return;\n        manifold.type = ManifoldType.e_circles;\n        manifold.localPoint.setVec2(circleA.m_p);\n        manifold.localNormal.setZero();\n        manifold.pointCount = 1;\n        manifold.points[0].localPoint.setVec2(circleB.m_p);\n        // manifold.points[0].id.key = 0;\n        manifold.points[0].id.cf.indexA = 0;\n        manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n        manifold.points[0].id.cf.indexB = 0;\n        manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\n    Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n    function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        var shapeA = fixtureA.getShape();\n        var shapeB = fixtureB.getShape();\n        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n    }\n    function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        var chain = fixtureA.getShape();\n        var edge = new EdgeShape();\n        chain.getChildEdge(edge, indexA);\n        var shapeA = edge;\n        var shapeB = fixtureB.getShape();\n        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n    }\n    // Compute contact points for edge versus circle.\n    // This accounts for edge connectivity.\n    function CollideEdgeCircle(manifold, edgeA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        // Compute circle in frame of edge\n        var Q = Transform.mulTVec2(xfA, Transform.mulVec2(xfB, circleB.m_p));\n        var A = edgeA.m_vertex1;\n        var B = edgeA.m_vertex2;\n        var e = Vec2.sub(B, A);\n        // Barycentric coordinates\n        var u = Vec2.dot(e, Vec2.sub(B, Q));\n        var v = Vec2.dot(e, Vec2.sub(Q, A));\n        var radius = edgeA.m_radius + circleB.m_radius;\n        // Region A\n        if (v <= 0.0) {\n            var P_1 = Vec2.clone(A);\n            var d_1 = Vec2.sub(Q, P_1);\n            var dd_1 = Vec2.dot(d_1, d_1);\n            if (dd_1 > radius * radius) return;\n            // Is there an edge connected to A?\n            if (edgeA.m_hasVertex0) {\n                var A1 = edgeA.m_vertex0;\n                var B1 = A;\n                var e1 = Vec2.sub(B1, A1);\n                var u1 = Vec2.dot(e1, Vec2.sub(B1, Q));\n                // Is the circle in Region AB of the previous edge?\n                if (u1 > 0.0) return;\n            }\n            manifold.type = ManifoldType.e_circles;\n            manifold.localNormal.setZero();\n            manifold.localPoint.setVec2(P_1);\n            manifold.pointCount = 1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Region B\n        if (u <= 0.0) {\n            var P_2 = Vec2.clone(B);\n            var d_2 = Vec2.sub(Q, P_2);\n            var dd_2 = Vec2.dot(d_2, d_2);\n            if (dd_2 > radius * radius) return;\n            // Is there an edge connected to B?\n            if (edgeA.m_hasVertex3) {\n                var B2 = edgeA.m_vertex3;\n                var A2 = B;\n                var e2 = Vec2.sub(B2, A2);\n                var v2 = Vec2.dot(e2, Vec2.sub(Q, A2));\n                // Is the circle in Region AB of the next edge?\n                if (v2 > 0.0) return;\n            }\n            manifold.type = ManifoldType.e_circles;\n            manifold.localNormal.setZero();\n            manifold.localPoint.setVec2(P_2);\n            manifold.pointCount = 1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 1;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Region AB\n        var den = Vec2.dot(e, e);\n        var P = Vec2.combine(u / den, A, v / den, B);\n        var d = Vec2.sub(Q, P);\n        var dd = Vec2.dot(d, d);\n        if (dd > radius * radius) return;\n        var n = Vec2.neo(-e.y, e.x);\n        if (Vec2.dot(n, Vec2.sub(Q, A)) < 0.0) n.setNum(-n.x, -n.y);\n        n.normalize();\n        manifold.type = ManifoldType.e_faceA;\n        manifold.localNormal = n;\n        manifold.localPoint.setVec2(A);\n        manifold.pointCount = 1;\n        manifold.points[0].localPoint.setVec2(circleB.m_p);\n        // manifold.points[0].id.key = 0;\n        manifold.points[0].id.cf.indexA = 0;\n        manifold.points[0].id.cf.typeA = ContactFeatureType.e_face;\n        manifold.points[0].id.cf.indexB = 0;\n        manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n    function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    /**\n     * Find the max separation between poly1 and poly2 using edge normals from\n     * poly1.\n     */ function findMaxSeparation(poly1, xf1, poly2, xf2, output) {\n        var count1 = poly1.m_count;\n        var count2 = poly2.m_count;\n        var n1s = poly1.m_normals;\n        var v1s = poly1.m_vertices;\n        var v2s = poly2.m_vertices;\n        var xf = Transform.mulTXf(xf2, xf1);\n        var bestIndex = 0;\n        var maxSeparation = -Infinity;\n        for(var i = 0; i < count1; ++i){\n            // Get poly1 normal in frame2.\n            var n = Rot.mulVec2(xf.q, n1s[i]);\n            var v1 = Transform.mulVec2(xf, v1s[i]);\n            // Find deepest point for normal i.\n            var si = Infinity;\n            for(var j = 0; j < count2; ++j){\n                var sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);\n                if (sij < si) si = sij;\n            }\n            if (si > maxSeparation) {\n                maxSeparation = si;\n                bestIndex = i;\n            }\n        }\n        // used to keep last FindMaxSeparation call values\n        output.maxSeparation = maxSeparation;\n        output.bestIndex = bestIndex;\n    }\n    function findIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {\n        var normals1 = poly1.m_normals;\n        var count2 = poly2.m_count;\n        var vertices2 = poly2.m_vertices;\n        var normals2 = poly2.m_normals;\n        // Get the normal of the reference edge in poly2's frame.\n        var normal1 = Rot.mulTVec2(xf2.q, Rot.mulVec2(xf1.q, normals1[edge1]));\n        // Find the incident edge on poly2.\n        var index = 0;\n        var minDot = Infinity;\n        for(var i = 0; i < count2; ++i){\n            var dot = Vec2.dot(normal1, normals2[i]);\n            if (dot < minDot) {\n                minDot = dot;\n                index = i;\n            }\n        }\n        // Build the clip vertices for the incident edge.\n        var i1 = index;\n        var i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n        c[0].v = Transform.mulVec2(xf2, vertices2[i1]);\n        c[0].id.cf.indexA = edge1;\n        c[0].id.cf.indexB = i1;\n        c[0].id.cf.typeA = ContactFeatureType.e_face;\n        c[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        c[1].v = Transform.mulVec2(xf2, vertices2[i2]);\n        c[1].id.cf.indexA = edge1;\n        c[1].id.cf.indexB = i2;\n        c[1].id.cf.typeA = ContactFeatureType.e_face;\n        c[1].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n    var maxSeparation = {\n        maxSeparation: 0,\n        bestIndex: 0\n    };\n    /**\n     *\n     * Find edge normal of max separation on A - return if separating axis is found<br>\n     * Find edge normal of max separation on B - return if separation axis is found<br>\n     * Choose reference edge as min(minA, minB)<br>\n     * Find incident edge<br>\n     * Clip\n     *\n     * The normal points from 1 to 2\n     */ function CollidePolygons(manifold, polyA, xfA, polyB, xfB) {\n        manifold.pointCount = 0;\n        var totalRadius = polyA.m_radius + polyB.m_radius;\n        findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n        var edgeA = maxSeparation.bestIndex;\n        var separationA = maxSeparation.maxSeparation;\n        if (separationA > totalRadius) return;\n        findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n        var edgeB = maxSeparation.bestIndex;\n        var separationB = maxSeparation.maxSeparation;\n        if (separationB > totalRadius) return;\n        var poly1; // reference polygon\n        var poly2; // incident polygon\n        var xf1;\n        var xf2;\n        var edge1; // reference edge\n        var flip;\n        var k_tol = 0.1 * Settings.linearSlop;\n        if (separationB > separationA + k_tol) {\n            poly1 = polyB;\n            poly2 = polyA;\n            xf1 = xfB;\n            xf2 = xfA;\n            edge1 = edgeB;\n            manifold.type = ManifoldType.e_faceB;\n            flip = 1;\n        } else {\n            poly1 = polyA;\n            poly2 = polyB;\n            xf1 = xfA;\n            xf2 = xfB;\n            edge1 = edgeA;\n            manifold.type = ManifoldType.e_faceA;\n            flip = 0;\n        }\n        var incidentEdge = [\n            new ClipVertex(),\n            new ClipVertex()\n        ];\n        findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n        var count1 = poly1.m_count;\n        var vertices1 = poly1.m_vertices;\n        var iv1 = edge1;\n        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n        var v11 = vertices1[iv1];\n        var v12 = vertices1[iv2];\n        var localTangent = Vec2.sub(v12, v11);\n        localTangent.normalize();\n        var localNormal = Vec2.crossVec2Num(localTangent, 1.0);\n        var planePoint = Vec2.combine(0.5, v11, 0.5, v12);\n        var tangent = Rot.mulVec2(xf1.q, localTangent);\n        var normal = Vec2.crossVec2Num(tangent, 1.0);\n        v11 = Transform.mulVec2(xf1, v11);\n        v12 = Transform.mulVec2(xf1, v12);\n        // Face offset.\n        var frontOffset = Vec2.dot(normal, v11);\n        // Side offsets, extended by polytope skin thickness.\n        var sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;\n        var sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;\n        // Clip incident edge against extruded edge1 side edges.\n        var clipPoints1 = [\n            new ClipVertex(),\n            new ClipVertex()\n        ];\n        var clipPoints2 = [\n            new ClipVertex(),\n            new ClipVertex()\n        ];\n        var np;\n        // Clip to box side 1\n        np = clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg(tangent), sideOffset1, iv1);\n        if (np < 2) return;\n        // Clip to negative box side 1\n        np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\n        if (np < 2) return;\n        // Now clipPoints2 contains the clipped points.\n        manifold.localNormal = localNormal;\n        manifold.localPoint = planePoint;\n        var pointCount = 0;\n        for(var i = 0; i < clipPoints2.length /* maxManifoldPoints */ ; ++i){\n            var separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;\n            if (separation <= totalRadius) {\n                var cp = manifold.points[pointCount];\n                cp.localPoint.setVec2(Transform.mulTVec2(xf2, clipPoints2[i].v));\n                cp.id = clipPoints2[i].id;\n                if (flip) {\n                    // Swap features\n                    var cf = cp.id.cf;\n                    var indexA = cf.indexA;\n                    var indexB = cf.indexB;\n                    var typeA = cf.typeA;\n                    var typeB = cf.typeB;\n                    cf.indexA = indexB;\n                    cf.indexB = indexA;\n                    cf.typeA = typeB;\n                    cf.typeB = typeA;\n                }\n                ++pointCount;\n            }\n        }\n        manifold.pointCount = pointCount;\n    }\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n    function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    function CollidePolygonCircle(manifold, polygonA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        // Compute circle position in the frame of the polygon.\n        var c = Transform.mulVec2(xfB, circleB.m_p);\n        var cLocal = Transform.mulTVec2(xfA, c);\n        // Find the min separating edge.\n        var normalIndex = 0;\n        var separation = -Infinity;\n        var radius = polygonA.m_radius + circleB.m_radius;\n        var vertexCount = polygonA.m_count;\n        var vertices = polygonA.m_vertices;\n        var normals = polygonA.m_normals;\n        for(var i = 0; i < vertexCount; ++i){\n            var s = Vec2.dot(normals[i], Vec2.sub(cLocal, vertices[i]));\n            if (s > radius) // Early out.\n            return;\n            if (s > separation) {\n                separation = s;\n                normalIndex = i;\n            }\n        }\n        // Vertices that subtend the incident face.\n        var vertIndex1 = normalIndex;\n        var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n        var v1 = vertices[vertIndex1];\n        var v2 = vertices[vertIndex2];\n        // If the center is inside the polygon ...\n        if (separation < math.EPSILON) {\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setVec2(normals[normalIndex]);\n            manifold.localPoint.setCombine(0.5, v1, 0.5, v2);\n            manifold.points[0].localPoint = circleB.m_p;\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Compute barycentric coordinates\n        var u1 = Vec2.dot(Vec2.sub(cLocal, v1), Vec2.sub(v2, v1));\n        var u2 = Vec2.dot(Vec2.sub(cLocal, v2), Vec2.sub(v1, v2));\n        if (u1 <= 0.0) {\n            if (Vec2.distanceSquared(cLocal, v1) > radius * radius) return;\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setCombine(1, cLocal, -1, v1);\n            manifold.localNormal.normalize();\n            manifold.localPoint = v1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        } else if (u2 <= 0.0) {\n            if (Vec2.distanceSquared(cLocal, v2) > radius * radius) return;\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setCombine(1, cLocal, -1, v2);\n            manifold.localNormal.normalize();\n            manifold.localPoint.setVec2(v2);\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        } else {\n            var faceCenter = Vec2.mid(v1, v2);\n            var separation_1 = Vec2.dot(cLocal, normals[vertIndex1]) - Vec2.dot(faceCenter, normals[vertIndex1]);\n            if (separation_1 > radius) return;\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setVec2(normals[vertIndex1]);\n            manifold.localPoint.setVec2(faceCenter);\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        }\n    }\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */ Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\n    Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n    function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {\n        CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);\n    }\n    function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {\n        var chain = fA.getShape();\n        var edge = new EdgeShape();\n        chain.getChildEdge(edge, indexA);\n        CollideEdgePolygon(manifold, edge, xfA, fB.getShape(), xfB);\n    }\n    var EPAxisType;\n    (function(EPAxisType) {\n        EPAxisType[EPAxisType[\"e_unknown\"] = -1] = \"e_unknown\";\n        EPAxisType[EPAxisType[\"e_edgeA\"] = 1] = \"e_edgeA\";\n        EPAxisType[EPAxisType[\"e_edgeB\"] = 2] = \"e_edgeB\";\n    })(EPAxisType || (EPAxisType = {}));\n    // unused?\n    var VertexType;\n    (function(VertexType) {\n        VertexType[VertexType[\"e_isolated\"] = 0] = \"e_isolated\";\n        VertexType[VertexType[\"e_concave\"] = 1] = \"e_concave\";\n        VertexType[VertexType[\"e_convex\"] = 2] = \"e_convex\";\n    })(VertexType || (VertexType = {}));\n    /**\n     * This structure is used to keep track of the best separating axis.\n     */ var EPAxis = /** @class */ function() {\n        function EPAxis() {}\n        return EPAxis;\n    }();\n    /**\n     * This holds polygon B expressed in frame A.\n     */ var TempPolygon = /** @class */ function() {\n        function TempPolygon() {\n            this.vertices = []; // [Settings.maxPolygonVertices]\n            this.normals = []; // [Settings.maxPolygonVertices];\n            this.count = 0;\n        }\n        return TempPolygon;\n    }();\n    /**\n     * Reference face used for clipping\n     */ var ReferenceFace = /** @class */ function() {\n        function ReferenceFace() {\n            this.normal = Vec2.zero();\n            this.sideNormal1 = Vec2.zero();\n            this.sideNormal2 = Vec2.zero();\n        }\n        return ReferenceFace;\n    }();\n    // reused\n    var edgeAxis = new EPAxis();\n    var polygonAxis = new EPAxis();\n    var polygonBA = new TempPolygon();\n    var rf = new ReferenceFace();\n    /**\n     * This function collides and edge and a polygon, taking into account edge\n     * adjacency.\n     */ function CollideEdgePolygon(manifold, edgeA, xfA, polygonB, xfB) {\n        // Algorithm:\n        // 1. Classify v1 and v2\n        // 2. Classify polygon centroid as front or back\n        // 3. Flip normal if necessary\n        // 4. Initialize normal range to [-pi, pi] about face normal\n        // 5. Adjust normal range according to adjacent edges\n        // 6. Visit each separating axes, only accept axes within the range\n        // 7. Return if _any_ axis indicates separation\n        // 8. Clip\n        // let m_type1: VertexType;\n        // let m_type2: VertexType;\n        var xf = Transform.mulTXf(xfA, xfB);\n        var centroidB = Transform.mulVec2(xf, polygonB.m_centroid);\n        var v0 = edgeA.m_vertex0;\n        var v1 = edgeA.m_vertex1;\n        var v2 = edgeA.m_vertex2;\n        var v3 = edgeA.m_vertex3;\n        var hasVertex0 = edgeA.m_hasVertex0;\n        var hasVertex3 = edgeA.m_hasVertex3;\n        var edge1 = Vec2.sub(v2, v1);\n        edge1.normalize();\n        var normal1 = Vec2.neo(edge1.y, -edge1.x);\n        var offset1 = Vec2.dot(normal1, Vec2.sub(centroidB, v1));\n        var offset0 = 0.0;\n        var offset2 = 0.0;\n        var convex1 = false;\n        var convex2 = false;\n        var normal0;\n        var normal2;\n        // Is there a preceding edge?\n        if (hasVertex0) {\n            var edge0 = Vec2.sub(v1, v0);\n            edge0.normalize();\n            normal0 = Vec2.neo(edge0.y, -edge0.x);\n            convex1 = Vec2.crossVec2Vec2(edge0, edge1) >= 0.0;\n            offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n        }\n        // Is there a following edge?\n        if (hasVertex3) {\n            var edge2 = Vec2.sub(v3, v2);\n            edge2.normalize();\n            normal2 = Vec2.neo(edge2.y, -edge2.x);\n            convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n            offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n        }\n        var front;\n        var normal = Vec2.zero();\n        var lowerLimit = Vec2.zero();\n        var upperLimit = Vec2.zero();\n        // Determine front or back collision. Determine collision normal limits.\n        if (hasVertex0 && hasVertex3) {\n            if (convex1 && convex2) {\n                front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setVec2(normal2);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n            } else if (convex1) {\n                front = offset0 >= 0.0 || offset1 >= 0.0 && offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setVec2(normal1);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setMul(-1, normal1);\n                }\n            } else if (convex2) {\n                front = offset2 >= 0.0 || offset0 >= 0.0 && offset1 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setVec2(normal2);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setMul(-1, normal0);\n                }\n            } else {\n                front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setVec2(normal1);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n        } else if (hasVertex0) {\n            if (convex1) {\n                front = offset0 >= 0.0 || offset1 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setMul(-1, normal1);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n            } else {\n                front = offset0 >= 0.0 && offset1 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal1);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n        } else if (hasVertex3) {\n            if (convex2) {\n                front = offset1 >= 0.0 || offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal2);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal1);\n                }\n            } else {\n                front = offset1 >= 0.0 && offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal1);\n                } else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setVec2(normal1);\n                }\n            }\n        } else {\n            front = offset1 >= 0.0;\n            if (front) {\n                normal.setVec2(normal1);\n                lowerLimit.setMul(-1, normal1);\n                upperLimit.setMul(-1, normal1);\n            } else {\n                normal.setMul(-1, normal1);\n                lowerLimit.setVec2(normal1);\n                upperLimit.setVec2(normal1);\n            }\n        }\n        // Get polygonB in frameA\n        polygonBA.count = polygonB.m_count;\n        for(var i = 0; i < polygonB.m_count; ++i){\n            polygonBA.vertices[i] = Transform.mulVec2(xf, polygonB.m_vertices[i]);\n            polygonBA.normals[i] = Rot.mulVec2(xf.q, polygonB.m_normals[i]);\n        }\n        var radius = 2.0 * Settings.polygonRadius;\n        manifold.pointCount = 0;\n        edgeAxis.type = EPAxisType.e_edgeA;\n        edgeAxis.index = front ? 0 : 1;\n        edgeAxis.separation = Infinity;\n        for(var i = 0; i < polygonBA.count; ++i){\n            var s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1));\n            if (s < edgeAxis.separation) edgeAxis.separation = s;\n        }\n        // If no valid normal can be found than this edge should not collide.\n        // @ts-ignore\n        if (edgeAxis.type == EPAxisType.e_unknown) return;\n        if (edgeAxis.separation > radius) return;\n        polygonAxis.type = EPAxisType.e_unknown;\n        polygonAxis.index = -1;\n        polygonAxis.separation = -Infinity;\n        var perp = Vec2.neo(-normal.y, normal.x);\n        for(var i = 0; i < polygonBA.count; ++i){\n            var n = Vec2.neg(polygonBA.normals[i]);\n            var s1 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v1));\n            var s2 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v2));\n            var s = math.min(s1, s2);\n            if (s > radius) {\n                // No collision\n                polygonAxis.type = EPAxisType.e_edgeB;\n                polygonAxis.index = i;\n                polygonAxis.separation = s;\n                break;\n            }\n            // Adjacency\n            if (Vec2.dot(n, perp) >= 0.0) {\n                if (Vec2.dot(Vec2.sub(n, upperLimit), normal) < -Settings.angularSlop) continue;\n            } else {\n                if (Vec2.dot(Vec2.sub(n, lowerLimit), normal) < -Settings.angularSlop) continue;\n            }\n            if (s > polygonAxis.separation) {\n                polygonAxis.type = EPAxisType.e_edgeB;\n                polygonAxis.index = i;\n                polygonAxis.separation = s;\n            }\n        }\n        if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) return;\n        // Use hysteresis for jitter reduction.\n        var k_relativeTol = 0.98;\n        var k_absoluteTol = 0.001;\n        var primaryAxis;\n        if (polygonAxis.type == EPAxisType.e_unknown) primaryAxis = edgeAxis;\n        else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) primaryAxis = polygonAxis;\n        else primaryAxis = edgeAxis;\n        var ie = [\n            new ClipVertex(),\n            new ClipVertex()\n        ];\n        if (primaryAxis.type == EPAxisType.e_edgeA) {\n            manifold.type = ManifoldType.e_faceA;\n            // Search for the polygon normal that is most anti-parallel to the edge\n            // normal.\n            var bestIndex = 0;\n            var bestValue = Vec2.dot(normal, polygonBA.normals[0]);\n            for(var i = 1; i < polygonBA.count; ++i){\n                var value = Vec2.dot(normal, polygonBA.normals[i]);\n                if (value < bestValue) {\n                    bestValue = value;\n                    bestIndex = i;\n                }\n            }\n            var i1 = bestIndex;\n            var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n            ie[0].v = polygonBA.vertices[i1];\n            ie[0].id.cf.indexA = 0;\n            ie[0].id.cf.indexB = i1;\n            ie[0].id.cf.typeA = ContactFeatureType.e_face;\n            ie[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            ie[1].v = polygonBA.vertices[i2];\n            ie[1].id.cf.indexA = 0;\n            ie[1].id.cf.indexB = i2;\n            ie[1].id.cf.typeA = ContactFeatureType.e_face;\n            ie[1].id.cf.typeB = ContactFeatureType.e_vertex;\n            if (front) {\n                rf.i1 = 0;\n                rf.i2 = 1;\n                rf.v1 = v1;\n                rf.v2 = v2;\n                rf.normal.setVec2(normal1);\n            } else {\n                rf.i1 = 1;\n                rf.i2 = 0;\n                rf.v1 = v2;\n                rf.v2 = v1;\n                rf.normal.setMul(-1, normal1);\n            }\n        } else {\n            manifold.type = ManifoldType.e_faceB;\n            ie[0].v = v1;\n            ie[0].id.cf.indexA = 0;\n            ie[0].id.cf.indexB = primaryAxis.index;\n            ie[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            ie[0].id.cf.typeB = ContactFeatureType.e_face;\n            ie[1].v = v2;\n            ie[1].id.cf.indexA = 0;\n            ie[1].id.cf.indexB = primaryAxis.index;\n            ie[1].id.cf.typeA = ContactFeatureType.e_vertex;\n            ie[1].id.cf.typeB = ContactFeatureType.e_face;\n            rf.i1 = primaryAxis.index;\n            rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n            rf.v1 = polygonBA.vertices[rf.i1];\n            rf.v2 = polygonBA.vertices[rf.i2];\n            rf.normal.setVec2(polygonBA.normals[rf.i1]);\n        }\n        rf.sideNormal1.setNum(rf.normal.y, -rf.normal.x);\n        rf.sideNormal2.setMul(-1, rf.sideNormal1);\n        rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);\n        rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);\n        // Clip incident edge against extruded edge1 side edges.\n        var clipPoints1 = [\n            new ClipVertex(),\n            new ClipVertex()\n        ];\n        var clipPoints2 = [\n            new ClipVertex(),\n            new ClipVertex()\n        ];\n        var np;\n        // Clip to box side 1\n        np = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n        if (np < Settings.maxManifoldPoints) return;\n        // Clip to negative box side 1\n        np = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n        if (np < Settings.maxManifoldPoints) return;\n        // Now clipPoints2 contains the clipped points.\n        if (primaryAxis.type == EPAxisType.e_edgeA) {\n            manifold.localNormal = Vec2.clone(rf.normal);\n            manifold.localPoint = Vec2.clone(rf.v1);\n        } else {\n            manifold.localNormal = Vec2.clone(polygonB.m_normals[rf.i1]);\n            manifold.localPoint = Vec2.clone(polygonB.m_vertices[rf.i1]);\n        }\n        var pointCount = 0;\n        for(var i = 0; i < Settings.maxManifoldPoints; ++i){\n            var separation = Vec2.dot(rf.normal, Vec2.sub(clipPoints2[i].v, rf.v1));\n            if (separation <= radius) {\n                var cp = manifold.points[pointCount]; // ManifoldPoint\n                if (primaryAxis.type == EPAxisType.e_edgeA) {\n                    cp.localPoint = Transform.mulTVec2(xf, clipPoints2[i].v);\n                    cp.id = clipPoints2[i].id;\n                } else {\n                    cp.localPoint = clipPoints2[i].v;\n                    cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\n                    cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\n                    cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\n                    cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\n                }\n                ++pointCount;\n            }\n        }\n        manifold.pointCount = pointCount;\n    }\n    /** @deprecated Merged with main namespace */ var internal = {};\n    // @ts-ignore\n    internal.CollidePolygons = CollidePolygons;\n    // @ts-ignore\n    internal.Settings = Settings;\n    // @ts-ignore\n    internal.Sweep = Sweep;\n    // @ts-ignore\n    internal.Manifold = Manifold;\n    // @ts-ignore\n    internal.Distance = Distance;\n    // @ts-ignore\n    internal.TimeOfImpact = TimeOfImpact;\n    // @ts-ignore\n    internal.DynamicTree = DynamicTree;\n    // @ts-ignore\n    internal.stats = stats;\n    // @ts-ignore\n    Solver.TimeStep = TimeStep;\n    // @ts-ignore\n    Distance.testOverlap = testOverlap;\n    // @ts-ignore\n    Distance.Input = DistanceInput;\n    // @ts-ignore\n    Distance.Output = DistanceOutput;\n    // @ts-ignore\n    Distance.Proxy = DistanceProxy;\n    // @ts-ignore\n    Distance.Cache = SimplexCache;\n    // @ts-ignore\n    TimeOfImpact.Input = TOIInput;\n    // @ts-ignore\n    TimeOfImpact.Output = TOIOutput;\n    exports1.AABB = AABB;\n    exports1.Body = Body;\n    exports1.Box = BoxShape;\n    exports1.Chain = ChainShape;\n    exports1.Circle = CircleShape;\n    exports1.CollideCircles = CollideCircles;\n    exports1.CollideEdgeCircle = CollideEdgeCircle;\n    exports1.CollideEdgePolygon = CollideEdgePolygon;\n    exports1.CollidePolygonCircle = CollidePolygonCircle;\n    exports1.CollidePolygons = CollidePolygons;\n    exports1.Contact = Contact;\n    exports1.Distance = Distance;\n    exports1.DistanceJoint = DistanceJoint;\n    exports1.DynamicTree = DynamicTree;\n    exports1.Edge = EdgeShape;\n    exports1.Fixture = Fixture;\n    exports1.FrictionJoint = FrictionJoint;\n    exports1.GearJoint = GearJoint;\n    exports1.Joint = Joint;\n    exports1.Manifold = Manifold;\n    exports1.Mat22 = Mat22;\n    exports1.Mat33 = Mat33;\n    exports1.Math = math;\n    exports1.MotorJoint = MotorJoint;\n    exports1.MouseJoint = MouseJoint;\n    exports1.Polygon = PolygonShape;\n    exports1.PrismaticJoint = PrismaticJoint;\n    exports1.PulleyJoint = PulleyJoint;\n    exports1.RevoluteJoint = RevoluteJoint;\n    exports1.RopeJoint = RopeJoint;\n    exports1.Rot = Rot;\n    exports1.Serializer = Serializer;\n    exports1.Settings = Settings;\n    exports1.Shape = Shape;\n    exports1.Sweep = Sweep;\n    exports1.TimeOfImpact = TimeOfImpact;\n    exports1.Transform = Transform;\n    exports1.Vec2 = Vec2;\n    exports1.Vec3 = Vec3;\n    exports1.WeldJoint = WeldJoint;\n    exports1.WheelJoint = WheelJoint;\n    exports1.World = World;\n    exports1.internal = internal;\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n});\n\n\n\nconst $1d1927fc5b91d8b6$export$c2cc40734f29867c = 30;\nconst $1d1927fc5b91d8b6$export$1cd840e6ecaab774 = 1600;\nconst $1d1927fc5b91d8b6$export$3d795bc15e02aca = 900;\nconst $1d1927fc5b91d8b6$export$677ef9a3ce6796cf = 5;\nconst $1d1927fc5b91d8b6$export$2708cc8cc9b2d975 = 1000;\nvar $1d1927fc5b91d8b6$export$bc572fe44976cfbc;\n(function(Skills) {\n    Skills[Skills[\"None\"] = 0] = \"None\";\n    Skills[Skills[\"Impact\"] = 1] = \"Impact\";\n})($1d1927fc5b91d8b6$export$bc572fe44976cfbc || ($1d1927fc5b91d8b6$export$bc572fe44976cfbc = {}));\n\n\n\nfunction $28770b279d7ab5b1$export$e774a455380e7b24(world, pos, power, center, size) {\n    const mover = world.createKinematicBody({\n        position: pos\n    });\n    mover.createFixture({\n        shape: new $6f94c7a48e8964a6$exports.Box(size ? size : 2, 0.1, center ? center : new $6f94c7a48e8964a6$exports.Vec2()),\n        restitution: 0.7\n    });\n    mover.setAngularVelocity(power);\n    return mover;\n}\nfunction $28770b279d7ab5b1$export$9ea1ce01850d7d98(world, pos, size, isTemporary = false) {\n    const jumper = world.createBody({\n        position: pos\n    });\n    jumper.createFixture({\n        shape: new $6f94c7a48e8964a6$exports.Circle(new (0, $6f94c7a48e8964a6$exports.Vec2)(), size),\n        restitution: 1.5\n    });\n    jumper.setUserData({\n        isTemporary: isTemporary\n    });\n    return jumper;\n}\nfunction $28770b279d7ab5b1$export$6459fc9e86be362e(world, pos, rotation, width = 0.5, height = 0.25) {\n    const boxBody = world.createBody({\n        type: \"static\",\n        position: pos\n    });\n    boxBody.createFixture({\n        shape: new $6f94c7a48e8964a6$exports.Box(width, height)\n    });\n    boxBody.setAngle(rotation);\n    return boxBody;\n}\nfunction $28770b279d7ab5b1$export$29e4e862bebba87f(degree) {\n    return Math.PI * degree / 180;\n}\nfunction $28770b279d7ab5b1$var$getRegexValue(regex, str) {\n    const result = regex.exec(str);\n    return result ? result[1] : \"\";\n}\nfunction $28770b279d7ab5b1$export$5d945868514965a9(nameStr) {\n    const weightRegex = /(\\/\\d+)/;\n    const countRegex = /(\\*\\d+)/;\n    const hasWeight = weightRegex.test(nameStr);\n    const hasCount = countRegex.test(nameStr);\n    const name = $28770b279d7ab5b1$var$getRegexValue(/^\\s*([^\\/*]+)?/, nameStr);\n    if (!name) return null;\n    const weight = hasWeight ? parseInt($28770b279d7ab5b1$var$getRegexValue(weightRegex, nameStr).replace(\"/\", \"\")) : 1;\n    const count = hasCount ? parseInt($28770b279d7ab5b1$var$getRegexValue(countRegex, nameStr).replace(\"*\", \"\")) : 1;\n    return {\n        name: name,\n        weight: weight,\n        count: count\n    };\n}\nfunction $28770b279d7ab5b1$export$5d04458e2a6c373e(v) {\n    return v.toString().padStart(2, \"0\");\n}\n\n\nclass $2573268c577c952d$var$Options {\n    constructor(){\n        this.useSkills = true;\n        this.winningRank = 0;\n        this.autoRecording = true;\n    }\n}\nconst $2573268c577c952d$var$options = new $2573268c577c952d$var$Options();\nvar $2573268c577c952d$export$2e2bcd8739ae039 = $2573268c577c952d$var$options;\n\n\nclass $e7b6517817360fee$export$e91dba6fa3f67f68 {\n    get position() {\n        return this.body.getPosition();\n    }\n    get x() {\n        return this.position.x;\n    }\n    set x(v) {\n        this.position.x = v;\n    }\n    get y() {\n        return this.position.y;\n    }\n    set y(v) {\n        this.position.y = v;\n    }\n    constructor(world, order, max, name, weight = 1){\n        this.type = \"marble\";\n        this.name = \"\";\n        this.size = 0.5;\n        this.color = \"red\";\n        this.hue = 0;\n        this.impact = 0;\n        this.weight = 1;\n        this.skill = (0, $1d1927fc5b91d8b6$export$bc572fe44976cfbc).None;\n        this._skillRate = 0.0005;\n        this._coolTime = 5000;\n        this._maxCoolTime = 5000;\n        this._stuckTime = 0;\n        this.lastPosition = (0, $6f94c7a48e8964a6$exports.Vec2)(0, 0);\n        this.name = name || `M${order}`;\n        this.body = world.createBody({\n            type: \"dynamic\",\n            allowSleep: false,\n            awake: true,\n            active: false,\n            linearDamping: 0,\n            angularDamping: 0.01,\n            linearVelocity: new $6f94c7a48e8964a6$exports.Vec2(0, 0.0)\n        });\n        this.weight = weight;\n        this._maxCoolTime = 1000 + (1 - this.weight) * 4000;\n        this._coolTime = this._maxCoolTime * Math.random();\n        this._skillRate = 0.2 * this.weight;\n        const maxLine = Math.ceil(max / 10);\n        const line = Math.floor(order / 10);\n        const lineDelta = -Math.max(0, Math.ceil(maxLine - 5));\n        this.hue = 360 / max * order;\n        this.color = `hsl(${this.hue} 100% 70%)`;\n        const circle = $6f94c7a48e8964a6$exports.Circle(new $6f94c7a48e8964a6$exports.Vec2(0, 0), this.size / 2);\n        this.body.createFixture({\n            shape: circle,\n            density: Math.random() + 1,\n            restitution: 0.2\n        });\n        this.body.setPosition(new $6f94c7a48e8964a6$exports.Vec2(10.25 + order % 10 * 0.6, maxLine - line + lineDelta));\n        this.body.setUserData(this);\n    }\n    update(deltaTime) {\n        if (this.body.isActive() && this.lastPosition.sub(this.position).length() < 0.001) {\n            this._stuckTime += deltaTime;\n            if (this._stuckTime > (0, $1d1927fc5b91d8b6$export$2708cc8cc9b2d975)) this.body.applyForceToCenter((0, $6f94c7a48e8964a6$exports.Vec2)(Math.random() * 10 - 5, Math.random() * 10 - 5), true);\n        } else this._stuckTime = 0;\n        this.lastPosition = this.position.clone();\n        this.skill = (0, $1d1927fc5b91d8b6$export$bc572fe44976cfbc).None;\n        if (this.impact) this.impact = Math.max(0, this.impact - deltaTime);\n        if (!this.body.isActive()) return;\n        if ((0, $2573268c577c952d$export$2e2bcd8739ae039).useSkills) this._updateSkillInformation(deltaTime);\n    }\n    _updateSkillInformation(deltaTime) {\n        if (this._coolTime > 0) this._coolTime -= deltaTime;\n        if (this._coolTime <= 0) {\n            this.skill = Math.random() < this._skillRate ? (0, $1d1927fc5b91d8b6$export$bc572fe44976cfbc).Impact : (0, $1d1927fc5b91d8b6$export$bc572fe44976cfbc).None;\n            this._coolTime = this._maxCoolTime;\n        }\n    }\n    render(ctx, zoom, outline, isMinimap = false) {\n        ctx.save();\n        if (isMinimap) this._renderMinimap(ctx);\n        else this._renderNormal(ctx, zoom, outline);\n        ctx.restore();\n    }\n    _renderMinimap(ctx) {\n        ctx.fillStyle = this.color;\n        this._drawMarbleBody(ctx, true);\n    }\n    _drawMarbleBody(ctx, isMinimap) {\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, isMinimap ? this.size : this.size / 2, 0, Math.PI * 2);\n        ctx.fill();\n    }\n    _renderNormal(ctx, zoom, outline) {\n        ctx.shadowColor = this.color;\n        ctx.shadowBlur = zoom / 2;\n        ctx.fillStyle = `hsl(${this.hue} 100% ${70 + 25 * Math.min(1, this.impact / 500)}%`;\n        this._drawMarbleBody(ctx, false);\n        this._drawName(ctx, zoom);\n        if (outline) this._drawOutline(ctx, 2 / zoom);\n        if ((0, $2573268c577c952d$export$2e2bcd8739ae039).useSkills) this._renderCooltime(ctx, zoom);\n    }\n    _drawName(ctx, zoom) {\n        ctx.save();\n        ctx.translate(this.x, this.y + 0.25);\n        ctx.scale(1 / zoom, 1 / zoom);\n        ctx.font = `12pt sans-serif`;\n        ctx.strokeStyle = \"black\";\n        ctx.lineWidth = 2;\n        ctx.fillStyle = this.color;\n        ctx.shadowBlur = 0;\n        ctx.strokeText(this.name, 0, 0);\n        ctx.fillText(this.name, 0, 0);\n        ctx.restore();\n    }\n    _drawOutline(ctx, lineWidth) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.strokeStyle = \"white\";\n        ctx.lineWidth = lineWidth;\n        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.restore();\n    }\n    _renderCooltime(ctx, zoom) {\n        ctx.strokeStyle = \"red\";\n        ctx.lineWidth = 1 / zoom;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size / 2 + 2 / zoom, (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(270), (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(270 + 360 * this._coolTime / this._maxCoolTime));\n        ctx.stroke();\n    }\n}\n\n\n\n\n\nconst $2139b4f99d5088b5$var$lifetime = 3000;\nclass $2139b4f99d5088b5$export$c36c68baa13912a5 {\n    constructor(x, y){\n        this._elapsed = 0;\n        this.position = new $6f94c7a48e8964a6$exports.Vec2();\n        this.force = new $6f94c7a48e8964a6$exports.Vec2();\n        this.color = \"\";\n        this.isDestroy = false;\n        this.position = new $6f94c7a48e8964a6$exports.Vec2(x, y);\n        const force = Math.random() * 250;\n        const ang = (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(90 * Math.random() - 180);\n        const fx = Math.cos(ang) * force;\n        const fy = Math.sin(ang) * force;\n        this.color = `hsl(${Math.random() * 360} 50% 50%)`;\n        this.force.set(fx, fy);\n    }\n    update(deltaTime) {\n        this._elapsed += deltaTime;\n        const delta = this.force.clone().mul(deltaTime / 100);\n        this.position.add(delta);\n        this.force.y += 10 * deltaTime / 100;\n        if (this._elapsed > $2139b4f99d5088b5$var$lifetime) this.isDestroy = true;\n    }\n    render(ctx) {\n        ctx.save();\n        ctx.globalAlpha = 1 - Math.pow(this._elapsed / $2139b4f99d5088b5$var$lifetime, 2);\n        ctx.fillStyle = this.color;\n        ctx.fillRect(this.position.x, this.position.y, 20, 20);\n        ctx.restore();\n    }\n}\n\n\nclass $69fffa06e2cc8da9$export$6658904c50100579 {\n    update(deltaTime) {\n        this._particles.forEach((particle)=>{\n            particle.update(deltaTime);\n        });\n        this._particles = this._particles.filter((particle)=>!particle.isDestroy);\n    }\n    render(ctx) {\n        this._particles.forEach((particle)=>particle.render(ctx));\n    }\n    shot(x, y) {\n        for(let i = 0; i < 200; i++)this._particles.push(new (0, $2139b4f99d5088b5$export$c36c68baa13912a5)(x, y));\n    }\n    constructor(){\n        this._particles = [];\n    }\n}\n\n\n\nconst $b2abafc93d11a512$export$1bfcff8d7c4bf05 = [\n    {\n        title: \"Wheel of fortune\",\n        goalY: 111,\n        zoomY: 106.75,\n        walls: [\n            [\n                [\n                    16.5,\n                    -300\n                ],\n                [\n                    9.25,\n                    -300\n                ],\n                [\n                    9.25,\n                    8.5\n                ],\n                [\n                    2,\n                    19.25\n                ],\n                [\n                    2,\n                    26\n                ],\n                [\n                    9.75,\n                    30\n                ],\n                [\n                    9.75,\n                    33.5\n                ],\n                [\n                    1.25,\n                    41\n                ],\n                [\n                    1.25,\n                    53.75\n                ],\n                [\n                    8.25,\n                    58.75\n                ],\n                [\n                    8.25,\n                    63\n                ],\n                [\n                    9.25,\n                    64\n                ],\n                [\n                    8.25,\n                    65\n                ],\n                [\n                    8.25,\n                    99.25\n                ],\n                [\n                    15.1,\n                    106.75\n                ],\n                [\n                    15.1,\n                    111.75\n                ]\n            ],\n            [\n                [\n                    16.5,\n                    -300\n                ],\n                [\n                    16.5,\n                    9.25\n                ],\n                [\n                    9.5,\n                    20\n                ],\n                [\n                    9.5,\n                    22.5\n                ],\n                [\n                    17.5,\n                    26\n                ],\n                [\n                    17.5,\n                    33.5\n                ],\n                [\n                    24,\n                    38.5\n                ],\n                [\n                    19,\n                    45.5\n                ],\n                [\n                    19,\n                    55.5\n                ],\n                [\n                    24,\n                    59.25\n                ],\n                [\n                    24,\n                    63\n                ],\n                [\n                    23,\n                    64\n                ],\n                [\n                    24,\n                    65\n                ],\n                [\n                    24,\n                    100.5\n                ],\n                [\n                    16,\n                    106.75\n                ],\n                [\n                    16,\n                    111.75\n                ]\n            ],\n            [\n                [\n                    12.75,\n                    37.5\n                ],\n                [\n                    7,\n                    43.5\n                ],\n                [\n                    7,\n                    49.75\n                ],\n                [\n                    12.75,\n                    53.75\n                ],\n                [\n                    12.75,\n                    37.5\n                ]\n            ],\n            [\n                [\n                    14.75,\n                    37.5\n                ],\n                [\n                    14.75,\n                    43\n                ],\n                [\n                    17.5,\n                    40.25\n                ],\n                [\n                    14.75,\n                    37.5\n                ]\n            ]\n        ],\n        boxes: [\n            // x, y, angle, width, height\n            [\n                15.5,\n                30.0,\n                -45,\n                0.2,\n                0.2\n            ],\n            [\n                15.5,\n                32.0,\n                -45,\n                0.2,\n                0.2\n            ],\n            [\n                15.5,\n                28.0,\n                -45,\n                0.2,\n                0.2\n            ],\n            [\n                12.5,\n                30.0,\n                -45,\n                0.2,\n                0.2\n            ],\n            [\n                12.5,\n                32.0,\n                -45,\n                0.2,\n                0.2\n            ],\n            [\n                12.5,\n                28.0,\n                -45,\n                0.2,\n                0.2\n            ],\n            [\n                9.4,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                11.3,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                13.2,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                15.1,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                17,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                18.9,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                20.699999999999997,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                22.7,\n                66.6,\n                45,\n                0.6,\n                0.1\n            ],\n            [\n                9.4,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                11.3,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                13.2,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                15.1,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                17,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                18.9,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                20.699999999999997,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                22.7,\n                69.1,\n                -45,\n                0.6,\n                0.1\n            ],\n            [\n                9.5,\n                92,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                12.75,\n                92,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                16,\n                92,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                19.25,\n                92,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                22.5,\n                92,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                11,\n                95,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                14.25,\n                95,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                17.5,\n                95,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                20.75,\n                95,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                9.5,\n                98,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                12.75,\n                98,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                16,\n                98,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                19.25,\n                98,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ],\n            [\n                22.5,\n                98,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.25,\n                0.25\n            ]\n        ],\n        wheels: [\n            // x, y, power, centerx, centery\n            [\n                8,\n                75,\n                3.5\n            ],\n            [\n                12,\n                75,\n                -3.5\n            ],\n            [\n                16,\n                75,\n                3.5\n            ],\n            [\n                20,\n                75,\n                -3.5\n            ],\n            [\n                24,\n                75,\n                3.5\n            ],\n            [\n                14.0,\n                106.75,\n                -1.2\n            ]\n        ]\n    },\n    {\n        title: \"BubblePop\",\n        goalY: 83,\n        zoomY: 78,\n        walls: [\n            [\n                [\n                    16.5,\n                    -300\n                ],\n                [\n                    9.25,\n                    -300\n                ],\n                [\n                    9.25,\n                    0\n                ],\n                [\n                    9.25,\n                    43\n                ],\n                [\n                    4.25,\n                    50\n                ],\n                [\n                    9.25,\n                    53\n                ],\n                [\n                    9.25,\n                    75\n                ],\n                [\n                    12,\n                    80\n                ],\n                [\n                    12,\n                    83\n                ]\n            ],\n            [\n                [\n                    16.5,\n                    -300\n                ],\n                [\n                    16.5,\n                    50\n                ],\n                [\n                    19.5,\n                    54\n                ],\n                [\n                    18.5,\n                    56\n                ],\n                [\n                    19.5,\n                    58\n                ],\n                [\n                    16.5,\n                    61\n                ],\n                [\n                    16.5,\n                    75\n                ],\n                [\n                    13,\n                    80\n                ],\n                [\n                    13,\n                    83\n                ]\n            ],\n            [\n                [\n                    16.5,\n                    52.5\n                ],\n                [\n                    17.5,\n                    54\n                ],\n                [\n                    16.5,\n                    56\n                ],\n                [\n                    17.5,\n                    58\n                ],\n                [\n                    16.5,\n                    59\n                ],\n                [\n                    15.5,\n                    56\n                ],\n                [\n                    16.5,\n                    52.5\n                ]\n            ],\n            [\n                [\n                    9.25,\n                    45.5\n                ],\n                [\n                    6.25,\n                    49.5\n                ],\n                [\n                    9.25,\n                    51\n                ],\n                [\n                    14.5,\n                    50.5\n                ],\n                [\n                    9.25,\n                    45.5\n                ]\n            ],\n            [\n                [\n                    9.25,\n                    26\n                ],\n                [\n                    11.0625,\n                    27.5\n                ]\n            ],\n            [\n                [\n                    16.5,\n                    26\n                ],\n                [\n                    14.6875,\n                    27.5\n                ]\n            ],\n            [\n                [\n                    11.0625,\n                    30\n                ],\n                [\n                    12.875,\n                    28.5\n                ],\n                [\n                    14.6875,\n                    30\n                ]\n            ],\n            [\n                [\n                    9.25,\n                    31\n                ],\n                [\n                    11.0625,\n                    32.5\n                ]\n            ],\n            [\n                [\n                    16.5,\n                    31\n                ],\n                [\n                    14.6875,\n                    32.5\n                ]\n            ],\n            [\n                [\n                    11.0625,\n                    35\n                ],\n                [\n                    12.875,\n                    33.5\n                ],\n                [\n                    14.6875,\n                    35\n                ]\n            ]\n        ],\n        wheels: [\n            [\n                10.7,\n                10,\n                10,\n                0,\n                0,\n                0.5\n            ],\n            [\n                14.7,\n                10,\n                -10,\n                0,\n                0,\n                0.5\n            ],\n            [\n                12.7,\n                10,\n                10,\n                0,\n                0,\n                0.5\n            ],\n            [\n                10.7,\n                14,\n                -3\n            ],\n            [\n                14.7,\n                14,\n                3\n            ],\n            [\n                11.20,\n                44,\n                -5,\n                0,\n                0,\n                0.5\n            ],\n            [\n                10.3,\n                75,\n                8,\n                0,\n                0,\n                1\n            ],\n            [\n                15.2,\n                75,\n                -8,\n                0,\n                0,\n                1\n            ]\n        ],\n        boxes: [\n            // x, y, angle, width, height\n            [\n                9.25,\n                18,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                11.25,\n                18,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                13.25,\n                18,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                15.25,\n                18,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                10.5,\n                19,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                12.5,\n                19,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                14.5,\n                19,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                16.5,\n                19,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                9.25,\n                20,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                11.25,\n                20,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                13.25,\n                20,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                15.25,\n                20,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                10.5,\n                21,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                12.5,\n                21,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                14.5,\n                21,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                16.5,\n                21,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                9.25,\n                22,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                11.25,\n                22,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                13.25,\n                22,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                15.25,\n                22,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                10.5,\n                23,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                12.5,\n                23,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                14.5,\n                23,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                16.5,\n                23,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                0.15,\n                0.15\n            ],\n            [\n                9.4,\n                39,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                3,\n                3\n            ],\n            [\n                16.5,\n                43,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                3,\n                3\n            ]\n        ],\n        jumpers: [\n            [\n                11,\n                65,\n                0.5,\n                true\n            ],\n            [\n                13,\n                65,\n                0.5,\n                true\n            ],\n            [\n                15,\n                65,\n                0.5,\n                true\n            ],\n            [\n                12,\n                67.5,\n                0.5,\n                true\n            ],\n            [\n                14,\n                67.5,\n                0.5,\n                true\n            ],\n            [\n                13,\n                71,\n                0.8,\n                true\n            ],\n            [\n                10.7,\n                77.5,\n                0.8,\n                true\n            ],\n            [\n                14.7,\n                77.5,\n                0.8,\n                true\n            ],\n            [\n                12.625,\n                80,\n                1.5,\n                true\n            ],\n            [\n                12.625,\n                80,\n                1.2,\n                true\n            ]\n        ]\n    },\n    {\n        title: \"Pot of greed\",\n        goalY: 111,\n        zoomY: 110,\n        walls: [\n            [\n                [\n                    17,\n                    -300\n                ],\n                [\n                    9,\n                    -300\n                ],\n                [\n                    9,\n                    8.5\n                ],\n                [\n                    2,\n                    15\n                ],\n                [\n                    6,\n                    61.5\n                ]\n            ],\n            [\n                [\n                    7,\n                    71\n                ],\n                [\n                    9,\n                    101\n                ],\n                [\n                    8,\n                    100.5\n                ],\n                [\n                    6,\n                    100\n                ],\n                [\n                    5,\n                    90\n                ],\n                [\n                    4,\n                    70\n                ],\n                [\n                    7,\n                    71\n                ]\n            ],\n            [\n                [\n                    17,\n                    -300\n                ],\n                [\n                    17,\n                    8.5\n                ],\n                [\n                    24,\n                    15\n                ],\n                [\n                    20,\n                    61.5\n                ]\n            ],\n            [\n                [\n                    19,\n                    71\n                ],\n                [\n                    17,\n                    101\n                ],\n                [\n                    18,\n                    100.5\n                ],\n                [\n                    20,\n                    100\n                ],\n                [\n                    21,\n                    90\n                ],\n                [\n                    22,\n                    70\n                ],\n                [\n                    19,\n                    71\n                ]\n            ],\n            [\n                [\n                    11,\n                    88\n                ],\n                [\n                    12,\n                    90\n                ],\n                [\n                    12,\n                    112\n                ]\n            ],\n            [\n                [\n                    15,\n                    88\n                ],\n                [\n                    14,\n                    90\n                ],\n                [\n                    14,\n                    112\n                ]\n            ],\n            [\n                [\n                    12,\n                    102\n                ],\n                [\n                    11,\n                    103\n                ],\n                [\n                    9,\n                    104\n                ],\n                [\n                    8,\n                    104\n                ],\n                [\n                    6,\n                    103\n                ],\n                [\n                    5,\n                    102\n                ],\n                [\n                    4,\n                    100\n                ],\n                [\n                    3,\n                    90\n                ],\n                [\n                    2,\n                    70\n                ],\n                [\n                    3,\n                    65\n                ],\n                [\n                    4,\n                    63\n                ],\n                [\n                    5,\n                    62\n                ],\n                [\n                    6,\n                    61.5\n                ]\n            ],\n            [\n                [\n                    14,\n                    102\n                ],\n                [\n                    15,\n                    103\n                ],\n                [\n                    17,\n                    104\n                ],\n                [\n                    18,\n                    104\n                ],\n                [\n                    20,\n                    103\n                ],\n                [\n                    21,\n                    102\n                ],\n                [\n                    22,\n                    100\n                ],\n                [\n                    23,\n                    90\n                ],\n                [\n                    24,\n                    70\n                ],\n                [\n                    23,\n                    65\n                ],\n                [\n                    22,\n                    63\n                ],\n                [\n                    21,\n                    62\n                ],\n                [\n                    20,\n                    61.5\n                ]\n            ]\n        ],\n        boxes: [\n            // x, y, angle, width, height\n            [\n                13,\n                20,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                3,\n                3\n            ],\n            [\n                13,\n                55,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                3,\n                3\n            ],\n            [\n                8,\n                37,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                2,\n                2\n            ],\n            [\n                18,\n                37,\n                (0, $28770b279d7ab5b1$export$29e4e862bebba87f)(45),\n                2,\n                2\n            ]\n        ],\n        jumpers: [],\n        wheels: [\n            [\n                11,\n                12,\n                -3\n            ],\n            [\n                15,\n                12,\n                3\n            ],\n            [\n                8,\n                104,\n                -10,\n                0,\n                0,\n                1\n            ],\n            [\n                6,\n                103,\n                -10,\n                0,\n                0,\n                1.5\n            ],\n            [\n                4,\n                100,\n                -10,\n                0,\n                0,\n                1.5\n            ],\n            [\n                3.5,\n                95,\n                -10\n            ],\n            [\n                3,\n                90,\n                -10\n            ],\n            [\n                2.75,\n                85,\n                -10\n            ],\n            [\n                2.5,\n                80,\n                -10\n            ],\n            [\n                2.25,\n                75,\n                -10\n            ],\n            [\n                2,\n                70,\n                -10\n            ],\n            [\n                18,\n                104,\n                10,\n                0,\n                0,\n                1\n            ],\n            [\n                20,\n                103,\n                10,\n                0,\n                0,\n                1.5\n            ],\n            [\n                22,\n                100,\n                10,\n                0,\n                0,\n                1.5\n            ],\n            [\n                22.5,\n                95,\n                10\n            ],\n            [\n                23,\n                90,\n                10\n            ],\n            [\n                23.25,\n                85,\n                10\n            ],\n            [\n                23.5,\n                80,\n                10\n            ],\n            [\n                23.75,\n                75,\n                10\n            ],\n            [\n                24,\n                70,\n                10\n            ]\n        ]\n    }\n];\n\n\n\n\n\nclass $238457a12dbae9c5$export$79f141de891a5fed {\n    get zoom() {\n        return this._zoom;\n    }\n    set zoom(v) {\n        this._targetZoom = v;\n    }\n    get x() {\n        return this._position.x;\n    }\n    set x(v) {\n        this._targetPosition.x = v;\n    }\n    get y() {\n        return this._position.y;\n    }\n    set y(v) {\n        this._targetPosition.y = v;\n    }\n    get position() {\n        return this._position;\n    }\n    setPosition(v, force = false) {\n        if (force) return this._position.set(v);\n        return this._targetPosition.set(v);\n    }\n    lock(v) {\n        this._locked = v;\n    }\n    update({ marbles: marbles, stage: stage, needToZoom: needToZoom, targetIndex: targetIndex }) {\n        // set target position\n        if (!this._locked) this._calcTargetPositionAndZoom(marbles, stage, needToZoom, targetIndex);\n        // interpolate position\n        this._position.x = this._interpolation(this.x, this._targetPosition.x);\n        this._position.y = this._interpolation(this.y, this._targetPosition.y);\n        // interpolate zoom\n        this._zoom = this._interpolation(this._zoom, this._targetZoom);\n    }\n    _calcTargetPositionAndZoom(marbles, stage, needToZoom, targetIndex) {\n        if (marbles.length > 0) {\n            const targetMarble = marbles[targetIndex] ? marbles[targetIndex] : marbles[0];\n            this.setPosition(targetMarble.position);\n            if (needToZoom) {\n                const goalDist = Math.abs(stage.zoomY - this._position.y);\n                this.zoom = Math.max(1, (1 - goalDist / (0, $1d1927fc5b91d8b6$export$677ef9a3ce6796cf)) * 4);\n            } else this.zoom = 1;\n        } else {\n            this.setPosition(new (0, $6f94c7a48e8964a6$exports.Vec2)(0, 0));\n            this.zoom = 1;\n        }\n    }\n    _interpolation(current, target) {\n        const d = target - current;\n        if (Math.abs(d) < 1 / (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c)) return target;\n        return current + d / 10;\n    }\n    renderScene(ctx, callback) {\n        const zoomFactor = (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c) * 2 * this._zoom;\n        ctx.save();\n        ctx.translate(-this.x * this._zoom, -this.y * this._zoom);\n        ctx.scale(this.zoom, this.zoom);\n        ctx.translate(ctx.canvas.width / zoomFactor, ctx.canvas.height / zoomFactor);\n        callback(ctx);\n        ctx.restore();\n    }\n    constructor(){\n        this._position = new (0, $6f94c7a48e8964a6$exports.Vec2)();\n        this._targetPosition = new (0, $6f94c7a48e8964a6$exports.Vec2)();\n        this._zoom = 1;\n        this._targetZoom = 1;\n        this._locked = false;\n    }\n}\n\n\n\nclass $68facf3481e408fc$export$a1ed140729fa937 {\n    constructor(){\n        this.sizeFactor = 1;\n    }\n    get width() {\n        return this._canvas.width;\n    }\n    get height() {\n        return this._canvas.height;\n    }\n    get canvas() {\n        return this._canvas;\n    }\n    init() {\n        this._canvas = document.createElement(\"canvas\");\n        this._canvas.width = (0, $1d1927fc5b91d8b6$export$1cd840e6ecaab774);\n        this._canvas.height = (0, $1d1927fc5b91d8b6$export$3d795bc15e02aca);\n        this._ctx = this._canvas.getContext(\"2d\", {\n            alpha: false\n        });\n        document.body.appendChild(this._canvas);\n        const resizing = (entries)=>{\n            const realSize = entries ? entries[0].contentRect : this._canvas.getBoundingClientRect();\n            const width = Math.max(realSize.width / 2, 640);\n            const height = width / realSize.width * realSize.height;\n            this._canvas.width = width;\n            this._canvas.height = height;\n            this.sizeFactor = width / realSize.width;\n        };\n        const resizeObserver = new ResizeObserver(resizing);\n        resizeObserver.observe(this._canvas);\n        resizing();\n    }\n    render(renderParameters, uiObjects) {\n        this._ctx.fillStyle = \"black\";\n        this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n        this._ctx.save();\n        this._ctx.scale((0, $1d1927fc5b91d8b6$export$c2cc40734f29867c), (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c));\n        this._ctx.textAlign = \"left\";\n        this._ctx.textBaseline = \"top\";\n        this._ctx.font = \"0.4pt sans-serif\";\n        renderParameters.camera.renderScene(this._ctx, ()=>{\n            this._renderWalls({\n                ...renderParameters\n            });\n            this._renderObjects({\n                ...renderParameters\n            });\n            this._renderEffects(renderParameters);\n            this._renderMarbles(renderParameters);\n        });\n        this._ctx.restore();\n        uiObjects.forEach((obj)=>obj.render(this._ctx, renderParameters, this._canvas.width, this._canvas.height));\n        renderParameters.particleManager.render(this._ctx);\n        this._renderWinner(renderParameters);\n    }\n    _renderWalls({ stage: stage, camera: camera }) {\n        if (!stage) return;\n        this._ctx.save();\n        this._ctx.strokeStyle = \"white\";\n        this._ctx.lineWidth = 5 / (camera.zoom + (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c));\n        this._ctx.beginPath();\n        stage.walls.forEach((wallDef)=>{\n            this._ctx.moveTo(wallDef[0][0], wallDef[0][1]);\n            for(let i = 1; i < wallDef.length; i++)this._ctx.lineTo(wallDef[i][0], wallDef[i][1]);\n        });\n        this._ctx.shadowColor = \"cyan\";\n        this._ctx.shadowBlur = 15;\n        this._ctx.stroke();\n        this._ctx.closePath();\n        this._ctx.restore();\n    }\n    _renderObjects({ objects: objects, camera: camera }) {\n        this._ctx.save();\n        this._ctx.fillStyle = \"black\";\n        this._ctx.lineWidth = 3 / (camera.zoom + (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c));\n        objects.forEach((obj)=>{\n            this._ctx.save();\n            const pos = obj.getPosition();\n            const ang = obj.getAngle();\n            this._ctx.translate(pos.x, pos.y);\n            this._ctx.rotate(ang);\n            for(let fixture = obj.getFixtureList(); fixture; fixture = fixture.getNext()){\n                const shape = fixture.getShape();\n                this._ctx.beginPath();\n                switch(shape.getType()){\n                    case \"circle\":\n                        this._ctx.strokeStyle = \"yellow\";\n                        this._ctx.arc(0, 0, shape.m_radius, 0, Math.PI * 2);\n                        break;\n                    default:\n                        this._ctx.strokeStyle = \"#94d5ed\";\n                        const vertices = shape.m_vertices;\n                        this._ctx.moveTo(vertices[0].x, vertices[0].y);\n                        for(let i = 1; i < vertices.length; i++){\n                            const vert = vertices[i];\n                            this._ctx.lineTo(vert.x, vert.y);\n                        }\n                        this._ctx.closePath();\n                        break;\n                }\n                this._ctx.fill();\n                this._ctx.save();\n                this._ctx.shadowBlur = 15;\n                this._ctx.shadowColor = \"cyan\";\n                this._ctx.stroke();\n                this._ctx.restore();\n                this._ctx.closePath();\n            }\n            this._ctx.restore();\n        });\n        this._ctx.restore();\n    }\n    _renderEffects({ effects: effects, camera: camera }) {\n        effects.forEach((effect)=>effect.render(this._ctx, camera.zoom * (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c)));\n    }\n    _renderMarbles({ marbles: marbles, camera: camera, winnerRank: winnerRank, winners: winners }) {\n        const winnerIndex = winnerRank - winners.length;\n        marbles.forEach((marble, i)=>{\n            marble.render(this._ctx, camera.zoom * (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c), i === winnerIndex, false);\n        });\n    }\n    _renderWinner({ winner: winner }) {\n        if (!winner) return;\n        this._ctx.save();\n        this._ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n        this._ctx.fillRect(this._canvas.width / 2, this._canvas.height - 168, this._canvas.width / 2, 168);\n        this._ctx.fillStyle = \"white\";\n        this._ctx.font = \"bold 48px sans-serif\";\n        this._ctx.textAlign = \"right\";\n        this._ctx.fillText(\"Winner\", this._canvas.width - 10, this._canvas.height - 120);\n        this._ctx.font = \"bold 72px sans-serif\";\n        this._ctx.fillStyle = winner.color;\n        this._ctx.fillText(winner.name, this._canvas.width - 10, this._canvas.height - 55);\n        this._ctx.restore();\n    }\n}\n\n\n\nconst $43c01f2b0f9df660$var$lifetime = 500;\nclass $43c01f2b0f9df660$export$2faf2590ac4901e1 {\n    constructor(x, y){\n        this._size = 0;\n        this._elapsed = 0;\n        this.isDestroy = false;\n        this.position = new $6f94c7a48e8964a6$exports.Vec2(x, y);\n    }\n    update(deltaTime) {\n        this._elapsed += deltaTime;\n        this._size = this._elapsed / $43c01f2b0f9df660$var$lifetime * 10;\n        if (this._elapsed > $43c01f2b0f9df660$var$lifetime) this.isDestroy = true;\n    }\n    render(ctx, zoom) {\n        ctx.save();\n        const rate = this._elapsed / $43c01f2b0f9df660$var$lifetime;\n        ctx.globalAlpha = 1 - rate * rate;\n        ctx.strokeStyle = \"white\";\n        ctx.lineWidth = 1 / zoom;\n        ctx.beginPath();\n        ctx.arc(this.position.x, this.position.y, this._size, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.restore();\n    }\n}\n\n\n\nfunction $5d9d2ddcc4e90c63$export$adf7c0fe6059d774(target, propertyKey, descriptor) {\n    return {\n        configurable: true,\n        get () {\n            const boundMethod = descriptor.value.bind(this);\n            Object.defineProperty(this, propertyKey, {\n                value: boundMethod,\n                configurable: true,\n                writable: true\n            });\n            return boundMethod;\n        }\n    };\n}\n\n\n\n\nclass $e0350dec16bbe919$export$795f70ffe4ca76fc {\n    constructor(){\n        this._currentY = 0;\n        this._targetY = 0;\n        this.fontHeight = 16;\n        this._userMoved = 0;\n        this._currentWinner = -1;\n        this.maxY = 0;\n    }\n    onWheel(e) {\n        this._targetY += e.deltaY;\n        if (this._targetY > this.maxY) this._targetY = this.maxY;\n        this._userMoved = 2000;\n    }\n    render(ctx, { winners: winners, marbles: marbles, winnerRank: winnerRank }, width, height) {\n        const startX = width - 5;\n        const startY = Math.max(0, this._currentY - height / 2);\n        this.maxY = Math.max(0, (marbles.length + winners.length) * this.fontHeight);\n        this._currentWinner = winners.length;\n        ctx.save();\n        ctx.translate(0, -startY);\n        ctx.font = \"bold 11pt sans-serif\";\n        ctx.textAlign = \"right\";\n        winners.forEach((marble, rank)=>{\n            const y = rank * this.fontHeight;\n            if (y >= startY) {\n                ctx.fillStyle = marble.color;\n                ctx.fillText(`${rank === winnerRank ? \"\\u2606\" : \"\\u2714\"} ${marble.name} #${rank + 1}`, startX, 20 + y);\n            }\n        });\n        ctx.font = \"10pt sans-serif\";\n        marbles.forEach((marble, rank)=>{\n            ctx.fillStyle = marble.color;\n            const y = (rank + winners.length) * this.fontHeight;\n            ctx.fillText(`${marble.name} #${rank + 1 + winners.length}`, startX, 20 + y);\n        });\n        ctx.restore();\n    }\n    update(deltaTime) {\n        if (this._currentWinner === -1) return;\n        if (this._userMoved > 0) this._userMoved -= deltaTime;\n        else this._targetY = this._currentWinner * this.fontHeight;\n        if (this._currentY !== this._targetY) this._currentY += (this._targetY - this._currentY) * (deltaTime / 250);\n        if (Math.abs(this._currentY - this._targetY) < 1) this._currentY = this._targetY;\n    }\n    getBoundingBox() {\n        return null;\n    }\n}\n(0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $5d9d2ddcc4e90c63$export$adf7c0fe6059d774)\n], $e0350dec16bbe919$export$795f70ffe4ca76fc.prototype, \"onWheel\", null);\n\n\n\n\n\n\nclass $c2ea39beabe51779$export$a8b4308ba35ee473 {\n    constructor(){\n        this.lastParams = null;\n        this._onViewportChangeHandler = null;\n        this.mousePosition = null;\n        this.boundingBox = {\n            x: 10,\n            y: 10,\n            w: 104,\n            h: 0\n        };\n    }\n    getBoundingBox() {\n        return this.boundingBox;\n    }\n    onViewportChange(callback) {\n        this._onViewportChangeHandler = callback;\n    }\n    update(deltaTime) {\n    // nothing to do\n    }\n    onMouseMove(e) {\n        if (!e) {\n            this.mousePosition = null;\n            if (this._onViewportChangeHandler) this._onViewportChangeHandler();\n            return;\n        }\n        if (!this.lastParams) return;\n        this.mousePosition = {\n            x: e.x,\n            y: e.y\n        };\n        if (this._onViewportChangeHandler) this._onViewportChangeHandler(new (0, $6f94c7a48e8964a6$exports.Vec2)(this.mousePosition.x / 4, this.mousePosition.y / 4));\n    }\n    render(ctx, params) {\n        if (!ctx) return;\n        const { stage: stage } = params;\n        if (!stage) return;\n        this.boundingBox.h = stage.goalY * 4;\n        this.lastParams = params;\n        this.ctx = ctx;\n        ctx.save();\n        ctx.fillStyle = \"#333\";\n        ctx.translate(10, 10);\n        ctx.scale(4, 4);\n        ctx.fillRect(0, 0, 26, stage.goalY);\n        this.drawWalls(params);\n        this.drawObjects(params);\n        this.drawMarbles(params);\n        this.drawViewport(params);\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = \"green\";\n        ctx.lineWidth = 1;\n        ctx.strokeRect(this.boundingBox.x, this.boundingBox.y, this.boundingBox.w, this.boundingBox.h);\n        ctx.restore();\n    }\n    drawViewport(params) {\n        this.ctx.save();\n        const { camera: camera, size: size } = params;\n        const zoom = camera.zoom * (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c);\n        const w = size.x / zoom;\n        const h = size.y / zoom;\n        this.ctx.strokeStyle = \"white\";\n        this.ctx.lineWidth = 1 / zoom;\n        this.ctx.strokeRect(camera.x - w / 2, camera.y - h / 2, w, h);\n        this.ctx.restore();\n    }\n    drawWalls(params) {\n        if (!params.stage) return;\n        this.ctx.save();\n        this.ctx.strokeStyle = \"black\";\n        this.ctx.lineWidth = 0.5;\n        this.ctx.beginPath();\n        params.stage.walls.forEach((wallDef)=>{\n            this.ctx.moveTo(wallDef[0][0], wallDef[0][1]);\n            for(let i = 1; i < wallDef.length; i++)this.ctx.lineTo(wallDef[i][0], wallDef[i][1]);\n        });\n        this.ctx.stroke();\n        this.ctx.closePath();\n        this.ctx.restore();\n    }\n    drawObjects(params) {\n        const { objects: objects } = params;\n        if (!objects) return;\n        this.ctx.save();\n        this.ctx.fillStyle = \"black\";\n        this.ctx.lineWidth = 1;\n        objects.forEach((obj)=>{\n            this.ctx.save();\n            const pos = obj.getPosition();\n            const ang = obj.getAngle();\n            this.ctx.translate(pos.x, pos.y);\n            this.ctx.rotate(ang);\n            for(let fixture = obj.getFixtureList(); fixture; fixture = fixture.getNext()){\n                const shape = fixture.getShape();\n                this.ctx.beginPath();\n                if (shape.getType() === \"circle\") {\n                    this.ctx.strokeStyle = \"yellow\";\n                    this.ctx.arc(0, 0, shape.m_radius, 0, Math.PI * 2);\n                } else {\n                    this.ctx.strokeStyle = \"#94d5ed\";\n                    const vertices = shape.m_vertices;\n                    this.ctx.moveTo(vertices[0].x, vertices[0].y);\n                    for(let i = 1; i < vertices.length; i++){\n                        const vertex = vertices[i];\n                        this.ctx.lineTo(vertex.x, vertex.y);\n                    }\n                    this.ctx.closePath();\n                }\n                this.ctx.fill();\n                this.ctx.closePath();\n            }\n            this.ctx.restore();\n        });\n        this.ctx.restore();\n    }\n    drawMarbles(params) {\n        const { marbles: marbles } = params;\n        marbles.forEach((marble)=>{\n            marble.render(this.ctx, 1, false, true);\n        });\n    }\n}\n(0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $5d9d2ddcc4e90c63$export$adf7c0fe6059d774)\n], $c2ea39beabe51779$export$a8b4308ba35ee473.prototype, \"onMouseMove\", null);\n\n\n\nclass $ba1c8fec6a2b59e4$export$ec9e02cabe22c790 {\n    constructor(canvas){\n        this.chunks = [];\n        this.stopping = false;\n        this.targetCanvas = canvas;\n        this.videoStream = this.targetCanvas.captureStream();\n        this.mediaRecorder = new MediaRecorder(this.videoStream, {\n            videoBitsPerSecond: 6000000\n        });\n    }\n    async start() {\n        this.stopping = false;\n        return new Promise((rs)=>{\n            this.chunks = [];\n            this.mediaRecorder.ondataavailable = (e)=>{\n                this.chunks.push(e.data);\n            };\n            this.mediaRecorder.onstop = ()=>{\n                const blob = new Blob(this.chunks, {\n                    \"type\": \"video/webm\"\n                });\n                const videoUrl = URL.createObjectURL(blob);\n                const downloadLink = document.createElement(\"a\");\n                const d = new Date();\n                downloadLink.href = videoUrl;\n                downloadLink.download = `marble_roulette_${d.getFullYear()}${(0, $28770b279d7ab5b1$export$5d04458e2a6c373e)(d.getMonth() + 1)}${(0, $28770b279d7ab5b1$export$5d04458e2a6c373e)(d.getDate())}${(0, $28770b279d7ab5b1$export$5d04458e2a6c373e)(d.getHours())}${(0, $28770b279d7ab5b1$export$5d04458e2a6c373e)(d.getMinutes())}${(0, $28770b279d7ab5b1$export$5d04458e2a6c373e)(d.getSeconds())}.webm`;\n                downloadLink.click();\n                downloadLink.remove();\n                URL.revokeObjectURL(videoUrl);\n            };\n            this.mediaRecorder.onstart = ()=>{\n                rs();\n            };\n            this.mediaRecorder.start();\n        });\n    }\n    stop() {\n        this.stopping = true;\n        if (this.mediaRecorder.state === \"recording\") this.mediaRecorder.stop();\n    }\n}\n\n\nclass $7c756c59aac10daa$export$4929751e8471403 extends EventTarget {\n    constructor(){\n        super();\n        this._marbles = [];\n        this._lastTime = 0;\n        this._elapsed = 0;\n        this._noMoveDuration = 0;\n        this._shakeAvailable = false;\n        this._updateInterval = 10;\n        this._timeScale = 1;\n        this._speed = 1;\n        this._winners = [];\n        this._objects = [];\n        this._stageObjects = [];\n        this._particleManager = new (0, $69fffa06e2cc8da9$export$6658904c50100579)();\n        this._stage = null;\n        this._camera = new (0, $238457a12dbae9c5$export$79f141de891a5fed)();\n        this._renderer = new (0, $68facf3481e408fc$export$a1ed140729fa937)();\n        this._effects = [];\n        this._winnerRank = 0;\n        this._totalMarbleCount = 0;\n        this._goalDist = Infinity;\n        this._isRunning = false;\n        this._winner = null;\n        this._uiObjects = [];\n        this._autoRecording = false;\n        this._renderer.init();\n        this._init();\n        this._update();\n    }\n    getZoom() {\n        return (0, $1d1927fc5b91d8b6$export$c2cc40734f29867c) * this._camera.zoom;\n    }\n    addUiObject(obj) {\n        this._uiObjects.push(obj);\n        if (obj.onWheel) this._renderer.canvas.addEventListener(\"wheel\", obj.onWheel);\n    }\n    _update() {\n        if (!this._lastTime) this._lastTime = Date.now();\n        const currentTime = Date.now();\n        this._elapsed += (currentTime - this._lastTime) * this._speed;\n        if (this._elapsed > 100) this._elapsed %= 100;\n        this._lastTime = currentTime;\n        const interval = this._updateInterval / 1000 * this._timeScale;\n        while(this._elapsed >= this._updateInterval){\n            this._world.step(interval);\n            this._updateMarbles(this._updateInterval);\n            this._particleManager.update(this._updateInterval);\n            this._updateEffects(this._updateInterval);\n            this._elapsed -= this._updateInterval;\n            this._uiObjects.forEach((obj)=>obj.update(this._updateInterval));\n        }\n        if (this._marbles.length > 1) this._marbles.sort((a, b)=>b.y - a.y);\n        if (this._stage) {\n            this._camera.update({\n                marbles: this._marbles,\n                stage: this._stage,\n                needToZoom: this._goalDist < (0, $1d1927fc5b91d8b6$export$677ef9a3ce6796cf),\n                targetIndex: this._winners.length > 0 ? this._winnerRank - this._winners.length : 0\n            });\n            if (this._isRunning && this._marbles.length > 0 && this._noMoveDuration > 3000) this._changeShakeAvailable(true);\n            else this._changeShakeAvailable(false);\n        }\n        this._render();\n        window.requestAnimationFrame(this._update);\n    }\n    _updateMarbles(deltaTime) {\n        if (!this._stage) return;\n        for(let contact = this._world.getContactList(); contact; contact = contact.getNext()){\n            if (!contact.isTouching()) continue;\n            let fixtures = [\n                contact.getFixtureA(),\n                contact.getFixtureB()\n            ];\n            fixtures.forEach((fixture)=>{\n                const body = fixture.getBody();\n                const userData = body.getUserData();\n                if (userData) {\n                    if (userData instanceof (0, $e7b6517817360fee$export$e91dba6fa3f67f68)) {\n                        userData.impact += 200;\n                        if (userData.impact > 500) userData.impact = 500;\n                    } else if (\"isTemporary\" in userData && userData.isTemporary) {\n                        this._world.destroyBody(body);\n                        this._objects = this._objects.filter((obj)=>obj !== body);\n                    }\n                }\n            });\n        }\n        for(let i = 0; i < this._marbles.length; i++){\n            const marble = this._marbles[i];\n            marble.update(deltaTime);\n            if (marble.skill === (0, $1d1927fc5b91d8b6$export$bc572fe44976cfbc).Impact) {\n                this._effects.push(new (0, $43c01f2b0f9df660$export$2faf2590ac4901e1)(marble.x, marble.y));\n                this._marbles.filter((target)=>target !== marble && target.position.clone().sub(marble.position).lengthSquared() < 100).forEach((target)=>{\n                    const v = target.position.clone().sub(marble.position);\n                    const norm = v.clone();\n                    norm.normalize();\n                    const power = 1 - v.length() / 10;\n                    norm.mul(power * power * 5);\n                    target.body.applyLinearImpulse(norm, marble.position);\n                });\n            }\n            if (marble.y > this._stage.goalY) {\n                this._winners.push(marble);\n                if (this._isRunning && this._winners.length === this._winnerRank + 1) {\n                    this.dispatchEvent(new CustomEvent(\"goal\", {\n                        detail: {\n                            winner: marble.name\n                        }\n                    }));\n                    this._winner = marble;\n                    this._isRunning = false;\n                    this._particleManager.shot(this._renderer.width, this._renderer.height);\n                    setTimeout(()=>{\n                        this._recorder.stop();\n                    }, 1000);\n                } else if (this._isRunning && this._winnerRank === this._winners.length && this._winnerRank === this._totalMarbleCount - 1) {\n                    this.dispatchEvent(new CustomEvent(\"goal\", {\n                        detail: {\n                            winner: this._marbles[i + 1].name\n                        }\n                    }));\n                    this._winner = this._marbles[i + 1];\n                    this._isRunning = false;\n                    this._particleManager.shot(this._renderer.width, this._renderer.height);\n                    setTimeout(()=>{\n                        this._recorder.stop();\n                    }, 1000);\n                }\n                setTimeout(()=>{\n                    this._world.destroyBody(marble.body);\n                }, 500);\n            }\n        }\n        const targetIndex = this._winnerRank - this._winners.length;\n        const topY = this._marbles[targetIndex] ? this._marbles[targetIndex].y : 0;\n        this._goalDist = Math.abs(this._stage.zoomY - topY);\n        this._timeScale = this._calcTimeScale();\n        this._marbles = this._marbles.filter((marble)=>marble.y <= this._stage.goalY);\n        const maximumForce = this._marbles.reduce((p, c)=>Math.max(p, c.body.getLinearVelocity().length()), 0);\n        if (maximumForce < 0.1) this._noMoveDuration += deltaTime;\n        else this._noMoveDuration = 0;\n    }\n    _calcTimeScale() {\n        if (!this._stage) return 1;\n        const targetIndex = this._winnerRank - this._winners.length;\n        if (this._winners.length < this._winnerRank + 1 && this._goalDist < (0, $1d1927fc5b91d8b6$export$677ef9a3ce6796cf)) {\n            if (this._marbles[targetIndex].y > this._stage.zoomY - (0, $1d1927fc5b91d8b6$export$677ef9a3ce6796cf) * 1.2 && (this._marbles[targetIndex - 1] || this._marbles[targetIndex + 1])) return Math.max(0.2, this._goalDist / (0, $1d1927fc5b91d8b6$export$677ef9a3ce6796cf));\n        }\n        return 1;\n    }\n    _updateEffects(deltaTime) {\n        this._effects.forEach((effect)=>effect.update(deltaTime));\n        this._effects = this._effects.filter((effect)=>!effect.isDestroy);\n    }\n    _render() {\n        if (!this._stage) return;\n        const renderParams = {\n            camera: this._camera,\n            stage: this._stage,\n            objects: this._objects,\n            marbles: this._marbles,\n            winners: this._winners,\n            particleManager: this._particleManager,\n            effects: this._effects,\n            winnerRank: this._winnerRank,\n            winner: this._winner,\n            size: (0, $6f94c7a48e8964a6$exports.Vec2)(this._renderer.width, this._renderer.height)\n        };\n        this._renderer.render(renderParams, this._uiObjects);\n    }\n    _init() {\n        this._recorder = new (0, $ba1c8fec6a2b59e4$export$ec9e02cabe22c790)(this._renderer.canvas);\n        this._world = new $6f94c7a48e8964a6$exports.World({\n            gravity: new $6f94c7a48e8964a6$exports.Vec2(0, 10)\n        });\n        this.addUiObject(new (0, $e0350dec16bbe919$export$795f70ffe4ca76fc)());\n        this.attachEvent();\n        const minimap = new (0, $c2ea39beabe51779$export$a8b4308ba35ee473)();\n        minimap.onViewportChange((pos)=>{\n            if (pos) {\n                this._camera.setPosition(pos, false);\n                this._camera.lock(true);\n            } else this._camera.lock(false);\n        });\n        this.addUiObject(minimap);\n        this._stage = (0, $b2abafc93d11a512$export$1bfcff8d7c4bf05)[0];\n        this._loadMap();\n    }\n    attachEvent() {\n        this._renderer.canvas.addEventListener(\"mousemove\", (e)=>{\n            const sizeFactor = this._renderer.sizeFactor;\n            const pos = {\n                x: e.offsetX * sizeFactor,\n                y: e.offsetY * sizeFactor\n            };\n            this._uiObjects.forEach((obj)=>{\n                if (!obj.onMouseMove) return;\n                const bounds = obj.getBoundingBox();\n                if (!bounds) obj.onMouseMove({\n                    ...pos\n                });\n                else if (bounds && pos.x >= bounds.x && pos.y >= bounds.y && pos.x <= bounds.x + bounds.w && pos.y <= bounds.y + bounds.h) obj.onMouseMove({\n                    x: pos.x - bounds.x,\n                    y: pos.y - bounds.y\n                });\n                else obj.onMouseMove(undefined);\n            });\n        });\n    }\n    _loadMap() {\n        if (!this._stage) throw new Error(\"No map has been selected\");\n        this._stageObjects = [];\n        const { walls: walls, boxes: boxes, wheels: wheels, jumpers: jumpers } = this._stage;\n        walls.forEach((wallDef)=>{\n            const wall = this._world.createBody({\n                type: \"static\"\n            });\n            wall.setPosition(new $6f94c7a48e8964a6$exports.Vec2(0, 0));\n            wall.createFixture({\n                shape: $6f94c7a48e8964a6$exports.Chain(wallDef.map((pos)=>new $6f94c7a48e8964a6$exports.Vec2(...pos)), false)\n            });\n            this._stageObjects.push(wall);\n        });\n        wheels.forEach((wheelDef)=>{\n            const item = (0, $28770b279d7ab5b1$export$e774a455380e7b24)(this._world, new $6f94c7a48e8964a6$exports.Vec2(wheelDef[0], wheelDef[1]), wheelDef[2], wheelDef[3] !== undefined && wheelDef[4] !== undefined ? new $6f94c7a48e8964a6$exports.Vec2(wheelDef[3], wheelDef[4]) : undefined, wheelDef[5] ?? undefined);\n            this._objects.push(item);\n            this._stageObjects.push(item);\n        });\n        boxes.forEach((boxDef)=>{\n            const item = (0, $28770b279d7ab5b1$export$6459fc9e86be362e)(this._world, new $6f94c7a48e8964a6$exports.Vec2(boxDef[0], boxDef[1]), boxDef[2], boxDef[3], boxDef[4]);\n            this._objects.push(item);\n            this._stageObjects.push(item);\n        });\n        if (jumpers) jumpers.forEach((jumperDef)=>{\n            const item = (0, $28770b279d7ab5b1$export$9ea1ce01850d7d98)(this._world, new $6f94c7a48e8964a6$exports.Vec2(jumperDef[0], jumperDef[1]), jumperDef[2], jumperDef[3]);\n            this._objects.push(item);\n            this._stageObjects.push(item);\n        });\n    }\n    clearMarbles() {\n        this._marbles.forEach((marble)=>{\n            this._world.destroyBody(marble.body);\n        });\n        this._winner = null;\n        this._winners = [];\n        this._marbles = [];\n    }\n    start() {\n        this._isRunning = true;\n        this._winnerRank = (0, $2573268c577c952d$export$2e2bcd8739ae039).winningRank;\n        if (this._winnerRank >= this._marbles.length) this._winnerRank = this._marbles.length - 1;\n        if (this._autoRecording) this._recorder.start().then(()=>{\n            this._marbles.forEach((marble)=>marble.body.setActive(true));\n        });\n        else this._marbles.forEach((marble)=>marble.body.setActive(true));\n    }\n    setSpeed(value) {\n        if (value <= 0) throw new Error(\"Speed multiplier must larger than 0\");\n        this._speed = value;\n    }\n    getSpeed() {\n        return this._speed;\n    }\n    setWinningRank(rank) {\n        this._winnerRank = rank;\n    }\n    setAutoRecording(value) {\n        this._autoRecording = value;\n    }\n    setMarbles(names) {\n        this.reset();\n        const arr = names.slice();\n        let maxWeight = -Infinity;\n        let minWeight = Infinity;\n        const members = arr.map((nameString)=>{\n            const result = (0, $28770b279d7ab5b1$export$5d945868514965a9)(nameString);\n            if (!result) return null;\n            const { name: name, weight: weight, count: count } = result;\n            if (weight > maxWeight) maxWeight = weight;\n            if (weight < minWeight) minWeight = weight;\n            return {\n                name: name,\n                weight: weight,\n                count: count\n            };\n        }).filter((member)=>!!member);\n        const gap = maxWeight - minWeight;\n        let totalCount = 0;\n        members.forEach((member)=>{\n            if (member) {\n                member.weight = 0.1 + (gap ? (member.weight - minWeight) / gap : 0);\n                totalCount += member.count;\n            }\n        });\n        const orders = Array(totalCount).fill(0).map((_, i)=>i).sort(()=>Math.random() - 0.5);\n        members.forEach((member)=>{\n            if (member) for(let j = 0; j < member.count; j++){\n                const order = orders.pop() || 0;\n                this._marbles.push(new (0, $e7b6517817360fee$export$e91dba6fa3f67f68)(this._world, order, totalCount, member.name, member.weight));\n            }\n        });\n        this._totalMarbleCount = totalCount;\n    }\n    _clearMap() {\n        for(let body = this._world.getBodyList(); body; body = body.getNext())this._world.destroyBody(body);\n        this._objects = [];\n        this._marbles = [];\n    }\n    reset() {\n        this.clearMarbles();\n        this._clearMap();\n        this._loadMap();\n        this._goalDist = Infinity;\n    }\n    getCount() {\n        return this._marbles.length;\n    }\n    _changeShakeAvailable(v) {\n        if (this._shakeAvailable !== v) {\n            this._shakeAvailable = v;\n            this.dispatchEvent(new CustomEvent(\"shakeAvailableChanged\", {\n                detail: v\n            }));\n        }\n    }\n    shake() {\n        if (!this._shakeAvailable) return;\n        const xPower = (Math.random() - 0.5) * 4;\n        const yPower = (Math.random() - 0.5) * 4;\n        const power = new (0, $6f94c7a48e8964a6$exports.Vec2)(xPower, yPower);\n        this._stageObjects.forEach((obj)=>{\n            let contact = obj.getContactList();\n            while(contact){\n                if (contact.other) contact.other.applyLinearImpulse(power, contact.other.getPosition());\n                contact = contact.next || null;\n            }\n        });\n        this._camera.setPosition(this._camera.position.add(power));\n    }\n    getMaps() {\n        return (0, $b2abafc93d11a512$export$1bfcff8d7c4bf05).map((stage, index)=>{\n            return {\n                index: index,\n                title: stage.title\n            };\n        });\n    }\n    setMap(index) {\n        if (index < 0 || index > (0, $b2abafc93d11a512$export$1bfcff8d7c4bf05).length - 1) throw new Error(\"Incorrect map number\");\n        const names = this._marbles.map((marble)=>marble.name);\n        this._stage = (0, $b2abafc93d11a512$export$1bfcff8d7c4bf05)[index];\n        this.setMarbles(names);\n    }\n}\n(0, $5c96a02c592fcff1$export$29e00dfd3077644b)([\n    (0, $5d9d2ddcc4e90c63$export$adf7c0fe6059d774)\n], $7c756c59aac10daa$export$4929751e8471403.prototype, \"_update\", null);\n\n\n\nconst $b4e14b6b8da86996$var$roulette = new (0, $7c756c59aac10daa$export$4929751e8471403)();\nwindow.roullete = $b4e14b6b8da86996$var$roulette;\nwindow.options = (0, $2573268c577c952d$export$2e2bcd8739ae039);\n\n\n//# sourceMappingURL=index.8efdd510.js.map\n","import {Roulette} from './roulette';\nimport options from './options';\n\nconst roulette = new Roulette();\n(window as any).roullete = roulette;\n(window as any).options = options;\n","import * as planck from 'planck';\nimport {Marble} from './marble';\nimport {initialZoom, Skills, zoomThreshold} from './data/constants';\nimport {ParticleManager} from './particleManager';\nimport {StageDef, stages} from './data/maps';\nimport { createBox, createJumper, createMover, parseName } from './utils/utils';\nimport {Camera} from './camera';\nimport {RouletteRenderer} from './rouletteRenderer';\nimport {SkillEffect} from './skillEffect';\nimport {GameObject} from './gameObject';\nimport options from './options';\nimport { bound } from './utils/bound.decorator';\nimport {Vec2} from 'planck';\nimport { UIObject } from './UIObject';\nimport { RankRenderer } from './rankRenderer';\nimport {Minimap} from './minimap';\nimport {VideoRecorder} from './utils/videoRecorder';\n\nexport class Roulette extends EventTarget {\n    private _world!: planck.World;\n    private _marbles: Marble[] = [];\n\n    private _lastTime: number = 0;\n    private _elapsed: number = 0;\n    private _noMoveDuration: number = 0;\n    private _shakeAvailable: boolean = false;\n\n    private _updateInterval = 10;\n    private _timeScale = 1;\n    private _speed = 1;\n\n    private _winners: Marble[] = [];\n    private _objects: planck.Body[] = [];\n    private _stageObjects: planck.Body[] = [];\n    private _particleManager = new ParticleManager();\n    private _stage: StageDef | null = null;\n\n    private _camera: Camera = new Camera();\n    private _renderer: RouletteRenderer = new RouletteRenderer();\n\n    private _effects: GameObject[] = [];\n\n    private _winnerRank = 0;\n    private _totalMarbleCount = 0;\n    private _goalDist: number = Infinity;\n    private _isRunning: boolean = false;\n    private _winner: Marble | null = null;\n\n    private _uiObjects: UIObject[] = [];\n\n    private _autoRecording: boolean = false;\n    private _recorder!: VideoRecorder;\n\n    constructor() {\n        super();\n        this._renderer.init();\n        this._init();\n        this._update();\n    }\n\n    public getZoom() {\n        return initialZoom * this._camera.zoom;\n    }\n\n    private addUiObject(obj: UIObject) {\n        this._uiObjects.push(obj);\n        if (obj.onWheel) {\n            this._renderer.canvas.addEventListener('wheel', obj.onWheel);\n        }\n    }\n\n    @bound\n    private _update() {\n        if (!this._lastTime) this._lastTime = Date.now();\n        const currentTime = Date.now();\n\n        this._elapsed += (currentTime - this._lastTime) * this._speed;\n        if (this._elapsed > 100) {\n            this._elapsed %= 100;\n        }\n        this._lastTime = currentTime;\n\n        const interval = this._updateInterval / 1000 * this._timeScale;\n\n        while (this._elapsed >= this._updateInterval) {\n            this._world.step(interval);\n            this._updateMarbles(this._updateInterval);\n            this._particleManager.update(this._updateInterval);\n            this._updateEffects(this._updateInterval);\n            this._elapsed -= this._updateInterval;\n            this._uiObjects.forEach(obj => obj.update(this._updateInterval));\n        }\n\n        if (this._marbles.length > 1) {\n            this._marbles.sort((a, b) => b.y - a.y);\n        }\n\n\n        if (this._stage) {\n            this._camera.update({\n                marbles: this._marbles,\n                stage: this._stage,\n                needToZoom: this._goalDist < zoomThreshold,\n                targetIndex: this._winners.length > 0 ? this._winnerRank - this._winners.length : 0,\n            });\n\n            if (this._isRunning && this._marbles.length > 0 && this._noMoveDuration > 3000) {\n                this._changeShakeAvailable(true);\n            } else {\n                this._changeShakeAvailable(false);\n            }\n        }\n\n        this._render();\n        window.requestAnimationFrame(this._update);\n    }\n\n    private _updateMarbles(deltaTime: number) {\n        if (!this._stage) return;\n\n        for (let contact = this._world.getContactList(); contact; contact = contact.getNext()) {\n            if (!contact.isTouching()) continue;\n            let fixtures = [contact.getFixtureA(), contact.getFixtureB()];\n            fixtures.forEach(fixture => {\n                const body = fixture.getBody();\n                const userData = body.getUserData() as any;\n                if (userData) {\n                    if (userData instanceof Marble) {\n                        userData.impact += 200;\n                        if (userData.impact > 500) userData.impact = 500;\n                    } else if ('isTemporary' in userData && userData.isTemporary) {\n                        this._world.destroyBody(body);\n                        this._objects = this._objects.filter(obj => obj !== body);\n                    }\n                }\n            });\n        }\n\n        for (let i = 0; i < this._marbles.length; i++) {\n            const marble = this._marbles[i];\n            marble.update(deltaTime);\n            if (marble.skill === Skills.Impact) {\n                this._effects.push(new SkillEffect(marble.x, marble.y));\n                this._marbles\n                    .filter(target => target !== marble && target.position.clone().sub(marble.position).lengthSquared() < 100)\n                    .forEach(target => {\n                        const v = target.position.clone().sub(marble.position);\n                        const norm = v.clone(); norm.normalize();\n                        const power = (1-(v.length()/10));\n                        norm.mul(power * power * 5);\n                        target.body.applyLinearImpulse(norm, marble.position);\n                    });\n            }\n            if (marble.y > this._stage.goalY) {\n                this._winners.push(marble);\n                if (this._isRunning && this._winners.length === this._winnerRank + 1) {\n                    this.dispatchEvent(new CustomEvent('goal', {detail: {winner: marble.name}}));\n                    this._winner = marble;\n                    this._isRunning = false;\n                    this._particleManager.shot(this._renderer.width, this._renderer.height);\n                    setTimeout(() => { this._recorder.stop(); }, 1000);\n                } else if (this._isRunning && this._winnerRank === this._winners.length && this._winnerRank === this._totalMarbleCount - 1) {\n                    this.dispatchEvent(new CustomEvent('goal', {detail: {winner: this._marbles[i + 1].name}}));\n                    this._winner = this._marbles[i+1];\n                    this._isRunning = false;\n                    this._particleManager.shot(this._renderer.width, this._renderer.height);\n                    setTimeout(() => { this._recorder.stop(); }, 1000);\n                }\n                setTimeout(() => {\n                    this._world.destroyBody(marble.body);\n                }, 500);\n            }\n        }\n\n        const targetIndex = this._winnerRank - this._winners.length;\n        const topY = this._marbles[targetIndex] ? this._marbles[targetIndex].y : 0;\n        this._goalDist = Math.abs(this._stage.zoomY - topY);\n        this._timeScale = this._calcTimeScale();\n\n        this._marbles = this._marbles.filter(marble => marble.y <= this._stage!.goalY);\n        const maximumForce = this._marbles.reduce((p, c) => Math.max(p, c.body.getLinearVelocity().length()), 0);\n        if (maximumForce < 0.1) {\n            this._noMoveDuration += deltaTime;\n        } else {\n            this._noMoveDuration = 0;\n        }\n    }\n\n    private _calcTimeScale(): number {\n        if (!this._stage) return 1;\n        const targetIndex = this._winnerRank - this._winners.length;\n        if (this._winners.length < this._winnerRank + 1 && this._goalDist < zoomThreshold) {\n            if ( this._marbles[targetIndex].y > this._stage.zoomY - (zoomThreshold*1.2) &&\n                (this._marbles[targetIndex - 1] || this._marbles[targetIndex + 1])\n            ) {\n                return Math.max(0.2, (this._goalDist / zoomThreshold));\n            }\n        }\n        return 1;\n    }\n\n    private _updateEffects(deltaTime: number) {\n        this._effects.forEach(effect => effect.update(deltaTime));\n        this._effects = this._effects.filter(effect => !effect.isDestroy)\n    }\n\n    private _render() {\n        if (!this._stage) return;\n        const renderParams = {\n            camera: this._camera,\n            stage: this._stage,\n            objects: this._objects,\n            marbles: this._marbles,\n            winners: this._winners,\n            particleManager: this._particleManager,\n            effects: this._effects,\n            winnerRank: this._winnerRank,\n            winner: this._winner,\n            size: Vec2(this._renderer.width, this._renderer.height),\n        };\n        this._renderer.render(renderParams, this._uiObjects);\n    }\n\n    private _init() {\n        this._recorder = new VideoRecorder(this._renderer.canvas);\n        this._world = new planck.World({\n            gravity: new planck.Vec2(0, 10),\n        });\n\n        this.addUiObject(new RankRenderer());\n        this.attachEvent();\n        const minimap = new Minimap();\n        minimap.onViewportChange((pos) => {\n            if (pos) {\n                this._camera.setPosition(pos, false);\n                this._camera.lock(true);\n            } else {\n                this._camera.lock(false);\n            }\n        });\n        this.addUiObject(minimap);\n        this._stage = stages[0];\n        this._loadMap();\n    }\n\n    private attachEvent() {\n        this._renderer.canvas.addEventListener('mousemove', (e) => {\n            const sizeFactor = this._renderer.sizeFactor;\n            const pos = {x: e.offsetX * sizeFactor , y: e.offsetY * sizeFactor};\n            this._uiObjects.forEach((obj) => {\n                if (!obj.onMouseMove) return;\n                const bounds = obj.getBoundingBox();\n                if (!bounds) {\n                    obj.onMouseMove({...pos});\n                } else if (bounds && pos.x >= bounds.x && pos.y >= bounds.y && pos.x <= bounds.x + bounds.w && pos.y <= bounds.y + bounds.h) {\n                    obj.onMouseMove({x: pos.x - bounds.x, y: pos.y - bounds.y});\n                } else {\n                    obj.onMouseMove(undefined);\n                }\n            });\n        });\n    }\n\n    private _loadMap() {\n        if (!this._stage) {\n            throw new Error('No map has been selected');\n        }\n        this._stageObjects = [];\n        const {walls, boxes, wheels, jumpers} = this._stage;\n        walls.forEach((wallDef) => {\n            const wall = this._world.createBody({type: 'static'});\n            wall.setPosition(new planck.Vec2(0, 0));\n            wall.createFixture({\n                shape: planck.Chain(wallDef.map(pos => new planck.Vec2(...pos)), false),\n            });\n            this._stageObjects.push(wall);\n        });\n\n        wheels.forEach((wheelDef) => {\n            const item = createMover(this._world, new planck.Vec2(wheelDef[0], wheelDef[1]), wheelDef[2], (wheelDef[3] !== undefined && wheelDef[4] !== undefined) ? new planck.Vec2(wheelDef[3], wheelDef[4]) : undefined, wheelDef[5] ?? undefined);\n            this._objects.push(item);\n            this._stageObjects.push(item);\n        });\n\n        boxes.forEach(boxDef => {\n            const item = createBox(this._world, new planck.Vec2(boxDef[0], boxDef[1]), boxDef[2], boxDef[3], boxDef[4]);\n            this._objects.push(item);\n            this._stageObjects.push(item);\n        });\n\n        if (jumpers) {\n            jumpers.forEach(jumperDef => {\n                const item = createJumper(this._world, new planck.Vec2(jumperDef[0], jumperDef[1]), jumperDef[2], jumperDef[3]);\n                this._objects.push(item);\n                this._stageObjects.push(item);\n            });\n        }\n    }\n\n    public clearMarbles() {\n        this._marbles.forEach(marble => {\n            this._world.destroyBody(marble.body);\n        });\n        this._winner = null;\n        this._winners = [];\n        this._marbles = [];\n    }\n\n    public start() {\n        this._isRunning = true;\n        this._winnerRank = options.winningRank;\n        if (this._winnerRank >= this._marbles.length) {\n            this._winnerRank = this._marbles.length - 1;\n        }\n        if (this._autoRecording) {\n            this._recorder.start().then(() => {\n                this._marbles.forEach(marble => marble.body.setActive(true));\n            });\n        } else {\n            this._marbles.forEach(marble => marble.body.setActive(true));\n        }\n    }\n\n    public setSpeed(value: number) {\n        if (value <= 0) {\n            throw new Error('Speed multiplier must larger than 0');\n        }\n        this._speed = value;\n    }\n\n    public getSpeed() {\n        return this._speed;\n    }\n\n    public setWinningRank(rank: number) {\n        this._winnerRank = rank;\n    }\n\n    public setAutoRecording(value: boolean) {\n        this._autoRecording = value;\n    }\n\n    public setMarbles(names: string[]) {\n        this.reset();\n        const arr = names.slice();\n\n\n        let maxWeight = -Infinity;\n        let minWeight = Infinity;\n\n        const members = arr.map(nameString => {\n            const result =  parseName(nameString);\n            if (!result) return null;\n            const { name, weight, count } = result;\n            if (weight > maxWeight) maxWeight = weight;\n            if (weight < minWeight) minWeight = weight;\n            return {name, weight, count};\n        }).filter(member => !!member);\n\n        const gap = maxWeight - minWeight;\n\n        let totalCount = 0;\n        members.forEach(member => {\n            if (member) {\n                member.weight = 0.1 + (gap ? (member.weight - minWeight) / gap : 0);\n                totalCount += member.count;\n            }\n        });\n\n        const orders = Array(totalCount).fill(0).map((_, i) => i).sort(() => Math.random() - 0.5);\n        members.forEach((member) => {\n            if (member) {\n                for (let j = 0; j < member.count; j++) {\n                    const order = orders.pop() || 0;\n                    this._marbles.push(new Marble(this._world, order, totalCount, member.name, member.weight));\n                }\n            }\n        });\n        this._totalMarbleCount = totalCount;\n    }\n\n    private _clearMap() {\n        for(let body = this._world.getBodyList(); body; body = body.getNext()) {\n            this._world.destroyBody(body);\n        }\n        this._objects = [];\n        this._marbles = [];\n    }\n\n    public reset() {\n        this.clearMarbles();\n        this._clearMap();\n        this._loadMap();\n        this._goalDist = Infinity;\n    }\n\n    public getCount() {\n        return this._marbles.length;\n    }\n\n    private _changeShakeAvailable(v: boolean) {\n        if (this._shakeAvailable !== v) {\n            this._shakeAvailable = v;\n            this.dispatchEvent(new CustomEvent('shakeAvailableChanged', {detail: v}));\n        }\n    }\n\n    public shake() {\n        if (!this._shakeAvailable) return;\n        const xPower = (Math.random() - 0.5) * 4;\n        const yPower = (Math.random() - 0.5) * 4;\n        const power = new Vec2(xPower, yPower);\n        this._stageObjects.forEach(obj => {\n            let contact = obj.getContactList();\n            while(contact) {\n                if (contact.other) {\n                    contact.other.applyLinearImpulse(power, contact.other.getPosition());\n                }\n                contact = contact.next || null;\n            }\n        });\n        this._camera.setPosition(this._camera.position.add(power));\n    }\n\n    public getMaps() {\n        return stages.map((stage, index) => {\n            return {\n                index,\n                title: stage.title\n            };\n        });\n    }\n\n    public setMap(index: number) {\n        if (index < 0 || index > stages.length - 1) {\n            throw new Error('Incorrect map number');\n        }\n        const names = this._marbles.map((marble) => marble.name);\n        this._stage = stages[index];\n        this.setMarbles(names);\n    }\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/**\n * Planck.js v1.0.0-alpha.4\n * @license The MIT license\n * @copyright Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.planck = {}));\n}(this, (function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\n\n    function options (input, defaults) {\n        if (input === null || typeof input === 'undefined') {\n            // tslint:disable-next-line:no-object-literal-type-assertion\n            input = {};\n        }\n        var output = __assign({}, input);\n        // tslint:disable-next-line:no-for-in\n        for (var key in defaults) {\n            if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {\n                output[key] = defaults[key];\n            }\n        }\n        if (typeof Object.getOwnPropertySymbols === 'function') {\n            var symbols = Object.getOwnPropertySymbols(defaults);\n            for (var i = 0; i < symbols.length; i++) {\n                var symbol = symbols[i];\n                if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {\n                    output[symbol] = defaults[symbol];\n                }\n            }\n        }\n        return output;\n    }\n\n    var debug = function () {\n        var rest = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            rest[_i] = arguments[_i];\n        }\n        return;\n    };\n    var assert = function (statement, err, log) {\n        return;\n    };\n    var common = {\n        assert: assert,\n        debug: debug,\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var math = Object.create(Math);\n    // @ts-ignore\n    // noinspection JSConstantReassignment\n    math.EPSILON = 1e-9; // TODO\n    math.isFinite = function (x) {\n        return (typeof x === 'number') && isFinite(x) && !isNaN(x);\n    };\n    math.assert = function (x) {\n        return;\n    };\n    math.invSqrt = function (x) {\n        // TODO:\n        return 1 / Math.sqrt(x);\n    };\n    math.nextPowerOfTwo = function (x) {\n        // TODO\n        x |= (x >> 1);\n        x |= (x >> 2);\n        x |= (x >> 4);\n        x |= (x >> 8);\n        x |= (x >> 16);\n        return x + 1;\n    };\n    math.isPowerOfTwo = function (x) {\n        return x > 0 && (x & (x - 1)) === 0;\n    };\n    math.mod = function (num, min, max) {\n        if (typeof min === 'undefined') {\n            max = 1;\n            min = 0;\n        }\n        else if (typeof max === 'undefined') {\n            max = min;\n            min = 0;\n        }\n        if (max > min) {\n            num = (num - min) % (max - min);\n            return num + (num < 0 ? max : min);\n        }\n        else {\n            num = (num - max) % (min - max);\n            return num + (num <= 0 ? min : max);\n        }\n    };\n    math.clamp = function (num, min, max) {\n        if (num < min) {\n            return min;\n        }\n        else if (num > max) {\n            return max;\n        }\n        else {\n            return num;\n        }\n    };\n    math.random = function (min, max) {\n        if (typeof min === 'undefined') {\n            max = 1;\n            min = 0;\n        }\n        else if (typeof max === 'undefined') {\n            max = min;\n            min = 0;\n        }\n        return min === max ? min : Math.random() * (max - min) + min;\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Vec2 = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        function Vec2(x, y) {\n            if (!(this instanceof Vec2)) {\n                return new Vec2(x, y);\n            }\n            if (typeof x === 'undefined') {\n                this.x = 0;\n                this.y = 0;\n            }\n            else if (typeof x === 'object') {\n                this.x = x.x;\n                this.y = x.y;\n            }\n            else {\n                this.x = x;\n                this.y = y;\n            }\n        }\n        /** @internal */\n        Vec2.prototype._serialize = function () {\n            return {\n                x: this.x,\n                y: this.y\n            };\n        };\n        /** @internal */\n        Vec2._deserialize = function (data) {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = data.x;\n            obj.y = data.y;\n            return obj;\n        };\n        Vec2.zero = function () {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = 0;\n            obj.y = 0;\n            return obj;\n        };\n        /** @internal */\n        Vec2.neo = function (x, y) {\n            var obj = Object.create(Vec2.prototype);\n            obj.x = x;\n            obj.y = y;\n            return obj;\n        };\n        Vec2.clone = function (v) {\n            return Vec2.neo(v.x, v.y);\n        };\n        /** @internal */\n        Vec2.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        /**\n         * Does this vector contain finite coordinates?\n         */\n        Vec2.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return math.isFinite(obj.x) && math.isFinite(obj.y);\n        };\n        Vec2.assert = function (o) {\n            return;\n        };\n        Vec2.prototype.clone = function () {\n            return Vec2.clone(this);\n        };\n        /**\n         * Set this vector to all zeros.\n         *\n         * @returns this\n         */\n        Vec2.prototype.setZero = function () {\n            this.x = 0.0;\n            this.y = 0.0;\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */\n        // tslint:disable-next-line:typedef\n        Vec2.prototype.set = function (x, y) {\n            if (typeof x === 'object') {\n                this.x = x.x;\n                this.y = x.y;\n            }\n            else {\n                this.x = x;\n                this.y = y;\n            }\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */\n        Vec2.prototype.setNum = function (x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        /**\n         * Set this vector to some specified coordinates.\n         *\n         * @returns this\n         */\n        Vec2.prototype.setVec2 = function (value) {\n            this.x = value.x;\n            this.y = value.y;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Use setCombine or setMul\n         */\n        Vec2.prototype.wSet = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return this.setCombine(a, v, b, w);\n            }\n            else {\n                return this.setMul(a, v);\n            }\n        };\n        /**\n         * Set linear combination of v and w: `a * v + b * w`\n         */\n        Vec2.prototype.setCombine = function (a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        Vec2.prototype.setMul = function (a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        /**\n         * Add a vector to this vector.\n         *\n         * @returns this\n         */\n        Vec2.prototype.add = function (w) {\n            this.x += w.x;\n            this.y += w.y;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Use addCombine or addMul\n         */\n        Vec2.prototype.wAdd = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return this.addCombine(a, v, b, w);\n            }\n            else {\n                return this.addMul(a, v);\n            }\n        };\n        /**\n         * Add linear combination of v and w: `a * v + b * w`\n         */\n        Vec2.prototype.addCombine = function (a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x += x;\n            this.y += y;\n            return this;\n        };\n        Vec2.prototype.addMul = function (a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x += x;\n            this.y += y;\n            return this;\n        };\n        /**\n         * @deprecated Use subCombine or subMul\n         */\n        Vec2.prototype.wSub = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return this.subCombine(a, v, b, w);\n            }\n            else {\n                return this.subMul(a, v);\n            }\n        };\n        /**\n         * Subtract linear combination of v and w: `a * v + b * w`\n         */\n        Vec2.prototype.subCombine = function (a, v, b, w) {\n            var x = a * v.x + b * w.x;\n            var y = a * v.y + b * w.y;\n            // `this` may be `w`\n            this.x -= x;\n            this.y -= y;\n            return this;\n        };\n        Vec2.prototype.subMul = function (a, v) {\n            var x = a * v.x;\n            var y = a * v.y;\n            this.x -= x;\n            this.y -= y;\n            return this;\n        };\n        /**\n         * Subtract a vector from this vector\n         *\n         * @returns this\n         */\n        Vec2.prototype.sub = function (w) {\n            this.x -= w.x;\n            this.y -= w.y;\n            return this;\n        };\n        /**\n         * Multiply this vector by a scalar.\n         *\n         * @returns this\n         */\n        Vec2.prototype.mul = function (m) {\n            this.x *= m;\n            this.y *= m;\n            return this;\n        };\n        /**\n         * Get the length of this vector (the norm).\n         *\n         * For performance, use this instead of lengthSquared (if possible).\n         */\n        Vec2.prototype.length = function () {\n            return Vec2.lengthOf(this);\n        };\n        /**\n         * Get the length squared.\n         */\n        Vec2.prototype.lengthSquared = function () {\n            return Vec2.lengthSquared(this);\n        };\n        /**\n         * Convert this vector into a unit vector.\n         *\n         * @returns old length\n         */\n        Vec2.prototype.normalize = function () {\n            var length = this.length();\n            if (length < math.EPSILON) {\n                return 0.0;\n            }\n            var invLength = 1.0 / length;\n            this.x *= invLength;\n            this.y *= invLength;\n            return length;\n        };\n        /**\n         * Get the length of this vector (the norm).\n         *\n         * For performance, use this instead of lengthSquared (if possible).\n         */\n        Vec2.lengthOf = function (v) {\n            return math.sqrt(v.x * v.x + v.y * v.y);\n        };\n        /**\n         * Get the length squared.\n         */\n        Vec2.lengthSquared = function (v) {\n            return v.x * v.x + v.y * v.y;\n        };\n        Vec2.distance = function (v, w) {\n            var dx = v.x - w.x;\n            var dy = v.y - w.y;\n            return math.sqrt(dx * dx + dy * dy);\n        };\n        Vec2.distanceSquared = function (v, w) {\n            var dx = v.x - w.x;\n            var dy = v.y - w.y;\n            return dx * dx + dy * dy;\n        };\n        Vec2.areEqual = function (v, w) {\n            return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;\n        };\n        /**\n         * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n         */\n        Vec2.skew = function (v) {\n            return Vec2.neo(-v.y, v.x);\n        };\n        /**\n         * Perform the dot product on two vectors.\n         */\n        Vec2.dot = function (v, w) {\n            return v.x * w.x + v.y * w.y;\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         *\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */\n        // tslint:disable-next-line:typedef\n        Vec2.cross = function (v, w) {\n            if (typeof w === 'number') {\n                return Vec2.neo(w * v.y, -w * v.x);\n            }\n            else if (typeof v === 'number') {\n                return Vec2.neo(-v * w.y, v * w.x);\n            }\n            else {\n                return v.x * w.y - v.y * w.x;\n            }\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         */\n        Vec2.crossVec2Vec2 = function (v, w) {\n            return v.x * w.y - v.y * w.x;\n        };\n        /**\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */\n        Vec2.crossVec2Num = function (v, w) {\n            return Vec2.neo(w * v.y, -w * v.x);\n        };\n        /**\n         * Perform the cross product on a vector and a scalar. In 2D this produces a\n         * vector.\n         */\n        Vec2.crossNumVec2 = function (v, w) {\n            return Vec2.neo(-v * w.y, v * w.x);\n        };\n        /**\n         * Returns `a + (v x w)`\n         */\n        // tslint:disable-next-line:typedef\n        Vec2.addCross = function (a, v, w) {\n            if (typeof w === 'number') {\n                return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n            }\n            else if (typeof v === 'number') {\n                return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n            }\n        };\n        /**\n         * Returns `a + (v x w)`\n         */\n        Vec2.addCrossVec2Num = function (a, v, w) {\n            return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n        };\n        /**\n         * Returns `a + (v x w)`\n         */\n        Vec2.addCrossNumVec2 = function (a, v, w) {\n            return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n        };\n        Vec2.add = function (v, w) {\n            return Vec2.neo(v.x + w.x, v.y + w.y);\n        };\n        /** @internal @deprecated */\n        Vec2.wAdd = function (a, v, b, w) {\n            if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n                return Vec2.combine(a, v, b, w);\n            }\n            else {\n                return Vec2.mulNumVec2(a, v);\n            }\n        };\n        Vec2.combine = function (a, v, b, w) {\n            return Vec2.zero().setCombine(a, v, b, w);\n        };\n        Vec2.sub = function (v, w) {\n            return Vec2.neo(v.x - w.x, v.y - w.y);\n        };\n        // tslint:disable-next-line:typedef\n        Vec2.mul = function (a, b) {\n            if (typeof a === 'object') {\n                return Vec2.neo(a.x * b, a.y * b);\n            }\n            else if (typeof b === 'object') {\n                return Vec2.neo(a * b.x, a * b.y);\n            }\n        };\n        Vec2.mulVec2Num = function (a, b) {\n            return Vec2.neo(a.x * b, a.y * b);\n        };\n        Vec2.mulNumVec2 = function (a, b) {\n            return Vec2.neo(a * b.x, a * b.y);\n        };\n        Vec2.prototype.neg = function () {\n            this.x = -this.x;\n            this.y = -this.y;\n            return this;\n        };\n        Vec2.neg = function (v) {\n            return Vec2.neo(-v.x, -v.y);\n        };\n        Vec2.abs = function (v) {\n            return Vec2.neo(math.abs(v.x), math.abs(v.y));\n        };\n        Vec2.mid = function (v, w) {\n            return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n        };\n        Vec2.upper = function (v, w) {\n            return Vec2.neo(math.max(v.x, w.x), math.max(v.y, w.y));\n        };\n        Vec2.lower = function (v, w) {\n            return Vec2.neo(math.min(v.x, w.x), math.min(v.y, w.y));\n        };\n        Vec2.prototype.clamp = function (max) {\n            var lengthSqr = this.x * this.x + this.y * this.y;\n            if (lengthSqr > max * max) {\n                var invLength = math.invSqrt(lengthSqr);\n                this.x *= invLength * max;\n                this.y *= invLength * max;\n            }\n            return this;\n        };\n        Vec2.clamp = function (v, max) {\n            v = Vec2.neo(v.x, v.y);\n            v.clamp(max);\n            return v;\n        };\n        /**  @internal @deprecated */\n        // tslint:disable-next-line:typedef\n        Vec2.scaleFn = function (x, y) {\n            return function (v) {\n                return Vec2.neo(v.x * x, v.y * y);\n            };\n        };\n        /**  @internal @deprecated */\n        // tslint:disable-next-line:typedef\n        Vec2.translateFn = function (x, y) {\n            return function (v) {\n                return Vec2.neo(v.x + x, v.y + y);\n            };\n        };\n        return Vec2;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var AABB = /** @class */ (function () {\n        function AABB(lower, upper) {\n            if (!(this instanceof AABB)) {\n                return new AABB(lower, upper);\n            }\n            this.lowerBound = Vec2.zero();\n            this.upperBound = Vec2.zero();\n            if (typeof lower === 'object') {\n                this.lowerBound.setVec2(lower);\n            }\n            if (typeof upper === 'object') {\n                this.upperBound.setVec2(upper);\n            }\n            else if (typeof lower === 'object') {\n                this.upperBound.setVec2(lower);\n            }\n        }\n        /**\n         * Verify that the bounds are sorted.\n         */\n        AABB.prototype.isValid = function () {\n            return AABB.isValid(this);\n        };\n        AABB.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n        };\n        AABB.assert = function (o) {\n            return;\n        };\n        /**\n         * Get the center of the AABB.\n         */\n        AABB.prototype.getCenter = function () {\n            return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n        };\n        /**\n         * Get the extents of the AABB (half-widths).\n         */\n        AABB.prototype.getExtents = function () {\n            return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n        };\n        /**\n         * Get the perimeter length.\n         */\n        AABB.prototype.getPerimeter = function () {\n            return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n        };\n        /**\n         * Combine one or two AABB into this one.\n         */\n        AABB.prototype.combine = function (a, b) {\n            b = b || this;\n            var lowerA = a.lowerBound;\n            var upperA = a.upperBound;\n            var lowerB = b.lowerBound;\n            var upperB = b.upperBound;\n            var lowerX = math.min(lowerA.x, lowerB.x);\n            var lowerY = math.min(lowerA.y, lowerB.y);\n            var upperX = math.max(upperB.x, upperA.x);\n            var upperY = math.max(upperB.y, upperA.y);\n            this.lowerBound.setNum(lowerX, lowerY);\n            this.upperBound.setNum(upperX, upperY);\n        };\n        AABB.prototype.combinePoints = function (a, b) {\n            this.lowerBound.setNum(math.min(a.x, b.x), math.min(a.y, b.y));\n            this.upperBound.setNum(math.max(a.x, b.x), math.max(a.y, b.y));\n        };\n        AABB.prototype.set = function (aabb) {\n            this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n            this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n        };\n        AABB.prototype.contains = function (aabb) {\n            var result = true;\n            result = result && this.lowerBound.x <= aabb.lowerBound.x;\n            result = result && this.lowerBound.y <= aabb.lowerBound.y;\n            result = result && aabb.upperBound.x <= this.upperBound.x;\n            result = result && aabb.upperBound.y <= this.upperBound.y;\n            return result;\n        };\n        AABB.prototype.extend = function (value) {\n            AABB.extend(this, value);\n            return this;\n        };\n        AABB.extend = function (aabb, value) {\n            aabb.lowerBound.x -= value;\n            aabb.lowerBound.y -= value;\n            aabb.upperBound.x += value;\n            aabb.upperBound.y += value;\n        };\n        AABB.testOverlap = function (a, b) {\n            var d1x = b.lowerBound.x - a.upperBound.x;\n            var d2x = a.lowerBound.x - b.upperBound.x;\n            var d1y = b.lowerBound.y - a.upperBound.y;\n            var d2y = a.lowerBound.y - b.upperBound.y;\n            if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n                return false;\n            }\n            return true;\n        };\n        AABB.areEqual = function (a, b) {\n            return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n        };\n        AABB.diff = function (a, b) {\n            var wD = math.max(0, math.min(a.upperBound.x, b.upperBound.x) - math.max(b.lowerBound.x, a.lowerBound.x));\n            var hD = math.max(0, math.min(a.upperBound.y, b.upperBound.y) - math.max(b.lowerBound.y, a.lowerBound.y));\n            var wA = a.upperBound.x - a.lowerBound.x;\n            var hA = a.upperBound.y - a.lowerBound.y;\n            var wB = b.upperBound.x - b.lowerBound.x;\n            var hB = b.upperBound.y - b.lowerBound.y;\n            return wA * hA + wB * hB - wD * hD;\n        };\n        AABB.prototype.rayCast = function (output, input) {\n            // From Real-time Collision Detection, p179.\n            var tmin = -Infinity;\n            var tmax = Infinity;\n            var p = input.p1;\n            var d = Vec2.sub(input.p2, input.p1);\n            var absD = Vec2.abs(d);\n            var normal = Vec2.zero();\n            for (var f = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {\n                if (absD.x < math.EPSILON) {\n                    // Parallel.\n                    if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n                        return false;\n                    }\n                }\n                else {\n                    var inv_d = 1.0 / d[f];\n                    var t1 = (this.lowerBound[f] - p[f]) * inv_d;\n                    var t2 = (this.upperBound[f] - p[f]) * inv_d;\n                    // Sign of the normal vector.\n                    var s = -1.0;\n                    if (t1 > t2) {\n                        var temp = t1;\n                        t1 = t2;\n                        t2 = temp;\n                        s = 1.0;\n                    }\n                    // Push the min up\n                    if (t1 > tmin) {\n                        normal.setZero();\n                        normal[f] = s;\n                        tmin = t1;\n                    }\n                    // Pull the max down\n                    tmax = math.min(tmax, t2);\n                    if (tmin > tmax) {\n                        return false;\n                    }\n                }\n            }\n            // Does the ray start inside the box?\n            // Does the ray intersect beyond the max fraction?\n            if (tmin < 0.0 || input.maxFraction < tmin) {\n                return false;\n            }\n            // Intersection.\n            output.fraction = tmin;\n            output.normal = normal;\n            return true;\n        };\n        /** @internal */\n        AABB.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        return AABB;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    // TODO merge with World options?\n    /**\n     * Tuning constants based on meters-kilograms-seconds (MKS) units.\n     */\n    // tslint:disable-next-line:no-unnecessary-class\n    var Settings = /** @class */ (function () {\n        function Settings() {\n        }\n        Object.defineProperty(Settings, \"linearSlopSquared\", {\n            get: function () { return Settings.linearSlop * Settings.linearSlop; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"polygonRadius\", {\n            /**\n             * The radius of the polygon/edge shape skin. This should not be modified.\n             * Making this smaller means polygons will have an insufficient buffer for\n             * continuous collision. Making it larger may create artifacts for vertex\n             * collision.\n             */\n            get: function () { return 2.0 * Settings.linearSlop; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"maxTranslationSquared\", {\n            get: function () { return Settings.maxTranslation * Settings.maxTranslation; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"maxRotationSquared\", {\n            get: function () { return Settings.maxRotation * Settings.maxRotation; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"linearSleepToleranceSqr\", {\n            get: function () { return Math.pow(Settings.linearSleepTolerance, 2); },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Settings, \"angularSleepToleranceSqr\", {\n            get: function () { return Math.pow(Settings.angularSleepTolerance, 2); },\n            enumerable: false,\n            configurable: true\n        });\n        // Collision\n        /**\n         * The maximum number of contact points between two convex shapes. Do not change\n         * this value.\n         */\n        Settings.maxManifoldPoints = 2;\n        /**\n         * The maximum number of vertices on a convex polygon. You cannot increase this\n         * too much because BlockAllocator has a maximum object size.\n         */\n        Settings.maxPolygonVertices = 12;\n        /**\n         * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n         * by a small amount without triggering a tree adjustment. This is in meters.\n         */\n        Settings.aabbExtension = 0.1;\n        /**\n         * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n         * future position based on the current displacement. This is a dimensionless\n         * multiplier.\n         */\n        Settings.aabbMultiplier = 2.0;\n        /**\n         * A small length used as a collision and constraint tolerance. Usually it is\n         * chosen to be numerically significant, but visually insignificant.\n         */\n        Settings.linearSlop = 0.005;\n        /**\n         * A small angle used as a collision and constraint tolerance. Usually it is\n         * chosen to be numerically significant, but visually insignificant.\n         */\n        Settings.angularSlop = (2.0 / 180.0 * Math.PI);\n        /**\n         * Maximum number of sub-steps per contact in continuous physics simulation.\n         */\n        Settings.maxSubSteps = 8;\n        // Dynamics\n        /**\n         * Maximum number of contacts to be handled to solve a TOI impact.\n         */\n        Settings.maxTOIContacts = 32;\n        /**\n         * Maximum iterations to solve a TOI.\n         */\n        Settings.maxTOIIterations = 20;\n        /**\n         * Maximum iterations to find Distance.\n         */\n        Settings.maxDistnceIterations = 20;\n        /**\n         * A velocity threshold for elastic collisions. Any collision with a relative\n         * linear velocity below this threshold will be treated as inelastic.\n         */\n        Settings.velocityThreshold = 1.0;\n        /**\n         * The maximum linear position correction used when solving constraints. This\n         * helps to prevent overshoot.\n         */\n        Settings.maxLinearCorrection = 0.2;\n        /**\n         * The maximum angular position correction used when solving constraints. This\n         * helps to prevent overshoot.\n         */\n        Settings.maxAngularCorrection = (8.0 / 180.0 * Math.PI);\n        /**\n         * The maximum linear velocity of a body. This limit is very large and is used\n         * to prevent numerical problems. You shouldn't need to adjust Settings.\n         */\n        Settings.maxTranslation = 2.0;\n        /**\n         * The maximum angular velocity of a body. This limit is very large and is used\n         * to prevent numerical problems. You shouldn't need to adjust Settings.\n         */\n        Settings.maxRotation = (0.5 * Math.PI);\n        /**\n         * This scale factor controls how fast overlap is resolved. Ideally this would\n         * be 1 so that overlap is removed in one time step. However using values close\n         * to 1 often lead to overshoot.\n         */\n        Settings.baumgarte = 0.2;\n        Settings.toiBaugarte = 0.75;\n        // Sleep\n        /**\n         * The time that a body must be still before it will go to sleep.\n         */\n        Settings.timeToSleep = 0.5;\n        /**\n         * A body cannot sleep if its linear velocity is above this tolerance.\n         */\n        Settings.linearSleepTolerance = 0.01;\n        /**\n         * A body cannot sleep if its angular velocity is above this tolerance.\n         */\n        Settings.angularSleepTolerance = (2.0 / 180.0 * Math.PI);\n        return Settings;\n    }());\n\n    /*\n     * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n     *\n     * This software is provided 'as-is', without any express or implied\n     * warranty.  In no event will the authors be held liable for any damages\n     * arising from the use of this software.\n     * Permission is granted to anyone to use this software for any purpose,\n     * including commercial applications, and to alter it and redistribute it\n     * freely, subject to the following restrictions:\n     * 1. The origin of this software must not be misrepresented; you must not\n     * claim that you wrote the original software. If you use this software\n     * in a product, an acknowledgment in the product documentation would be\n     * appreciated but is not required.\n     * 2. Altered source versions must be plainly marked as such, and must not be\n     * misrepresented as being the original software.\n     * 3. This notice may not be removed or altered from any source distribution.\n     */\n    var Pool = /** @class */ (function () {\n        function Pool(opts) {\n            this._list = [];\n            this._max = Infinity;\n            this._createCount = 0;\n            this._outCount = 0;\n            this._inCount = 0;\n            this._discardCount = 0;\n            this._list = [];\n            this._max = opts.max || this._max;\n            this._createFn = opts.create;\n            this._outFn = opts.allocate;\n            this._inFn = opts.release;\n            this._discardFn = opts.discard;\n        }\n        Pool.prototype.max = function (n) {\n            if (typeof n === 'number') {\n                this._max = n;\n                return this;\n            }\n            return this._max;\n        };\n        Pool.prototype.size = function () {\n            return this._list.length;\n        };\n        Pool.prototype.allocate = function () {\n            var item;\n            if (this._list.length > 0) {\n                item = this._list.shift();\n            }\n            else {\n                this._createCount++;\n                if (typeof this._createFn === 'function') {\n                    item = this._createFn();\n                }\n                else {\n                    // tslint:disable-next-line:no-object-literal-type-assertion\n                    item = {};\n                }\n            }\n            this._outCount++;\n            if (typeof this._outFn === 'function') {\n                this._outFn(item);\n            }\n            return item;\n        };\n        Pool.prototype.release = function (item) {\n            if (this._list.length < this._max) {\n                this._inCount++;\n                if (typeof this._inFn === 'function') {\n                    this._inFn(item);\n                }\n                this._list.push(item);\n            }\n            else {\n                this._discardCount++;\n                if (typeof this._discardFn === 'function') {\n                    item = this._discardFn(item);\n                }\n            }\n        };\n        /** @internal */\n        Pool.prototype.toString = function () {\n            return \" +\" + this._createCount + \" >\" + this._outCount + \" <\" + this._inCount + \" -\"\n                + this._discardCount + \" =\" + this._list.length + \"/\" + this._max;\n        };\n        return Pool;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A node in the dynamic tree. The client does not interact with this directly.\n     */\n    var TreeNode = /** @class */ (function () {\n        function TreeNode(id) {\n            /** Enlarged AABB */\n            this.aabb = new AABB();\n            this.userData = null;\n            this.parent = null;\n            this.child1 = null;\n            this.child2 = null;\n            /** 0: leaf, -1: free node */\n            this.height = -1;\n            this.id = id;\n        }\n        /** @internal */\n        TreeNode.prototype.toString = function () {\n            return this.id + \": \" + this.userData;\n        };\n        TreeNode.prototype.isLeaf = function () {\n            return this.child1 == null;\n        };\n        return TreeNode;\n    }());\n    /**\n     * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n     * dynamic tree arranges data in a binary tree to accelerate queries such as\n     * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n     * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n     * than the client object. This allows the client object to move by small\n     * amounts without triggering a tree update.\n     *\n     * Nodes are pooled and relocatable, so we use node indices rather than\n     * pointers.\n     */\n    var DynamicTree = /** @class */ (function () {\n        function DynamicTree() {\n            this.inputPool = new Pool({\n                create: function () {\n                    // tslint:disable-next-line:no-object-literal-type-assertion\n                    return {};\n                },\n                release: function (stack) {\n                }\n            });\n            this.stackPool = new Pool({\n                create: function () {\n                    return [];\n                },\n                release: function (stack) {\n                    stack.length = 0;\n                }\n            });\n            this.iteratorPool = new Pool({\n                create: function () {\n                    return new Iterator();\n                },\n                release: function (iterator) {\n                    iterator.close();\n                }\n            });\n            this.m_root = null;\n            this.m_nodes = {};\n            this.m_lastProxyId = 0;\n            this.m_pool = new Pool({\n                create: function () {\n                    return new TreeNode();\n                }\n            });\n        }\n        /**\n         * Get proxy user data.\n         *\n         * @return the proxy user data or 0 if the id is invalid.\n         */\n        DynamicTree.prototype.getUserData = function (id) {\n            var node = this.m_nodes[id];\n            return node.userData;\n        };\n        /**\n         * Get the fat AABB for a node id.\n         *\n         * @return the proxy user data or 0 if the id is invalid.\n         */\n        DynamicTree.prototype.getFatAABB = function (id) {\n            var node = this.m_nodes[id];\n            return node.aabb;\n        };\n        DynamicTree.prototype.allocateNode = function () {\n            var node = this.m_pool.allocate();\n            node.id = ++this.m_lastProxyId;\n            node.userData = null;\n            node.parent = null;\n            node.child1 = null;\n            node.child2 = null;\n            node.height = -1;\n            this.m_nodes[node.id] = node;\n            return node;\n        };\n        DynamicTree.prototype.freeNode = function (node) {\n            this.m_pool.release(node);\n            node.height = -1;\n            // tslint:disable-next-line:no-dynamic-delete\n            delete this.m_nodes[node.id];\n        };\n        /**\n         * Create a proxy in the tree as a leaf node. We return the index of the node\n         * instead of a pointer so that we can grow the node pool.\n         *\n         * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n         */\n        DynamicTree.prototype.createProxy = function (aabb, userData) {\n            var node = this.allocateNode();\n            node.aabb.set(aabb);\n            // Fatten the aabb.\n            AABB.extend(node.aabb, Settings.aabbExtension);\n            node.userData = userData;\n            node.height = 0;\n            this.insertLeaf(node);\n            return node.id;\n        };\n        /**\n         * Destroy a proxy. This asserts if the id is invalid.\n         */\n        DynamicTree.prototype.destroyProxy = function (id) {\n            var node = this.m_nodes[id];\n            this.removeLeaf(node);\n            this.freeNode(node);\n        };\n        /**\n         * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n         * fattened AABB, then the proxy is removed from the tree and re-inserted.\n         * Otherwise the function returns immediately.\n         *\n         * @param d Displacement\n         *\n         * @return true if the proxy was re-inserted.\n         */\n        DynamicTree.prototype.moveProxy = function (id, aabb, d) {\n            var node = this.m_nodes[id];\n            if (node.aabb.contains(aabb)) {\n                return false;\n            }\n            this.removeLeaf(node);\n            node.aabb.set(aabb);\n            // Extend AABB.\n            aabb = node.aabb;\n            AABB.extend(aabb, Settings.aabbExtension);\n            // Predict AABB displacement.\n            // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n            if (d.x < 0.0) {\n                aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n            }\n            else {\n                aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n            }\n            if (d.y < 0.0) {\n                aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n            }\n            else {\n                aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n            }\n            this.insertLeaf(node);\n            return true;\n        };\n        DynamicTree.prototype.insertLeaf = function (leaf) {\n            if (this.m_root == null) {\n                this.m_root = leaf;\n                this.m_root.parent = null;\n                return;\n            }\n            // Find the best sibling for this node\n            var leafAABB = leaf.aabb;\n            var index = this.m_root;\n            while (!index.isLeaf()) {\n                var child1 = index.child1;\n                var child2 = index.child2;\n                var area = index.aabb.getPerimeter();\n                var combinedAABB = new AABB();\n                combinedAABB.combine(index.aabb, leafAABB);\n                var combinedArea = combinedAABB.getPerimeter();\n                // Cost of creating a new parent for this node and the new leaf\n                var cost = 2.0 * combinedArea;\n                // Minimum cost of pushing the leaf further down the tree\n                var inheritanceCost = 2.0 * (combinedArea - area);\n                // Cost of descending into child1\n                var cost1 = void 0;\n                if (child1.isLeaf()) {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child1.aabb);\n                    cost1 = aabb.getPerimeter() + inheritanceCost;\n                }\n                else {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child1.aabb);\n                    var oldArea = child1.aabb.getPerimeter();\n                    var newArea = aabb.getPerimeter();\n                    cost1 = (newArea - oldArea) + inheritanceCost;\n                }\n                // Cost of descending into child2\n                var cost2 = void 0;\n                if (child2.isLeaf()) {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child2.aabb);\n                    cost2 = aabb.getPerimeter() + inheritanceCost;\n                }\n                else {\n                    var aabb = new AABB();\n                    aabb.combine(leafAABB, child2.aabb);\n                    var oldArea = child2.aabb.getPerimeter();\n                    var newArea = aabb.getPerimeter();\n                    cost2 = newArea - oldArea + inheritanceCost;\n                }\n                // Descend according to the minimum cost.\n                if (cost < cost1 && cost < cost2) {\n                    break;\n                }\n                // Descend\n                if (cost1 < cost2) {\n                    index = child1;\n                }\n                else {\n                    index = child2;\n                }\n            }\n            var sibling = index;\n            // Create a new parent.\n            var oldParent = sibling.parent;\n            var newParent = this.allocateNode();\n            newParent.parent = oldParent;\n            newParent.userData = null;\n            newParent.aabb.combine(leafAABB, sibling.aabb);\n            newParent.height = sibling.height + 1;\n            if (oldParent != null) {\n                // The sibling was not the root.\n                if (oldParent.child1 === sibling) {\n                    oldParent.child1 = newParent;\n                }\n                else {\n                    oldParent.child2 = newParent;\n                }\n                newParent.child1 = sibling;\n                newParent.child2 = leaf;\n                sibling.parent = newParent;\n                leaf.parent = newParent;\n            }\n            else {\n                // The sibling was the root.\n                newParent.child1 = sibling;\n                newParent.child2 = leaf;\n                sibling.parent = newParent;\n                leaf.parent = newParent;\n                this.m_root = newParent;\n            }\n            // Walk back up the tree fixing heights and AABBs\n            index = leaf.parent;\n            while (index != null) {\n                index = this.balance(index);\n                var child1 = index.child1;\n                var child2 = index.child2;\n                index.height = 1 + math.max(child1.height, child2.height);\n                index.aabb.combine(child1.aabb, child2.aabb);\n                index = index.parent;\n            }\n            // validate();\n        };\n        DynamicTree.prototype.removeLeaf = function (leaf) {\n            if (leaf === this.m_root) {\n                this.m_root = null;\n                return;\n            }\n            var parent = leaf.parent;\n            var grandParent = parent.parent;\n            var sibling;\n            if (parent.child1 === leaf) {\n                sibling = parent.child2;\n            }\n            else {\n                sibling = parent.child1;\n            }\n            if (grandParent != null) {\n                // Destroy parent and connect sibling to grandParent.\n                if (grandParent.child1 === parent) {\n                    grandParent.child1 = sibling;\n                }\n                else {\n                    grandParent.child2 = sibling;\n                }\n                sibling.parent = grandParent;\n                this.freeNode(parent);\n                // Adjust ancestor bounds.\n                var index = grandParent;\n                while (index != null) {\n                    index = this.balance(index);\n                    var child1 = index.child1;\n                    var child2 = index.child2;\n                    index.aabb.combine(child1.aabb, child2.aabb);\n                    index.height = 1 + math.max(child1.height, child2.height);\n                    index = index.parent;\n                }\n            }\n            else {\n                this.m_root = sibling;\n                sibling.parent = null;\n                this.freeNode(parent);\n            }\n            // validate();\n        };\n        /**\n         * Perform a left or right rotation if node A is imbalanced. Returns the new\n         * root index.\n         */\n        DynamicTree.prototype.balance = function (iA) {\n            var A = iA;\n            if (A.isLeaf() || A.height < 2) {\n                return iA;\n            }\n            var B = A.child1;\n            var C = A.child2;\n            var balance = C.height - B.height;\n            // Rotate C up\n            if (balance > 1) {\n                var F = C.child1;\n                var G = C.child2;\n                // Swap A and C\n                C.child1 = A;\n                C.parent = A.parent;\n                A.parent = C;\n                // A's old parent should point to C\n                if (C.parent != null) {\n                    if (C.parent.child1 === iA) {\n                        C.parent.child1 = C;\n                    }\n                    else {\n                        C.parent.child2 = C;\n                    }\n                }\n                else {\n                    this.m_root = C;\n                }\n                // Rotate\n                if (F.height > G.height) {\n                    C.child2 = F;\n                    A.child2 = G;\n                    G.parent = A;\n                    A.aabb.combine(B.aabb, G.aabb);\n                    C.aabb.combine(A.aabb, F.aabb);\n                    A.height = 1 + math.max(B.height, G.height);\n                    C.height = 1 + math.max(A.height, F.height);\n                }\n                else {\n                    C.child2 = G;\n                    A.child2 = F;\n                    F.parent = A;\n                    A.aabb.combine(B.aabb, F.aabb);\n                    C.aabb.combine(A.aabb, G.aabb);\n                    A.height = 1 + math.max(B.height, F.height);\n                    C.height = 1 + math.max(A.height, G.height);\n                }\n                return C;\n            }\n            // Rotate B up\n            if (balance < -1) {\n                var D = B.child1;\n                var E = B.child2;\n                // Swap A and B\n                B.child1 = A;\n                B.parent = A.parent;\n                A.parent = B;\n                // A's old parent should point to B\n                if (B.parent != null) {\n                    if (B.parent.child1 === A) {\n                        B.parent.child1 = B;\n                    }\n                    else {\n                        B.parent.child2 = B;\n                    }\n                }\n                else {\n                    this.m_root = B;\n                }\n                // Rotate\n                if (D.height > E.height) {\n                    B.child2 = D;\n                    A.child1 = E;\n                    E.parent = A;\n                    A.aabb.combine(C.aabb, E.aabb);\n                    B.aabb.combine(A.aabb, D.aabb);\n                    A.height = 1 + math.max(C.height, E.height);\n                    B.height = 1 + math.max(A.height, D.height);\n                }\n                else {\n                    B.child2 = E;\n                    A.child1 = D;\n                    D.parent = A;\n                    A.aabb.combine(C.aabb, D.aabb);\n                    B.aabb.combine(A.aabb, E.aabb);\n                    A.height = 1 + math.max(C.height, D.height);\n                    B.height = 1 + math.max(A.height, E.height);\n                }\n                return B;\n            }\n            return A;\n        };\n        /**\n         * Compute the height of the binary tree in O(N) time. Should not be called\n         * often.\n         */\n        DynamicTree.prototype.getHeight = function () {\n            if (this.m_root == null) {\n                return 0;\n            }\n            return this.m_root.height;\n        };\n        /**\n         * Get the ratio of the sum of the node areas to the root area.\n         */\n        DynamicTree.prototype.getAreaRatio = function () {\n            if (this.m_root == null) {\n                return 0.0;\n            }\n            var root = this.m_root;\n            var rootArea = root.aabb.getPerimeter();\n            var totalArea = 0.0;\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                if (node.height < 0) {\n                    // Free node in pool\n                    continue;\n                }\n                totalArea += node.aabb.getPerimeter();\n            }\n            this.iteratorPool.release(it);\n            return totalArea / rootArea;\n        };\n        /**\n         * Compute the height of a sub-tree.\n         */\n        DynamicTree.prototype.computeHeight = function (id) {\n            var node;\n            if (typeof id !== 'undefined') {\n                node = this.m_nodes[id];\n            }\n            else {\n                node = this.m_root;\n            }\n            // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);\n            if (node.isLeaf()) {\n                return 0;\n            }\n            var height1 = this.computeHeight(node.child1.id);\n            var height2 = this.computeHeight(node.child2.id);\n            return 1 + math.max(height1, height2);\n        };\n        DynamicTree.prototype.validateStructure = function (node) {\n            if (node == null) {\n                return;\n            }\n            if (node === this.m_root) ;\n            var child1 = node.child1;\n            var child2 = node.child2;\n            if (node.isLeaf()) {\n                return;\n            }\n            this.validateStructure(child1);\n            this.validateStructure(child2);\n        };\n        DynamicTree.prototype.validateMetrics = function (node) {\n            if (node == null) {\n                return;\n            }\n            var child1 = node.child1;\n            var child2 = node.child2;\n            if (node.isLeaf()) {\n                return;\n            }\n            // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n            // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n            var height1 = child1.height;\n            var height2 = child2.height;\n            1 + math.max(height1, height2);\n            var aabb = new AABB();\n            aabb.combine(child1.aabb, child2.aabb);\n            this.validateMetrics(child1);\n            this.validateMetrics(child2);\n        };\n        /**\n         * Validate this tree. For testing.\n         */\n        DynamicTree.prototype.validate = function () {\n            this.validateStructure(this.m_root);\n            this.validateMetrics(this.m_root);\n        };\n        /**\n         * Get the maximum balance of an node in the tree. The balance is the difference\n         * in height of the two children of a node.\n         */\n        DynamicTree.prototype.getMaxBalance = function () {\n            var maxBalance = 0;\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                if (node.height <= 1) {\n                    continue;\n                }\n                var balance = math.abs(node.child2.height - node.child1.height);\n                maxBalance = math.max(maxBalance, balance);\n            }\n            this.iteratorPool.release(it);\n            return maxBalance;\n        };\n        /**\n         * Build an optimal tree. Very expensive. For testing.\n         */\n        DynamicTree.prototype.rebuildBottomUp = function () {\n            var nodes = [];\n            var count = 0;\n            // Build array of leaves. Free the rest.\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                if (node.height < 0) {\n                    // free node in pool\n                    continue;\n                }\n                if (node.isLeaf()) {\n                    node.parent = null;\n                    nodes[count] = node;\n                    ++count;\n                }\n                else {\n                    this.freeNode(node);\n                }\n            }\n            this.iteratorPool.release(it);\n            while (count > 1) {\n                var minCost = Infinity;\n                var iMin = -1;\n                var jMin = -1;\n                for (var i = 0; i < count; ++i) {\n                    var aabbi = nodes[i].aabb;\n                    for (var j = i + 1; j < count; ++j) {\n                        var aabbj = nodes[j].aabb;\n                        var b = new AABB();\n                        b.combine(aabbi, aabbj);\n                        var cost = b.getPerimeter();\n                        if (cost < minCost) {\n                            iMin = i;\n                            jMin = j;\n                            minCost = cost;\n                        }\n                    }\n                }\n                var child1 = nodes[iMin];\n                var child2 = nodes[jMin];\n                var parent_1 = this.allocateNode();\n                parent_1.child1 = child1;\n                parent_1.child2 = child2;\n                parent_1.height = 1 + math.max(child1.height, child2.height);\n                parent_1.aabb.combine(child1.aabb, child2.aabb);\n                parent_1.parent = null;\n                child1.parent = parent_1;\n                child2.parent = parent_1;\n                nodes[jMin] = nodes[count - 1];\n                nodes[iMin] = parent_1;\n                --count;\n            }\n            this.m_root = nodes[0];\n            this.validate();\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */\n        DynamicTree.prototype.shiftOrigin = function (newOrigin) {\n            // Build array of leaves. Free the rest.\n            var node;\n            var it = this.iteratorPool.allocate().preorder(this.m_root);\n            while (node = it.next()) {\n                var aabb = node.aabb;\n                aabb.lowerBound.x -= newOrigin.x;\n                aabb.lowerBound.y -= newOrigin.y;\n                aabb.upperBound.x -= newOrigin.x;\n                aabb.upperBound.y -= newOrigin.y;\n            }\n            this.iteratorPool.release(it);\n        };\n        /**\n         * Query an AABB for overlapping proxies. The callback class is called for each\n         * proxy that overlaps the supplied AABB.\n         */\n        DynamicTree.prototype.query = function (aabb, queryCallback) {\n            var stack = this.stackPool.allocate();\n            stack.push(this.m_root);\n            while (stack.length > 0) {\n                var node = stack.pop();\n                if (node == null) {\n                    continue;\n                }\n                if (AABB.testOverlap(node.aabb, aabb)) {\n                    if (node.isLeaf()) {\n                        var proceed = queryCallback(node.id);\n                        if (proceed === false) {\n                            return;\n                        }\n                    }\n                    else {\n                        stack.push(node.child1);\n                        stack.push(node.child2);\n                    }\n                }\n            }\n            this.stackPool.release(stack);\n        };\n        /**\n         * Ray-cast against the proxies in the tree. This relies on the callback to\n         * perform a exact ray-cast in the case were the proxy contains a shape. The\n         * callback also performs the any collision filtering. This has performance\n         * roughly equal to k * log(n), where k is the number of collisions and n is the\n         * number of proxies in the tree.\n         *\n         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n         */\n        DynamicTree.prototype.rayCast = function (input, rayCastCallback) {\n            var p1 = input.p1;\n            var p2 = input.p2;\n            var r = Vec2.sub(p2, p1);\n            r.normalize();\n            // v is perpendicular to the segment.\n            var v = Vec2.crossNumVec2(1.0, r);\n            var abs_v = Vec2.abs(v);\n            // Separating axis for segment (Gino, p80).\n            // |dot(v, p1 - c)| > dot(|v|, h)\n            var maxFraction = input.maxFraction;\n            // Build a bounding box for the segment.\n            var segmentAABB = new AABB();\n            var t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n            segmentAABB.combinePoints(p1, t);\n            var stack = this.stackPool.allocate();\n            var subInput = this.inputPool.allocate();\n            stack.push(this.m_root);\n            while (stack.length > 0) {\n                var node = stack.pop();\n                if (node == null) {\n                    continue;\n                }\n                if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n                    continue;\n                }\n                // Separating axis for segment (Gino, p80).\n                // |dot(v, p1 - c)| > dot(|v|, h)\n                var c = node.aabb.getCenter();\n                var h = node.aabb.getExtents();\n                var separation = math.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n                if (separation > 0.0) {\n                    continue;\n                }\n                if (node.isLeaf()) {\n                    subInput.p1 = Vec2.clone(input.p1);\n                    subInput.p2 = Vec2.clone(input.p2);\n                    subInput.maxFraction = maxFraction;\n                    var value = rayCastCallback(subInput, node.id);\n                    if (value === 0.0) {\n                        // The client has terminated the ray cast.\n                        return;\n                    }\n                    if (value > 0.0) {\n                        // update segment bounding box.\n                        maxFraction = value;\n                        t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n                        segmentAABB.combinePoints(p1, t);\n                    }\n                }\n                else {\n                    stack.push(node.child1);\n                    stack.push(node.child2);\n                }\n            }\n            this.stackPool.release(stack);\n            this.inputPool.release(subInput);\n        };\n        return DynamicTree;\n    }());\n    var Iterator = /** @class */ (function () {\n        function Iterator() {\n            this.parents = [];\n            this.states = [];\n        }\n        Iterator.prototype.preorder = function (root) {\n            this.parents.length = 0;\n            this.parents.push(root);\n            this.states.length = 0;\n            this.states.push(0);\n            return this;\n        };\n        Iterator.prototype.next = function () {\n            while (this.parents.length > 0) {\n                var i = this.parents.length - 1;\n                var node = this.parents[i];\n                if (this.states[i] === 0) {\n                    this.states[i] = 1;\n                    return node;\n                }\n                if (this.states[i] === 1) {\n                    this.states[i] = 2;\n                    if (node.child1) {\n                        this.parents.push(node.child1);\n                        this.states.push(1);\n                        return node.child1;\n                    }\n                }\n                if (this.states[i] === 2) {\n                    this.states[i] = 3;\n                    if (node.child2) {\n                        this.parents.push(node.child2);\n                        this.states.push(1);\n                        return node.child2;\n                    }\n                }\n                this.parents.pop();\n                this.states.pop();\n            }\n        };\n        Iterator.prototype.close = function () {\n            this.parents.length = 0;\n        };\n        return Iterator;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n     * objects and query them on update.\n     */\n    var BroadPhase = /** @class */ (function () {\n        function BroadPhase() {\n            var _this = this;\n            this.m_tree = new DynamicTree();\n            this.m_proxyCount = 0;\n            this.m_moveBuffer = [];\n            /**\n             * Query an AABB for overlapping proxies. The callback class is called for each\n             * proxy that overlaps the supplied AABB.\n             */\n            this.query = function (aabb, queryCallback) {\n                _this.m_tree.query(aabb, queryCallback);\n            };\n            this.queryCallback = function (proxyId) {\n                // A proxy cannot form a pair with itself.\n                if (proxyId === _this.m_queryProxyId) {\n                    return true;\n                }\n                var proxyIdA = math.min(proxyId, _this.m_queryProxyId);\n                var proxyIdB = math.max(proxyId, _this.m_queryProxyId);\n                // TODO: Skip any duplicate pairs.\n                var userDataA = _this.m_tree.getUserData(proxyIdA);\n                var userDataB = _this.m_tree.getUserData(proxyIdB);\n                // Send the pairs back to the client.\n                _this.m_callback(userDataA, userDataB);\n                return true;\n            };\n        }\n        /**\n         * Get user data from a proxy. Returns null if the id is invalid.\n         */\n        BroadPhase.prototype.getUserData = function (proxyId) {\n            return this.m_tree.getUserData(proxyId);\n        };\n        /**\n         * Test overlap of fat AABBs.\n         */\n        BroadPhase.prototype.testOverlap = function (proxyIdA, proxyIdB) {\n            var aabbA = this.m_tree.getFatAABB(proxyIdA);\n            var aabbB = this.m_tree.getFatAABB(proxyIdB);\n            return AABB.testOverlap(aabbA, aabbB);\n        };\n        /**\n         * Get the fat AABB for a proxy.\n         */\n        BroadPhase.prototype.getFatAABB = function (proxyId) {\n            return this.m_tree.getFatAABB(proxyId);\n        };\n        /**\n         * Get the number of proxies.\n         */\n        BroadPhase.prototype.getProxyCount = function () {\n            return this.m_proxyCount;\n        };\n        /**\n         * Get the height of the embedded tree.\n         */\n        BroadPhase.prototype.getTreeHeight = function () {\n            return this.m_tree.getHeight();\n        };\n        /**\n         * Get the balance (integer) of the embedded tree.\n         */\n        BroadPhase.prototype.getTreeBalance = function () {\n            return this.m_tree.getMaxBalance();\n        };\n        /**\n         * Get the quality metric of the embedded tree.\n         */\n        BroadPhase.prototype.getTreeQuality = function () {\n            return this.m_tree.getAreaRatio();\n        };\n        /**\n         * Ray-cast against the proxies in the tree. This relies on the callback to\n         * perform a exact ray-cast in the case were the proxy contains a shape. The\n         * callback also performs the any collision filtering. This has performance\n         * roughly equal to k * log(n), where k is the number of collisions and n is the\n         * number of proxies in the tree.\n         *\n         * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n         * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n         */\n        BroadPhase.prototype.rayCast = function (input, rayCastCallback) {\n            this.m_tree.rayCast(input, rayCastCallback);\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */\n        BroadPhase.prototype.shiftOrigin = function (newOrigin) {\n            this.m_tree.shiftOrigin(newOrigin);\n        };\n        /**\n         * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n         * is called.\n         */\n        BroadPhase.prototype.createProxy = function (aabb, userData) {\n            var proxyId = this.m_tree.createProxy(aabb, userData);\n            this.m_proxyCount++;\n            this.bufferMove(proxyId);\n            return proxyId;\n        };\n        /**\n         * Destroy a proxy. It is up to the client to remove any pairs.\n         */\n        BroadPhase.prototype.destroyProxy = function (proxyId) {\n            this.unbufferMove(proxyId);\n            this.m_proxyCount--;\n            this.m_tree.destroyProxy(proxyId);\n        };\n        /**\n         * Call moveProxy as many times as you like, then when you are done call\n         * UpdatePairs to finalized the proxy pairs (for your time step).\n         */\n        BroadPhase.prototype.moveProxy = function (proxyId, aabb, displacement) {\n            var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n            if (changed) {\n                this.bufferMove(proxyId);\n            }\n        };\n        /**\n         * Call to trigger a re-processing of it's pairs on the next call to\n         * UpdatePairs.\n         */\n        BroadPhase.prototype.touchProxy = function (proxyId) {\n            this.bufferMove(proxyId);\n        };\n        BroadPhase.prototype.bufferMove = function (proxyId) {\n            this.m_moveBuffer.push(proxyId);\n        };\n        BroadPhase.prototype.unbufferMove = function (proxyId) {\n            for (var i = 0; i < this.m_moveBuffer.length; ++i) {\n                if (this.m_moveBuffer[i] === proxyId) {\n                    this.m_moveBuffer[i] = null;\n                }\n            }\n        };\n        /**\n         * Update the pairs. This results in pair callbacks. This can only add pairs.\n         */\n        BroadPhase.prototype.updatePairs = function (addPairCallback) {\n            this.m_callback = addPairCallback;\n            // Perform tree queries for all moving proxies.\n            while (this.m_moveBuffer.length > 0) {\n                this.m_queryProxyId = this.m_moveBuffer.pop();\n                if (this.m_queryProxyId === null) {\n                    continue;\n                }\n                // We have to query the tree with the fat AABB so that\n                // we don't fail to create a pair that may touch later.\n                var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n                // Query tree, create pairs and add them pair buffer.\n                this.m_tree.query(fatAABB, this.queryCallback);\n            }\n            // Try to keep the tree balanced.\n            // this.m_tree.rebalance(4);\n        };\n        return BroadPhase;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Rot = /** @class */ (function () {\n        /** Initialize from an angle in radians. */\n        function Rot(angle) {\n            if (!(this instanceof Rot)) {\n                return new Rot(angle);\n            }\n            if (typeof angle === 'number') {\n                this.setAngle(angle);\n            }\n            else if (typeof angle === 'object') {\n                this.setRot(angle);\n            }\n            else {\n                this.setIdentity();\n            }\n        }\n        /** @internal */\n        Rot.neo = function (angle) {\n            var obj = Object.create(Rot.prototype);\n            obj.setAngle(angle);\n            return obj;\n        };\n        Rot.clone = function (rot) {\n            var obj = Object.create(Rot.prototype);\n            obj.s = rot.s;\n            obj.c = rot.c;\n            return obj;\n        };\n        Rot.identity = function () {\n            var obj = Object.create(Rot.prototype);\n            obj.s = 0.0;\n            obj.c = 1.0;\n            return obj;\n        };\n        Rot.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return math.isFinite(obj.s) && math.isFinite(obj.c);\n        };\n        Rot.assert = function (o) {\n            return;\n        };\n        /** Set to the identity rotation. */\n        Rot.prototype.setIdentity = function () {\n            this.s = 0.0;\n            this.c = 1.0;\n        };\n        Rot.prototype.set = function (angle) {\n            if (typeof angle === 'object') {\n                this.s = angle.s;\n                this.c = angle.c;\n            }\n            else {\n                // TODO_ERIN optimize\n                this.s = math.sin(angle);\n                this.c = math.cos(angle);\n            }\n        };\n        Rot.prototype.setRot = function (angle) {\n            this.s = angle.s;\n            this.c = angle.c;\n        };\n        /** Set using an angle in radians. */\n        Rot.prototype.setAngle = function (angle) {\n            // TODO_ERIN optimize\n            this.s = math.sin(angle);\n            this.c = math.cos(angle);\n        };\n        /** Get the angle in radians. */\n        Rot.prototype.getAngle = function () {\n            return math.atan2(this.s, this.c);\n        };\n        /** Get the x-axis. */\n        Rot.prototype.getXAxis = function () {\n            return Vec2.neo(this.c, this.s);\n        };\n        /** Get the u-axis. */\n        Rot.prototype.getYAxis = function () {\n            return Vec2.neo(-this.s, this.c);\n        };\n        // tslint:disable-next-line:typedef\n        Rot.mul = function (rot, m) {\n            if ('c' in m && 's' in m) {\n                // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n                // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n                // s = qs * rc + qc * rs\n                // c = qc * rc - qs * rs\n                var qr = Rot.identity();\n                qr.s = rot.s * m.c + rot.c * m.s;\n                qr.c = rot.c * m.c - rot.s * m.s;\n                return qr;\n            }\n            else if ('x' in m && 'y' in m) {\n                return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n            }\n        };\n        /** Multiply two rotations: q * r */\n        Rot.mulRot = function (rot, m) {\n            // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n            // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n            // s = qs * rc + qc * rs\n            // c = qc * rc - qs * rs\n            var qr = Rot.identity();\n            qr.s = rot.s * m.c + rot.c * m.s;\n            qr.c = rot.c * m.c - rot.s * m.s;\n            return qr;\n        };\n        /** Rotate a vector */\n        Rot.mulVec2 = function (rot, m) {\n            return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n        };\n        Rot.mulSub = function (rot, v, w) {\n            var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n            var y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n            return Vec2.neo(x, y);\n        };\n        // tslint:disable-next-line:typedef\n        Rot.mulT = function (rot, m) {\n            if ('c' in m && 's' in m) {\n                // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n                // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n                // s = qc * rs - qs * rc\n                // c = qc * rc + qs * rs\n                var qr = Rot.identity();\n                qr.s = rot.c * m.s - rot.s * m.c;\n                qr.c = rot.c * m.c + rot.s * m.s;\n                return qr;\n            }\n            else if ('x' in m && 'y' in m) {\n                return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n            }\n        };\n        /** Transpose multiply two rotations: qT * r */\n        Rot.mulTRot = function (rot, m) {\n            // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n            // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n            // s = qc * rs - qs * rc\n            // c = qc * rc + qs * rs\n            var qr = Rot.identity();\n            qr.s = rot.c * m.s - rot.s * m.c;\n            qr.c = rot.c * m.c + rot.s * m.s;\n            return qr;\n        };\n        /** Inverse rotate a vector */\n        Rot.mulTVec2 = function (rot, m) {\n            return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n        };\n        return Rot;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A transform contains translation and rotation. It is used to represent the\n     * position and orientation of rigid frames. Initialize using a position vector\n     * and a rotation.\n     */\n    var Transform = /** @class */ (function () {\n        function Transform(position, rotation) {\n            if (!(this instanceof Transform)) {\n                return new Transform(position, rotation);\n            }\n            this.p = Vec2.zero();\n            this.q = Rot.identity();\n            if (typeof position !== 'undefined') {\n                this.p.setVec2(position);\n            }\n            if (typeof rotation !== 'undefined') {\n                this.q.setAngle(rotation);\n            }\n        }\n        Transform.clone = function (xf) {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.clone(xf.p);\n            obj.q = Rot.clone(xf.q);\n            return obj;\n        };\n        /** @internal */\n        Transform.neo = function (position, rotation) {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.clone(position);\n            obj.q = Rot.clone(rotation);\n            return obj;\n        };\n        Transform.identity = function () {\n            var obj = Object.create(Transform.prototype);\n            obj.p = Vec2.zero();\n            obj.q = Rot.identity();\n            return obj;\n        };\n        /**\n         * Set this to the identity transform.\n         */\n        Transform.prototype.setIdentity = function () {\n            this.p.setZero();\n            this.q.setIdentity();\n        };\n        /**\n         * Set this based on the position and angle.\n         */\n        // tslint:disable-next-line:typedef\n        Transform.prototype.set = function (a, b) {\n            if (typeof b === 'undefined') {\n                this.p.set(a.p);\n                this.q.set(a.q);\n            }\n            else {\n                this.p.set(a);\n                this.q.set(b);\n            }\n        };\n        /**\n         * Set this based on the position and angle.\n         */\n        Transform.prototype.setNum = function (position, rotation) {\n            this.p.setVec2(position);\n            this.q.setAngle(rotation);\n        };\n        Transform.prototype.setTransform = function (xf) {\n            this.p.setVec2(xf.p);\n            this.q.setRot(xf.q);\n        };\n        Transform.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n        };\n        Transform.assert = function (o) {\n            return;\n        };\n        // static mul(a: Transform, b: Vec2[]): Vec2[];\n        // static mul(a: Transform, b: Transform[]): Transform[];\n        // tslint:disable-next-line:typedef\n        Transform.mul = function (a, b) {\n            if (Array.isArray(b)) {\n                var arr = [];\n                for (var i = 0; i < b.length; i++) {\n                    arr[i] = Transform.mul(a, b[i]);\n                }\n                return arr;\n            }\n            else if ('x' in b && 'y' in b) {\n                return Transform.mulVec2(a, b);\n            }\n            else if ('p' in b && 'q' in b) {\n                return Transform.mulXf(a, b);\n            }\n        };\n        // tslint:disable-next-line:typedef\n        Transform.mulAll = function (a, b) {\n            var arr = [];\n            for (var i = 0; i < b.length; i++) {\n                arr[i] = Transform.mul(a, b[i]);\n            }\n            return arr;\n        };\n        /** @internal @deprecated */\n        // tslint:disable-next-line:typedef\n        Transform.mulFn = function (a) {\n            return function (b) {\n                return Transform.mul(a, b);\n            };\n        };\n        Transform.mulVec2 = function (a, b) {\n            var x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;\n            var y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;\n            return Vec2.neo(x, y);\n        };\n        Transform.mulXf = function (a, b) {\n            // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n            // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n            var xf = Transform.identity();\n            xf.q = Rot.mulRot(a.q, b.q);\n            xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n            return xf;\n        };\n        // tslint:disable-next-line:typedef\n        Transform.mulT = function (a, b) {\n            if ('x' in b && 'y' in b) {\n                return Transform.mulTVec2(a, b);\n            }\n            else if ('p' in b && 'q' in b) {\n                return Transform.mulTXf(a, b);\n            }\n        };\n        Transform.mulTVec2 = function (a, b) {\n            var px = b.x - a.p.x;\n            var py = b.y - a.p.y;\n            var x = (a.q.c * px + a.q.s * py);\n            var y = (-a.q.s * px + a.q.c * py);\n            return Vec2.neo(x, y);\n        };\n        Transform.mulTXf = function (a, b) {\n            // v2 = A.q' * (B.q * v1 + B.p - A.p)\n            // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n            var xf = Transform.identity();\n            xf.q.setRot(Rot.mulTRot(a.q, b.q));\n            xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n            return xf;\n        };\n        return Transform;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * This describes the motion of a body/shape for TOI computation. Shapes are\n     * defined with respect to the body origin, which may not coincide with the\n     * center of mass. However, to support dynamics we must interpolate the center\n     * of mass position.\n     */\n    var Sweep = /** @class */ (function () {\n        function Sweep(c, a) {\n            this.localCenter = Vec2.zero();\n            this.c = Vec2.zero();\n            this.a = 0;\n            this.alpha0 = 0;\n            this.c0 = Vec2.zero();\n            this.a0 = 0;\n        }\n        Sweep.prototype.setTransform = function (xf) {\n            var c = Transform.mulVec2(xf, this.localCenter);\n            this.c.setVec2(c);\n            this.c0.setVec2(c);\n            this.a = xf.q.getAngle();\n            this.a0 = xf.q.getAngle();\n        };\n        Sweep.prototype.setLocalCenter = function (localCenter, xf) {\n            this.localCenter.setVec2(localCenter);\n            var c = Transform.mulVec2(xf, this.localCenter);\n            this.c.setVec2(c);\n            this.c0.setVec2(c);\n        };\n        /**\n         * Get the interpolated transform at a specific time.\n         *\n         * @param xf\n         * @param beta A factor in [0,1], where 0 indicates alpha0\n         */\n        Sweep.prototype.getTransform = function (xf, beta) {\n            if (beta === void 0) { beta = 0; }\n            xf.q.setAngle((1.0 - beta) * this.a0 + beta * this.a);\n            xf.p.setCombine((1.0 - beta), this.c0, beta, this.c);\n            // shift to origin\n            xf.p.sub(Rot.mulVec2(xf.q, this.localCenter));\n        };\n        /**\n         * Advance the sweep forward, yielding a new initial state.\n         *\n         * @param alpha The new initial time\n         */\n        Sweep.prototype.advance = function (alpha) {\n            var beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n            this.c0.setCombine(beta, this.c, 1 - beta, this.c0);\n            this.a0 = beta * this.a + (1 - beta) * this.a0;\n            this.alpha0 = alpha;\n        };\n        Sweep.prototype.forward = function () {\n            this.a0 = this.a;\n            this.c0.setVec2(this.c);\n        };\n        /**\n         * normalize the angles in radians to be between -pi and pi.\n         */\n        Sweep.prototype.normalize = function () {\n            var a0 = math.mod(this.a0, -math.PI, +math.PI);\n            this.a -= this.a0 - a0;\n            this.a0 = a0;\n        };\n        Sweep.prototype.clone = function () {\n            var clone = new Sweep();\n            clone.localCenter.setVec2(this.localCenter);\n            clone.alpha0 = this.alpha0;\n            clone.a0 = this.a0;\n            clone.a = this.a;\n            clone.c0.setVec2(this.c0);\n            clone.c.setVec2(this.c);\n            return clone;\n        };\n        Sweep.prototype.set = function (that) {\n            this.localCenter.setVec2(that.localCenter);\n            this.alpha0 = that.alpha0;\n            this.a0 = that.a0;\n            this.a = that.a;\n            this.c0.setVec2(that.c0);\n            this.c.setVec2(that.c);\n        };\n        return Sweep;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Velocity = /** @class */ (function () {\n        function Velocity() {\n            this.v = Vec2.zero();\n            this.w = 0;\n        }\n        return Velocity;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Position = /** @class */ (function () {\n        function Position() {\n            this.c = Vec2.zero();\n            this.a = 0;\n        }\n        Position.prototype.getTransform = function (xf, p) {\n            xf.q.setAngle(this.a);\n            xf.p.setVec2(Vec2.sub(this.c, Rot.mulVec2(xf.q, p)));\n            return xf;\n        };\n        return Position;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A shape is used for collision detection. You can create a shape however you\n     * like. Shapes used for simulation in World are created automatically when a\n     * Fixture is created. Shapes may encapsulate one or more child shapes.\n     */\n    var Shape = /** @class */ (function () {\n        function Shape() {\n        }\n        /** @internal */\n        Shape.prototype._reset = function () {\n        };\n        Shape.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';\n        };\n        Shape.prototype.getRadius = function () {\n            return this.m_radius;\n        };\n        /**\n         * Get the type of this shape. You can use this to down cast to the concrete\n         * shape.\n         *\n         * @return the shape type.\n         */\n        Shape.prototype.getType = function () {\n            return this.m_type;\n        };\n        return Shape;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var FixtureDefDefault = {\n        userData: null,\n        friction: 0.2,\n        restitution: 0.0,\n        density: 0.0,\n        isSensor: false,\n        filterGroupIndex: 0,\n        filterCategoryBits: 0x0001,\n        filterMaskBits: 0xFFFF\n    };\n    /**\n     * This proxy is used internally to connect shape children to the broad-phase.\n     */\n    var FixtureProxy = /** @class */ (function () {\n        function FixtureProxy(fixture, childIndex) {\n            this.aabb = new AABB();\n            this.fixture = fixture;\n            this.childIndex = childIndex;\n            this.proxyId;\n        }\n        return FixtureProxy;\n    }());\n    /**\n     * A fixture is used to attach a shape to a body for collision detection. A\n     * fixture inherits its transform from its parent. Fixtures hold additional\n     * non-geometric data such as friction, collision filters, etc.\n     *\n     * To create a new Fixture use {@link Body.createFixture}.\n     */\n    var Fixture = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        /** @internal */ function Fixture(body, shape, def) {\n            if (shape.shape) {\n                def = shape;\n                shape = shape.shape;\n            }\n            else if (typeof def === 'number') {\n                def = { density: def };\n            }\n            def = options(def, FixtureDefDefault);\n            this.m_body = body;\n            this.m_friction = def.friction;\n            this.m_restitution = def.restitution;\n            this.m_density = def.density;\n            this.m_isSensor = def.isSensor;\n            this.m_filterGroupIndex = def.filterGroupIndex;\n            this.m_filterCategoryBits = def.filterCategoryBits;\n            this.m_filterMaskBits = def.filterMaskBits;\n            // TODO validate shape\n            this.m_shape = shape; // .clone();\n            this.m_next = null;\n            this.m_proxies = [];\n            this.m_proxyCount = 0;\n            var childCount = this.m_shape.getChildCount();\n            for (var i = 0; i < childCount; ++i) {\n                this.m_proxies[i] = new FixtureProxy(this, i);\n            }\n            this.m_userData = def.userData;\n        }\n        /**\n         * Re-setup fixture.\n         * @internal\n         */\n        Fixture.prototype._reset = function () {\n            var body = this.getBody();\n            var broadPhase = body.m_world.m_broadPhase;\n            this.destroyProxies(broadPhase);\n            if (this.m_shape._reset) {\n                this.m_shape._reset();\n            }\n            var childCount = this.m_shape.getChildCount();\n            for (var i = 0; i < childCount; ++i) {\n                this.m_proxies[i] = new FixtureProxy(this, i);\n            }\n            this.createProxies(broadPhase, body.m_xf);\n            body.resetMassData();\n        };\n        /** @internal */\n        Fixture.prototype._serialize = function () {\n            return {\n                friction: this.m_friction,\n                restitution: this.m_restitution,\n                density: this.m_density,\n                isSensor: this.m_isSensor,\n                filterGroupIndex: this.m_filterGroupIndex,\n                filterCategoryBits: this.m_filterCategoryBits,\n                filterMaskBits: this.m_filterMaskBits,\n                shape: this.m_shape,\n            };\n        };\n        /** @internal */\n        Fixture._deserialize = function (data, body, restore) {\n            var shape = restore(Shape, data.shape);\n            var fixture = shape && new Fixture(body, shape, data);\n            return fixture;\n        };\n        /**\n         * Get the type of the child shape. You can use this to down cast to the\n         * concrete shape.\n         */\n        Fixture.prototype.getType = function () {\n            return this.m_shape.getType();\n        };\n        /**\n         * Get the child shape. You can modify the child shape, however you should not\n         * change the number of vertices because this will crash some collision caching\n         * mechanisms. Manipulating the shape may lead to non-physical behavior.\n         */\n        Fixture.prototype.getShape = function () {\n            return this.m_shape;\n        };\n        /**\n         * A sensor shape collects contact information but never generates a collision\n         * response.\n         */\n        Fixture.prototype.isSensor = function () {\n            return this.m_isSensor;\n        };\n        /**\n         * Set if this fixture is a sensor.\n         */\n        Fixture.prototype.setSensor = function (sensor) {\n            if (sensor != this.m_isSensor) {\n                this.m_body.setAwake(true);\n                this.m_isSensor = sensor;\n            }\n        };\n        // /**\n        //  * Get the contact filtering data.\n        //  */\n        // getFilterData() {\n        //   return this.m_filter;\n        // }\n        /**\n         * Get the user data that was assigned in the fixture definition. Use this to\n         * store your application specific data.\n         */\n        Fixture.prototype.getUserData = function () {\n            return this.m_userData;\n        };\n        /**\n         * Set the user data. Use this to store your application specific data.\n         */\n        Fixture.prototype.setUserData = function (data) {\n            this.m_userData = data;\n        };\n        /**\n         * Get the parent body of this fixture. This is null if the fixture is not\n         * attached.\n         */\n        Fixture.prototype.getBody = function () {\n            return this.m_body;\n        };\n        /**\n         * Get the next fixture in the parent body's fixture list.\n         */\n        Fixture.prototype.getNext = function () {\n            return this.m_next;\n        };\n        /**\n         * Get the density of this fixture.\n         */\n        Fixture.prototype.getDensity = function () {\n            return this.m_density;\n        };\n        /**\n         * Set the density of this fixture. This will _not_ automatically adjust the\n         * mass of the body. You must call Body.resetMassData to update the body's mass.\n         */\n        Fixture.prototype.setDensity = function (density) {\n            this.m_density = density;\n        };\n        /**\n         * Get the coefficient of friction, usually in the range [0,1].\n         */\n        Fixture.prototype.getFriction = function () {\n            return this.m_friction;\n        };\n        /**\n         * Set the coefficient of friction. This will not change the friction of\n         * existing contacts.\n         */\n        Fixture.prototype.setFriction = function (friction) {\n            this.m_friction = friction;\n        };\n        /**\n         * Get the coefficient of restitution.\n         */\n        Fixture.prototype.getRestitution = function () {\n            return this.m_restitution;\n        };\n        /**\n         * Set the coefficient of restitution. This will not change the restitution of\n         * existing contacts.\n         */\n        Fixture.prototype.setRestitution = function (restitution) {\n            this.m_restitution = restitution;\n        };\n        /**\n         * Test a point in world coordinates for containment in this fixture.\n         */\n        Fixture.prototype.testPoint = function (p) {\n            return this.m_shape.testPoint(this.m_body.getTransform(), p);\n        };\n        /**\n         * Cast a ray against this shape.\n         */\n        Fixture.prototype.rayCast = function (output, input, childIndex) {\n            return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n        };\n        /**\n         * Get the mass data for this fixture. The mass data is based on the density and\n         * the shape. The rotational inertia is about the shape's origin. This operation\n         * may be expensive.\n         */\n        Fixture.prototype.getMassData = function (massData) {\n            this.m_shape.computeMass(massData, this.m_density);\n        };\n        /**\n         * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n         * more accurate AABB, compute it using the shape and the body transform.\n         */\n        Fixture.prototype.getAABB = function (childIndex) {\n            return this.m_proxies[childIndex].aabb;\n        };\n        /**\n         * These support body activation/deactivation.\n         */\n        Fixture.prototype.createProxies = function (broadPhase, xf) {\n            // Create proxies in the broad-phase.\n            this.m_proxyCount = this.m_shape.getChildCount();\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                var proxy = this.m_proxies[i];\n                this.m_shape.computeAABB(proxy.aabb, xf, i);\n                proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n            }\n        };\n        Fixture.prototype.destroyProxies = function (broadPhase) {\n            // Destroy proxies in the broad-phase.\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                var proxy = this.m_proxies[i];\n                broadPhase.destroyProxy(proxy.proxyId);\n                proxy.proxyId = null;\n            }\n            this.m_proxyCount = 0;\n        };\n        /**\n         * Updates this fixture proxy in broad-phase (with combined AABB of current and\n         * next transformation).\n         */\n        Fixture.prototype.synchronize = function (broadPhase, xf1, xf2) {\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                var proxy = this.m_proxies[i];\n                // Compute an AABB that covers the swept shape (may miss some rotation\n                // effect).\n                var aabb1 = new AABB();\n                var aabb2 = new AABB();\n                this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);\n                this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);\n                proxy.aabb.combine(aabb1, aabb2);\n                var displacement = Vec2.sub(xf2.p, xf1.p);\n                broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n            }\n        };\n        /**\n         * Set the contact filtering data. This will not update contacts until the next\n         * time step when either parent body is active and awake. This automatically\n         * calls refilter.\n         */\n        Fixture.prototype.setFilterData = function (filter) {\n            this.m_filterGroupIndex = filter.groupIndex;\n            this.m_filterCategoryBits = filter.categoryBits;\n            this.m_filterMaskBits = filter.maskBits;\n            this.refilter();\n        };\n        Fixture.prototype.getFilterGroupIndex = function () {\n            return this.m_filterGroupIndex;\n        };\n        Fixture.prototype.setFilterGroupIndex = function (groupIndex) {\n            this.m_filterGroupIndex = groupIndex;\n        };\n        Fixture.prototype.getFilterCategoryBits = function () {\n            return this.m_filterCategoryBits;\n        };\n        Fixture.prototype.setFilterCategoryBits = function (categoryBits) {\n            this.m_filterCategoryBits = categoryBits;\n        };\n        Fixture.prototype.getFilterMaskBits = function () {\n            return this.m_filterMaskBits;\n        };\n        Fixture.prototype.setFilterMaskBits = function (maskBits) {\n            this.m_filterMaskBits = maskBits;\n        };\n        /**\n         * Call this if you want to establish collision that was previously disabled by\n         * ContactFilter.\n         */\n        Fixture.prototype.refilter = function () {\n            if (this.m_body == null) {\n                return;\n            }\n            // Flag associated contacts for filtering.\n            var edge = this.m_body.getContactList();\n            while (edge) {\n                var contact = edge.contact;\n                var fixtureA = contact.getFixtureA();\n                var fixtureB = contact.getFixtureB();\n                if (fixtureA == this || fixtureB == this) {\n                    contact.flagForFiltering();\n                }\n                edge = edge.next;\n            }\n            var world = this.m_body.getWorld();\n            if (world == null) {\n                return;\n            }\n            // Touch each proxy so that new pairs may be created\n            var broadPhase = world.m_broadPhase;\n            for (var i = 0; i < this.m_proxyCount; ++i) {\n                broadPhase.touchProxy(this.m_proxies[i].proxyId);\n            }\n        };\n        /**\n         * Implement this method to provide collision filtering, if you want finer\n         * control over contact creation.\n         *\n         * Return true if contact calculations should be performed between these two\n         * fixtures.\n         *\n         * Warning: for performance reasons this is only called when the AABBs begin to\n         * overlap.\n         */\n        Fixture.prototype.shouldCollide = function (that) {\n            if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n                return that.m_filterGroupIndex > 0;\n            }\n            var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n            var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n            var collide = collideA && collideB;\n            return collide;\n        };\n        return Fixture;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var STATIC = 'static';\n    var KINEMATIC = 'kinematic';\n    var DYNAMIC = 'dynamic';\n    var BodyDefDefault = {\n        type: STATIC,\n        position: Vec2.zero(),\n        angle: 0.0,\n        linearVelocity: Vec2.zero(),\n        angularVelocity: 0.0,\n        linearDamping: 0.0,\n        angularDamping: 0.0,\n        fixedRotation: false,\n        bullet: false,\n        gravityScale: 1.0,\n        allowSleep: true,\n        awake: true,\n        active: true,\n        userData: null\n    };\n    /**\n     * MassData This holds the mass data computed for a shape.\n     */\n    var MassData = /** @class */ (function () {\n        function MassData() {\n            /** The mass of the shape, usually in kilograms. */\n            this.mass = 0;\n            /** The position of the shape's centroid relative to the shape's origin. */\n            this.center = Vec2.zero();\n            /** The rotational inertia of the shape about the local origin. */\n            this.I = 0;\n        }\n        return MassData;\n    }());\n    /**\n     * A rigid body composed of one or more fixtures.\n     *\n     * To create a new Body use {@link World.createBody}.\n     */\n    var Body = /** @class */ (function () {\n        /** @internal */\n        function Body(world, def) {\n            def = options(def, BodyDefDefault);\n            this.m_world = world;\n            this.m_awakeFlag = def.awake;\n            this.m_autoSleepFlag = def.allowSleep;\n            this.m_bulletFlag = def.bullet;\n            this.m_fixedRotationFlag = def.fixedRotation;\n            this.m_activeFlag = def.active;\n            this.m_islandFlag = false;\n            this.m_toiFlag = false;\n            this.m_userData = def.userData;\n            this.m_type = def.type;\n            if (this.m_type == DYNAMIC) {\n                this.m_mass = 1.0;\n                this.m_invMass = 1.0;\n            }\n            else {\n                this.m_mass = 0.0;\n                this.m_invMass = 0.0;\n            }\n            // Rotational inertia about the center of mass.\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            // the body origin transform\n            this.m_xf = Transform.identity();\n            this.m_xf.p = Vec2.clone(def.position);\n            this.m_xf.q.setAngle(def.angle);\n            // the swept motion for CCD\n            this.m_sweep = new Sweep();\n            this.m_sweep.setTransform(this.m_xf);\n            // position and velocity correction\n            this.c_velocity = new Velocity();\n            this.c_position = new Position();\n            this.m_force = Vec2.zero();\n            this.m_torque = 0.0;\n            this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n            this.m_angularVelocity = def.angularVelocity;\n            this.m_linearDamping = def.linearDamping;\n            this.m_angularDamping = def.angularDamping;\n            this.m_gravityScale = def.gravityScale;\n            this.m_sleepTime = 0.0;\n            this.m_jointList = null;\n            this.m_contactList = null;\n            this.m_fixtureList = null;\n            this.m_prev = null;\n            this.m_next = null;\n            this.m_destroyed = false;\n        }\n        /** @internal */\n        Body.prototype._serialize = function () {\n            var fixtures = [];\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                fixtures.push(f);\n            }\n            return {\n                type: this.m_type,\n                bullet: this.m_bulletFlag,\n                position: this.m_xf.p,\n                angle: this.m_xf.q.getAngle(),\n                linearVelocity: this.m_linearVelocity,\n                angularVelocity: this.m_angularVelocity,\n                fixtures: fixtures,\n            };\n        };\n        /** @internal */\n        Body._deserialize = function (data, world, restore) {\n            var body = new Body(world, data);\n            if (data.fixtures) {\n                for (var i = data.fixtures.length - 1; i >= 0; i--) {\n                    var fixture = restore(Fixture, data.fixtures[i], body);\n                    body._addFixture(fixture);\n                }\n            }\n            return body;\n        };\n        Body.prototype.isWorldLocked = function () {\n            return this.m_world && this.m_world.isLocked() ? true : false;\n        };\n        Body.prototype.getWorld = function () {\n            return this.m_world;\n        };\n        Body.prototype.getNext = function () {\n            return this.m_next;\n        };\n        Body.prototype.setUserData = function (data) {\n            this.m_userData = data;\n        };\n        Body.prototype.getUserData = function () {\n            return this.m_userData;\n        };\n        Body.prototype.getFixtureList = function () {\n            return this.m_fixtureList;\n        };\n        Body.prototype.getJointList = function () {\n            return this.m_jointList;\n        };\n        /**\n         * Warning: this list changes during the time step and you may miss some\n         * collisions if you don't use ContactListener.\n         */\n        Body.prototype.getContactList = function () {\n            return this.m_contactList;\n        };\n        Body.prototype.isStatic = function () {\n            return this.m_type == STATIC;\n        };\n        Body.prototype.isDynamic = function () {\n            return this.m_type == DYNAMIC;\n        };\n        Body.prototype.isKinematic = function () {\n            return this.m_type == KINEMATIC;\n        };\n        /**\n         * This will alter the mass and velocity.\n         */\n        Body.prototype.setStatic = function () {\n            this.setType(STATIC);\n            return this;\n        };\n        Body.prototype.setDynamic = function () {\n            this.setType(DYNAMIC);\n            return this;\n        };\n        Body.prototype.setKinematic = function () {\n            this.setType(KINEMATIC);\n            return this;\n        };\n        /**\n         * @internal\n         */\n        Body.prototype.getType = function () {\n            return this.m_type;\n        };\n        /**\n         * @internal\n         */\n        Body.prototype.setType = function (type) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            if (this.m_type == type) {\n                return;\n            }\n            this.m_type = type;\n            this.resetMassData();\n            if (this.m_type == STATIC) {\n                this.m_linearVelocity.setZero();\n                this.m_angularVelocity = 0.0;\n                this.m_sweep.forward();\n                this.synchronizeFixtures();\n            }\n            this.setAwake(true);\n            this.m_force.setZero();\n            this.m_torque = 0.0;\n            // Delete the attached contacts.\n            var ce = this.m_contactList;\n            while (ce) {\n                var ce0 = ce;\n                ce = ce.next;\n                this.m_world.destroyContact(ce0.contact);\n            }\n            this.m_contactList = null;\n            // Touch the proxies so that new contacts will be created (when appropriate)\n            var broadPhase = this.m_world.m_broadPhase;\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                var proxyCount = f.m_proxyCount;\n                for (var i = 0; i < proxyCount; ++i) {\n                    broadPhase.touchProxy(f.m_proxies[i].proxyId);\n                }\n            }\n        };\n        Body.prototype.isBullet = function () {\n            return this.m_bulletFlag;\n        };\n        /**\n         * Should this body be treated like a bullet for continuous collision detection?\n         */\n        Body.prototype.setBullet = function (flag) {\n            this.m_bulletFlag = !!flag;\n        };\n        Body.prototype.isSleepingAllowed = function () {\n            return this.m_autoSleepFlag;\n        };\n        Body.prototype.setSleepingAllowed = function (flag) {\n            this.m_autoSleepFlag = !!flag;\n            if (this.m_autoSleepFlag == false) {\n                this.setAwake(true);\n            }\n        };\n        Body.prototype.isAwake = function () {\n            return this.m_awakeFlag;\n        };\n        /**\n         * Set the sleep state of the body. A sleeping body has very low CPU cost.\n         *\n         * @param flag Set to true to wake the body, false to put it to sleep.\n         */\n        Body.prototype.setAwake = function (flag) {\n            if (flag) {\n                if (this.m_awakeFlag == false) {\n                    this.m_awakeFlag = true;\n                    this.m_sleepTime = 0.0;\n                }\n            }\n            else {\n                this.m_awakeFlag = false;\n                this.m_sleepTime = 0.0;\n                this.m_linearVelocity.setZero();\n                this.m_angularVelocity = 0.0;\n                this.m_force.setZero();\n                this.m_torque = 0.0;\n            }\n        };\n        Body.prototype.isActive = function () {\n            return this.m_activeFlag;\n        };\n        /**\n         * Set the active state of the body. An inactive body is not simulated and\n         * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n         * will be added to the broad-phase. If you pass a flag of false, all fixtures\n         * will be removed from the broad-phase and all contacts will be destroyed.\n         * Fixtures and joints are otherwise unaffected.\n         *\n         * You may continue to create/destroy fixtures and joints on inactive bodies.\n         * Fixtures on an inactive body are implicitly inactive and will not participate\n         * in collisions, ray-casts, or queries. Joints connected to an inactive body\n         * are implicitly inactive. An inactive body is still owned by a World object\n         * and remains\n         */\n        Body.prototype.setActive = function (flag) {\n            if (flag == this.m_activeFlag) {\n                return;\n            }\n            this.m_activeFlag = !!flag;\n            if (this.m_activeFlag) {\n                // Create all proxies.\n                var broadPhase = this.m_world.m_broadPhase;\n                for (var f = this.m_fixtureList; f; f = f.m_next) {\n                    f.createProxies(broadPhase, this.m_xf);\n                }\n                // Contacts are created the next time step.\n            }\n            else {\n                // Destroy all proxies.\n                var broadPhase = this.m_world.m_broadPhase;\n                for (var f = this.m_fixtureList; f; f = f.m_next) {\n                    f.destroyProxies(broadPhase);\n                }\n                // Destroy the attached contacts.\n                var ce = this.m_contactList;\n                while (ce) {\n                    var ce0 = ce;\n                    ce = ce.next;\n                    this.m_world.destroyContact(ce0.contact);\n                }\n                this.m_contactList = null;\n            }\n        };\n        Body.prototype.isFixedRotation = function () {\n            return this.m_fixedRotationFlag;\n        };\n        /**\n         * Set this body to have fixed rotation. This causes the mass to be reset.\n         */\n        Body.prototype.setFixedRotation = function (flag) {\n            if (this.m_fixedRotationFlag == flag) {\n                return;\n            }\n            this.m_fixedRotationFlag = !!flag;\n            this.m_angularVelocity = 0.0;\n            this.resetMassData();\n        };\n        /**\n         * Get the world transform for the body's origin.\n         */\n        Body.prototype.getTransform = function () {\n            return this.m_xf;\n        };\n        /**\n         * Set the position of the body's origin and rotation. Manipulating a body's\n         * transform may cause non-physical behavior. Note: contacts are updated on the\n         * next call to World.step.\n         *\n         * @param position The world position of the body's local origin.\n         * @param angle The world rotation in radians.\n         */\n        Body.prototype.setTransform = function (position, angle) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            this.m_xf.setNum(position, angle);\n            this.m_sweep.setTransform(this.m_xf);\n            var broadPhase = this.m_world.m_broadPhase;\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                f.synchronize(broadPhase, this.m_xf, this.m_xf);\n            }\n        };\n        Body.prototype.synchronizeTransform = function () {\n            this.m_sweep.getTransform(this.m_xf, 1);\n        };\n        /**\n         * Update fixtures in broad-phase.\n         */\n        Body.prototype.synchronizeFixtures = function () {\n            var xf = Transform.identity();\n            this.m_sweep.getTransform(xf, 0);\n            var broadPhase = this.m_world.m_broadPhase;\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                f.synchronize(broadPhase, xf, this.m_xf);\n            }\n        };\n        /**\n         * Used in TOI.\n         */\n        Body.prototype.advance = function (alpha) {\n            // Advance to the new safe time. This doesn't sync the broad-phase.\n            this.m_sweep.advance(alpha);\n            this.m_sweep.c.setVec2(this.m_sweep.c0);\n            this.m_sweep.a = this.m_sweep.a0;\n            this.m_sweep.getTransform(this.m_xf, 1);\n        };\n        /**\n         * Get the world position for the body's origin.\n         */\n        Body.prototype.getPosition = function () {\n            return this.m_xf.p;\n        };\n        Body.prototype.setPosition = function (p) {\n            this.setTransform(p, this.m_sweep.a);\n        };\n        /**\n         * Get the current world rotation angle in radians.\n         */\n        Body.prototype.getAngle = function () {\n            return this.m_sweep.a;\n        };\n        Body.prototype.setAngle = function (angle) {\n            this.setTransform(this.m_xf.p, angle);\n        };\n        /**\n         * Get the world position of the center of mass.\n         */\n        Body.prototype.getWorldCenter = function () {\n            return this.m_sweep.c;\n        };\n        /**\n         * Get the local position of the center of mass.\n         */\n        Body.prototype.getLocalCenter = function () {\n            return this.m_sweep.localCenter;\n        };\n        /**\n         * Get the linear velocity of the center of mass.\n         *\n         * @return the linear velocity of the center of mass.\n         */\n        Body.prototype.getLinearVelocity = function () {\n            return this.m_linearVelocity;\n        };\n        /**\n         * Get the world linear velocity of a world point attached to this body.\n         *\n         * @param worldPoint A point in world coordinates.\n         */\n        Body.prototype.getLinearVelocityFromWorldPoint = function (worldPoint) {\n            var localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n            return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity, localCenter));\n        };\n        /**\n         * Get the world velocity of a local point.\n         *\n         * @param localPoint A point in local coordinates.\n         */\n        Body.prototype.getLinearVelocityFromLocalPoint = function (localPoint) {\n            return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n        };\n        /**\n         * Set the linear velocity of the center of mass.\n         *\n         * @param v The new linear velocity of the center of mass.\n         */\n        Body.prototype.setLinearVelocity = function (v) {\n            if (this.m_type == STATIC) {\n                return;\n            }\n            if (Vec2.dot(v, v) > 0.0) {\n                this.setAwake(true);\n            }\n            this.m_linearVelocity.setVec2(v);\n        };\n        /**\n         * Get the angular velocity.\n         *\n         * @returns the angular velocity in radians/second.\n         */\n        Body.prototype.getAngularVelocity = function () {\n            return this.m_angularVelocity;\n        };\n        /**\n         * Set the angular velocity.\n         *\n         * @param omega The new angular velocity in radians/second.\n         */\n        Body.prototype.setAngularVelocity = function (w) {\n            if (this.m_type == STATIC) {\n                return;\n            }\n            if (w * w > 0.0) {\n                this.setAwake(true);\n            }\n            this.m_angularVelocity = w;\n        };\n        Body.prototype.getLinearDamping = function () {\n            return this.m_linearDamping;\n        };\n        Body.prototype.setLinearDamping = function (linearDamping) {\n            this.m_linearDamping = linearDamping;\n        };\n        Body.prototype.getAngularDamping = function () {\n            return this.m_angularDamping;\n        };\n        Body.prototype.setAngularDamping = function (angularDamping) {\n            this.m_angularDamping = angularDamping;\n        };\n        Body.prototype.getGravityScale = function () {\n            return this.m_gravityScale;\n        };\n        /**\n         * Scale the gravity applied to this body.\n         */\n        Body.prototype.setGravityScale = function (scale) {\n            this.m_gravityScale = scale;\n        };\n        /**\n         * Get the total mass of the body.\n         *\n         * @returns The mass, usually in kilograms (kg).\n         */\n        Body.prototype.getMass = function () {\n            return this.m_mass;\n        };\n        /**\n         * Get the rotational inertia of the body about the local origin.\n         *\n         * @return the rotational inertia, usually in kg-m^2.\n         */\n        Body.prototype.getInertia = function () {\n            return this.m_I + this.m_mass\n                * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n        };\n        /**\n         * Copy the mass data of the body to data.\n         */\n        Body.prototype.getMassData = function (data) {\n            data.mass = this.m_mass;\n            data.I = this.getInertia();\n            data.center.setVec2(this.m_sweep.localCenter);\n        };\n        /**\n         * This resets the mass properties to the sum of the mass properties of the\n         * fixtures. This normally does not need to be called unless you called\n         * SetMassData to override the mass and you later want to reset the mass.\n         */\n        Body.prototype.resetMassData = function () {\n            // Compute mass data from shapes. Each shape has its own density.\n            this.m_mass = 0.0;\n            this.m_invMass = 0.0;\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            this.m_sweep.localCenter.setZero();\n            // Static and kinematic bodies have zero mass.\n            if (this.isStatic() || this.isKinematic()) {\n                this.m_sweep.c0.setVec2(this.m_xf.p);\n                this.m_sweep.c.setVec2(this.m_xf.p);\n                this.m_sweep.a0 = this.m_sweep.a;\n                return;\n            }\n            // Accumulate mass over all fixtures.\n            var localCenter = Vec2.zero();\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\n                if (f.m_density == 0.0) {\n                    continue;\n                }\n                var massData = new MassData();\n                f.getMassData(massData);\n                this.m_mass += massData.mass;\n                localCenter.addMul(massData.mass, massData.center);\n                this.m_I += massData.I;\n            }\n            // Compute center of mass.\n            if (this.m_mass > 0.0) {\n                this.m_invMass = 1.0 / this.m_mass;\n                localCenter.mul(this.m_invMass);\n            }\n            else {\n                // Force all dynamic bodies to have a positive mass.\n                this.m_mass = 1.0;\n                this.m_invMass = 1.0;\n            }\n            if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n                // Center the inertia about the center of mass.\n                this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);\n                this.m_invI = 1.0 / this.m_I;\n            }\n            else {\n                this.m_I = 0.0;\n                this.m_invI = 0.0;\n            }\n            // Move center of mass.\n            var oldCenter = Vec2.clone(this.m_sweep.c);\n            this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n            // Update center of mass velocity.\n            this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));\n        };\n        /**\n         * Set the mass properties to override the mass properties of the fixtures. Note\n         * that this changes the center of mass position. Note that creating or\n         * destroying fixtures can also alter the mass. This function has no effect if\n         * the body isn't dynamic.\n         *\n         * @param massData The mass properties.\n         */\n        Body.prototype.setMassData = function (massData) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            this.m_invMass = 0.0;\n            this.m_I = 0.0;\n            this.m_invI = 0.0;\n            this.m_mass = massData.mass;\n            if (this.m_mass <= 0.0) {\n                this.m_mass = 1.0;\n            }\n            this.m_invMass = 1.0 / this.m_mass;\n            if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n                this.m_I = massData.I - this.m_mass\n                    * Vec2.dot(massData.center, massData.center);\n                this.m_invI = 1.0 / this.m_I;\n            }\n            // Move center of mass.\n            var oldCenter = Vec2.clone(this.m_sweep.c);\n            this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n            // Update center of mass velocity.\n            this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(this.m_sweep.c, oldCenter)));\n        };\n        /**\n         * Apply a force at a world point. If the force is not applied at the center of\n         * mass, it will generate a torque and affect the angular velocity. This wakes\n         * up the body.\n         *\n         * @param force The world force vector, usually in Newtons (N).\n         * @param point The world position of the point of application.\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyForce = function (force, point, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate a force if the body is sleeping.\n            if (this.m_awakeFlag) {\n                this.m_force.add(force);\n                this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n            }\n        };\n        /**\n         * Apply a force to the center of mass. This wakes up the body.\n         *\n         * @param force The world force vector, usually in Newtons (N).\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyForceToCenter = function (force, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate a force if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_force.add(force);\n            }\n        };\n        /**\n         * Apply a torque. This affects the angular velocity without affecting the\n         * linear velocity of the center of mass. This wakes up the body.\n         *\n         * @param torque About the z-axis (out of the screen), usually in N-m.\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyTorque = function (torque, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate a force if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_torque += torque;\n            }\n        };\n        /**\n         * Apply an impulse at a point. This immediately modifies the velocity. It also\n         * modifies the angular velocity if the point of application is not at the\n         * center of mass. This wakes up the body.\n         *\n         * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n         * @param point The world position of the point of application.\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyLinearImpulse = function (impulse, point, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate velocity if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_linearVelocity.addMul(this.m_invMass, impulse);\n                this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n            }\n        };\n        /**\n         * Apply an angular impulse.\n         *\n         * @param impulse The angular impulse in units of kg*m*m/s\n         * @param wake Also wake up the body\n         */\n        Body.prototype.applyAngularImpulse = function (impulse, wake) {\n            if (wake === void 0) { wake = true; }\n            if (this.m_type != DYNAMIC) {\n                return;\n            }\n            if (wake && this.m_awakeFlag == false) {\n                this.setAwake(true);\n            }\n            // Don't accumulate velocity if the body is sleeping\n            if (this.m_awakeFlag) {\n                this.m_angularVelocity += this.m_invI * impulse;\n            }\n        };\n        /**\n         * This is used to prevent connected bodies (by joints) from colliding,\n         * depending on the joint's collideConnected flag.\n         */\n        Body.prototype.shouldCollide = function (that) {\n            // At least one body should be dynamic.\n            if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n                return false;\n            }\n            // Does a joint prevent collision?\n            for (var jn = this.m_jointList; jn; jn = jn.next) {\n                if (jn.other == that) {\n                    if (jn.joint.m_collideConnected == false) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        /**\n         * @internal Used for deserialize.\n         */\n        Body.prototype._addFixture = function (fixture) {\n            if (this.isWorldLocked() == true) {\n                return null;\n            }\n            if (this.m_activeFlag) {\n                var broadPhase = this.m_world.m_broadPhase;\n                fixture.createProxies(broadPhase, this.m_xf);\n            }\n            fixture.m_next = this.m_fixtureList;\n            this.m_fixtureList = fixture;\n            // Adjust mass properties if needed.\n            if (fixture.m_density > 0.0) {\n                this.resetMassData();\n            }\n            // Let the world know we have a new fixture. This will cause new contacts\n            // to be created at the beginning of the next time step.\n            this.m_world.m_newFixture = true;\n            return fixture;\n        };\n        // tslint:disable-next-line:typedef\n        Body.prototype.createFixture = function (shape, fixdef) {\n            if (this.isWorldLocked() == true) {\n                return null;\n            }\n            var fixture = new Fixture(this, shape, fixdef);\n            this._addFixture(fixture);\n            return fixture;\n        };\n        /**\n         * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n         * all contacts associated with this fixture. This will automatically adjust the\n         * mass of the body if the body is dynamic and the fixture has positive density.\n         * All fixtures attached to a body are implicitly destroyed when the body is\n         * destroyed.\n         *\n         * Warning: This function is locked during callbacks.\n         *\n         * @param fixture The fixture to be removed.\n         */\n        Body.prototype.destroyFixture = function (fixture) {\n            if (this.isWorldLocked() == true) {\n                return;\n            }\n            if (this.m_fixtureList === fixture) {\n                this.m_fixtureList = fixture.m_next;\n            }\n            else {\n                var node = this.m_fixtureList;\n                while (node != null) {\n                    if (node.m_next === fixture) {\n                        node.m_next = fixture.m_next;\n                        break;\n                    }\n                    node = node.m_next;\n                }\n            }\n            // Destroy any contacts associated with the fixture.\n            var edge = this.m_contactList;\n            while (edge) {\n                var c = edge.contact;\n                edge = edge.next;\n                var fixtureA = c.getFixtureA();\n                var fixtureB = c.getFixtureB();\n                if (fixture == fixtureA || fixture == fixtureB) {\n                    // This destroys the contact and removes it from\n                    // this body's contact list.\n                    this.m_world.destroyContact(c);\n                }\n            }\n            if (this.m_activeFlag) {\n                var broadPhase = this.m_world.m_broadPhase;\n                fixture.destroyProxies(broadPhase);\n            }\n            fixture.m_body = null;\n            fixture.m_next = null;\n            this.m_world.publish('remove-fixture', fixture);\n            // Reset the mass data.\n            this.resetMassData();\n        };\n        /**\n         * Get the corresponding world point of a local point.\n         */\n        Body.prototype.getWorldPoint = function (localPoint) {\n            return Transform.mulVec2(this.m_xf, localPoint);\n        };\n        /**\n         * Get the corresponding world vector of a local vector.\n         */\n        Body.prototype.getWorldVector = function (localVector) {\n            return Rot.mulVec2(this.m_xf.q, localVector);\n        };\n        /**\n         * Gets the corresponding local point of a world point.\n         */\n        Body.prototype.getLocalPoint = function (worldPoint) {\n            return Transform.mulTVec2(this.m_xf, worldPoint);\n        };\n        /**\n         * Gets the corresponding local vector of a world vector.\n         */\n        Body.prototype.getLocalVector = function (worldVector) {\n            return Rot.mulTVec2(this.m_xf.q, worldVector);\n        };\n        /**\n         * A static body does not move under simulation and behaves as if it has infinite mass.\n         * Internally, zero is stored for the mass and the inverse mass.\n         * Static bodies can be moved manually by the user.\n         * A static body has zero velocity.\n         * Static bodies do not collide with other static or kinematic bodies.\n         */\n        Body.STATIC = 'static';\n        /**\n         * A kinematic body moves under simulation according to its velocity.\n         * Kinematic bodies do not respond to forces.\n         * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n         * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n         * Kinematic bodies do not collide with other kinematic or static bodies.\n         */\n        Body.KINEMATIC = 'kinematic';\n        /**\n         * A dynamic body is fully simulated.\n         * They can be moved manually by the user, but normally they move according to forces.\n         * A dynamic body can collide with all body types.\n         * A dynamic body always has finite, non-zero mass.\n         * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n         */\n        Body.DYNAMIC = 'dynamic';\n        return Body;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A 2-by-2 matrix. Stored in column-major order.\n     */\n    var Mat22 = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        function Mat22(a, b, c, d) {\n            if (typeof a === 'object' && a !== null) {\n                this.ex = Vec2.clone(a);\n                this.ey = Vec2.clone(b);\n            }\n            else if (typeof a === 'number') {\n                this.ex = Vec2.neo(a, c);\n                this.ey = Vec2.neo(b, d);\n            }\n            else {\n                this.ex = Vec2.zero();\n                this.ey = Vec2.zero();\n            }\n        }\n        /** @internal */\n        Mat22.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        Mat22.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n        };\n        Mat22.assert = function (o) {\n            return;\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.prototype.set = function (a, b, c, d) {\n            if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'\n                && typeof d === 'number') {\n                this.ex.setNum(a, c);\n                this.ey.setNum(b, d);\n            }\n            else if (typeof a === 'object' && typeof b === 'object') {\n                this.ex.setVec2(a);\n                this.ey.setVec2(b);\n            }\n            else if (typeof a === 'object') {\n                this.ex.setVec2(a.ex);\n                this.ey.setVec2(a.ey);\n            }\n            else ;\n        };\n        Mat22.prototype.setIdentity = function () {\n            this.ex.x = 1.0;\n            this.ey.x = 0.0;\n            this.ex.y = 0.0;\n            this.ey.y = 1.0;\n        };\n        Mat22.prototype.setZero = function () {\n            this.ex.x = 0.0;\n            this.ey.x = 0.0;\n            this.ex.y = 0.0;\n            this.ey.y = 0.0;\n        };\n        Mat22.prototype.getInverse = function () {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var imx = new Mat22();\n            imx.ex.x = det * d;\n            imx.ey.x = -det * b;\n            imx.ex.y = -det * c;\n            imx.ey.y = det * a;\n            return imx;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases.\n         */\n        Mat22.prototype.solve = function (v) {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var w = Vec2.zero();\n            w.x = det * (d * v.x - b * v.y);\n            w.y = det * (a * v.y - c * v.x);\n            return w;\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.mul = function (mx, v) {\n            if (v && 'x' in v && 'y' in v) {\n                var x = mx.ex.x * v.x + mx.ey.x * v.y;\n                var y = mx.ex.y * v.x + mx.ey.y * v.y;\n                return Vec2.neo(x, y);\n            }\n            else if (v && 'ex' in v && 'ey' in v) { // Mat22\n                // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n                var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n                var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n                var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n                var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n                return new Mat22(a, b, c, d);\n            }\n        };\n        Mat22.mulVec2 = function (mx, v) {\n            var x = mx.ex.x * v.x + mx.ey.x * v.y;\n            var y = mx.ex.y * v.x + mx.ey.y * v.y;\n            return Vec2.neo(x, y);\n        };\n        Mat22.mulMat22 = function (mx, v) {\n            // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n            var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n            var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n            var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n            var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n            return new Mat22(a, b, c, d);\n        };\n        // tslint:disable-next-line:typedef\n        Mat22.mulT = function (mx, v) {\n            if (v && 'x' in v && 'y' in v) { // Vec2\n                return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n            }\n            else if (v && 'ex' in v && 'ey' in v) { // Mat22\n                var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n                var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n                return new Mat22(c1, c2);\n            }\n        };\n        Mat22.mulTVec2 = function (mx, v) {\n            return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n        };\n        Mat22.mulTMat22 = function (mx, v) {\n            var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n            var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n            return new Mat22(c1, c2);\n        };\n        Mat22.abs = function (mx) {\n            return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n        };\n        Mat22.add = function (mx1, mx2) {\n            return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n        };\n        return Mat22;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var ManifoldType;\n    (function (ManifoldType) {\n        ManifoldType[ManifoldType[\"e_circles\"] = 0] = \"e_circles\";\n        ManifoldType[ManifoldType[\"e_faceA\"] = 1] = \"e_faceA\";\n        ManifoldType[ManifoldType[\"e_faceB\"] = 2] = \"e_faceB\";\n    })(ManifoldType || (ManifoldType = {}));\n    var ContactFeatureType;\n    (function (ContactFeatureType) {\n        ContactFeatureType[ContactFeatureType[\"e_vertex\"] = 0] = \"e_vertex\";\n        ContactFeatureType[ContactFeatureType[\"e_face\"] = 1] = \"e_face\";\n    })(ContactFeatureType || (ContactFeatureType = {}));\n    /**\n     * This is used for determining the state of contact points.\n     */\n    var PointState;\n    (function (PointState) {\n        /** Point does not exist */\n        PointState[PointState[\"nullState\"] = 0] = \"nullState\";\n        /** Point was added in the update */\n        PointState[PointState[\"addState\"] = 1] = \"addState\";\n        /** Point persisted across the update */\n        PointState[PointState[\"persistState\"] = 2] = \"persistState\";\n        /** Point was removed in the update */\n        PointState[PointState[\"removeState\"] = 3] = \"removeState\";\n    })(PointState || (PointState = {}));\n    /**\n     * Used for computing contact manifolds.\n     */\n    var ClipVertex = /** @class */ (function () {\n        function ClipVertex() {\n            this.v = Vec2.zero();\n            this.id = new ContactID();\n        }\n        ClipVertex.prototype.set = function (o) {\n            this.v.setVec2(o.v);\n            this.id.set(o.id);\n        };\n        return ClipVertex;\n    }());\n    /**\n     * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n     * method of Contact subclasses.\n     *\n     * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n     * with radius and e_circles point versus point with radius.\n     *\n     * We store contacts in this way so that position correction can account for\n     * movement, which is critical for continuous physics. All contact scenarios\n     * must be expressed in one of these types. This structure is stored across time\n     * steps, so we keep it small.\n     *\n     * @prop type e_circle, e_faceA, e_faceB\n     * @prop localPoint Usage depends on manifold type:<br>\n     *       e_circles: the local center of circleA <br>\n     *       e_faceA: the center of faceA <br>\n     *       e_faceB: the center of faceB\n     * @prop localNormal Usage depends on manifold type:<br>\n     *       e_circles: not used <br>\n     *       e_faceA: the normal on polygonA <br>\n     *       e_faceB: the normal on polygonB\n     * @prop points The points of contact {ManifoldPoint[]}\n     * @prop pointCount The number of manifold points\n     */\n    var Manifold = /** @class */ (function () {\n        function Manifold() {\n            this.localNormal = Vec2.zero();\n            this.localPoint = Vec2.zero();\n            this.points = [new ManifoldPoint(), new ManifoldPoint()];\n            this.pointCount = 0;\n        }\n        /**\n         * Evaluate the manifold with supplied transforms. This assumes modest motion\n         * from the original state. This does not change the point count, impulses, etc.\n         * The radii must come from the shapes that generated the manifold.\n         */\n        Manifold.prototype.getWorldManifold = function (wm, xfA, radiusA, xfB, radiusB) {\n            if (this.pointCount == 0) {\n                return;\n            }\n            wm = wm || new WorldManifold();\n            var normal = wm.normal;\n            var points = wm.points;\n            var separations = wm.separations;\n            // TODO: improve\n            switch (this.type) {\n                case ManifoldType.e_circles: {\n                    normal = Vec2.neo(1.0, 0.0);\n                    var pointA = Transform.mulVec2(xfA, this.localPoint);\n                    var pointB = Transform.mulVec2(xfB, this.points[0].localPoint);\n                    var dist = Vec2.sub(pointB, pointA);\n                    if (Vec2.lengthSquared(dist) > math.EPSILON * math.EPSILON) {\n                        normal.setVec2(dist);\n                        normal.normalize();\n                    }\n                    var cA = pointA.clone().addMul(radiusA, normal);\n                    var cB = pointB.clone().addMul(-radiusB, normal);\n                    points[0] = Vec2.mid(cA, cB);\n                    separations[0] = Vec2.dot(Vec2.sub(cB, cA), normal);\n                    points.length = 1;\n                    separations.length = 1;\n                    break;\n                }\n                case ManifoldType.e_faceA: {\n                    normal = Rot.mulVec2(xfA.q, this.localNormal);\n                    var planePoint = Transform.mulVec2(xfA, this.localPoint);\n                    for (var i = 0; i < this.pointCount; ++i) {\n                        var clipPoint = Transform.mulVec2(xfB, this.points[i].localPoint);\n                        var cA = Vec2.clone(clipPoint).addMul(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n                        var cB = Vec2.clone(clipPoint).subMul(radiusB, normal);\n                        points[i] = Vec2.mid(cA, cB);\n                        separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);\n                    }\n                    points.length = this.pointCount;\n                    separations.length = this.pointCount;\n                    break;\n                }\n                case ManifoldType.e_faceB: {\n                    normal = Rot.mulVec2(xfB.q, this.localNormal);\n                    var planePoint = Transform.mulVec2(xfB, this.localPoint);\n                    for (var i = 0; i < this.pointCount; ++i) {\n                        var clipPoint = Transform.mulVec2(xfA, this.points[i].localPoint);\n                        var cB = Vec2.combine(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n                        var cA = Vec2.combine(1, clipPoint, -radiusA, normal);\n                        points[i] = Vec2.mid(cA, cB);\n                        separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);\n                    }\n                    points.length = this.pointCount;\n                    separations.length = this.pointCount;\n                    // Ensure normal points from A to B.\n                    normal.mul(-1);\n                    break;\n                }\n            }\n            wm.normal = normal;\n            wm.points = points;\n            wm.separations = separations;\n            return wm;\n        };\n        Manifold.clipSegmentToLine = clipSegmentToLine;\n        Manifold.ClipVertex = ClipVertex;\n        Manifold.getPointStates = getPointStates;\n        Manifold.PointState = PointState;\n        return Manifold;\n    }());\n    /**\n     * A manifold point is a contact point belonging to a contact manifold. It holds\n     * details related to the geometry and dynamics of the contact points.\n     *\n     * This structure is stored across time steps, so we keep it small.\n     *\n     * Note: impulses are used for internal caching and may not provide reliable\n     * contact forces, especially for high speed collisions.\n     */\n    var ManifoldPoint = /** @class */ (function () {\n        function ManifoldPoint() {\n            /**\n             * Usage depends on manifold type.\n             *       e_circles: the local center of circleB,\n             *       e_faceA: the local center of cirlceB or the clip point of polygonB,\n             *       e_faceB: the clip point of polygonA.\n             */\n            this.localPoint = Vec2.zero();\n            /**\n             * The non-penetration impulse\n             */\n            this.normalImpulse = 0;\n            /**\n             * The friction impulse\n             */\n            this.tangentImpulse = 0;\n            /**\n             * Uniquely identifies a contact point between two shapes to facilatate warm starting\n             */\n            this.id = new ContactID();\n        }\n        return ManifoldPoint;\n    }());\n    /**\n     * Contact ids to facilitate warm starting.\n     */\n    var ContactID = /** @class */ (function () {\n        function ContactID() {\n            this.cf = new ContactFeature();\n        }\n        Object.defineProperty(ContactID.prototype, \"key\", {\n            /**\n             * Used to quickly compare contact ids.\n             */\n            get: function () {\n                return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ContactID.prototype.set = function (o) {\n            // this.key = o.key;\n            this.cf.set(o.cf);\n        };\n        return ContactID;\n    }());\n    /**\n     * The features that intersect to form the contact point.\n     */\n    var ContactFeature = /** @class */ (function () {\n        function ContactFeature() {\n        }\n        ContactFeature.prototype.set = function (o) {\n            this.indexA = o.indexA;\n            this.indexB = o.indexB;\n            this.typeA = o.typeA;\n            this.typeB = o.typeB;\n        };\n        return ContactFeature;\n    }());\n    /**\n     * This is used to compute the current state of a contact manifold.\n     */\n    var WorldManifold = /** @class */ (function () {\n        function WorldManifold() {\n            /**\n             * World contact point (point of intersection)\n             */\n            this.points = []; // [maxManifoldPoints]\n            /**\n             * A negative value indicates overlap, in meters\n             */\n            this.separations = []; // [maxManifoldPoints]\n        }\n        return WorldManifold;\n    }());\n    /**\n     * Compute the point states given two manifolds. The states pertain to the\n     * transition from manifold1 to manifold2. So state1 is either persist or remove\n     * while state2 is either add or persist.\n     */\n    function getPointStates(state1, state2, manifold1, manifold2) {\n        // state1, state2: PointState[Settings.maxManifoldPoints]\n        // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n        // state1[i] = PointState.nullState;\n        // state2[i] = PointState.nullState;\n        // }\n        // Detect persists and removes.\n        for (var i = 0; i < manifold1.pointCount; ++i) {\n            var id = manifold1.points[i].id;\n            state1[i] = PointState.removeState;\n            for (var j = 0; j < manifold2.pointCount; ++j) {\n                if (manifold2.points[j].id.key == id.key) {\n                    state1[i] = PointState.persistState;\n                    break;\n                }\n            }\n        }\n        // Detect persists and adds.\n        for (var i = 0; i < manifold2.pointCount; ++i) {\n            var id = manifold2.points[i].id;\n            state2[i] = PointState.addState;\n            for (var j = 0; j < manifold1.pointCount; ++j) {\n                if (manifold1.points[j].id.key == id.key) {\n                    state2[i] = PointState.persistState;\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n     */\n    function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {\n        // Start with no output points\n        var numOut = 0;\n        // Calculate the distance of end points to the line\n        var distance0 = Vec2.dot(normal, vIn[0].v) - offset;\n        var distance1 = Vec2.dot(normal, vIn[1].v) - offset;\n        // If the points are behind the plane\n        if (distance0 <= 0.0)\n            vOut[numOut++].set(vIn[0]);\n        if (distance1 <= 0.0)\n            vOut[numOut++].set(vIn[1]);\n        // If the points are on different sides of the plane\n        if (distance0 * distance1 < 0.0) {\n            // Find intersection point of edge and plane\n            var interp = distance0 / (distance0 - distance1);\n            vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);\n            // VertexA is hitting edgeB.\n            vOut[numOut].id.cf.indexA = vertexIndexA;\n            vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;\n            vOut[numOut].id.cf.typeA = ContactFeatureType.e_vertex;\n            vOut[numOut].id.cf.typeB = ContactFeatureType.e_face;\n            ++numOut;\n        }\n        return numOut;\n    }\n\n    var stats = {\n        gjkCalls: 0,\n        gjkIters: 0,\n        gjkMaxIters: 0,\n        toiTime: 0,\n        toiMaxTime: 0,\n        toiCalls: 0,\n        toiIters: 0,\n        toiMaxIters: 0,\n        toiRootIters: 0,\n        toiMaxRootIters: 0,\n        toString: function (newline) {\n            newline = typeof newline === 'string' ? newline : '\\n';\n            var string = \"\";\n            // tslint:disable-next-line:no-for-in\n            for (var name_1 in this) {\n                if (typeof this[name_1] !== 'function' && typeof this[name_1] !== 'object') {\n                    string += name_1 + ': ' + this[name_1] + newline;\n                }\n            }\n            return string;\n        }\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n     */\n    stats.gjkCalls = 0;\n    stats.gjkIters = 0;\n    stats.gjkMaxIters = 0;\n    /**\n     * Input for Distance. You have to option to use the shape radii in the\n     * computation. Even\n     */\n    var DistanceInput = /** @class */ (function () {\n        function DistanceInput() {\n            this.proxyA = new DistanceProxy();\n            this.proxyB = new DistanceProxy();\n            this.transformA = null;\n            this.transformB = null;\n            this.useRadii = false;\n        }\n        return DistanceInput;\n    }());\n    /**\n     * Output for Distance.\n     *\n     * @prop {Vec2} pointA closest point on shapeA\n     * @prop {Vec2} pointB closest point on shapeB\n     * @prop distance\n     * @prop iterations number of GJK iterations used\n     */\n    var DistanceOutput = /** @class */ (function () {\n        function DistanceOutput() {\n            this.pointA = Vec2.zero();\n            this.pointB = Vec2.zero();\n        }\n        return DistanceOutput;\n    }());\n    /**\n     * Used to warm start Distance. Set count to zero on first call.\n     *\n     * @prop {number} metric length or area\n     * @prop {array} indexA vertices on shape A\n     * @prop {array} indexB vertices on shape B\n     * @prop {number} count\n     */\n    var SimplexCache = /** @class */ (function () {\n        function SimplexCache() {\n            this.metric = 0;\n            this.indexA = [];\n            this.indexB = [];\n            this.count = 0;\n        }\n        return SimplexCache;\n    }());\n    /**\n     * Compute the closest points between two shapes. Supports any combination of:\n     * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n     * the first call set SimplexCache.count to zero.\n     */\n    function Distance(output, cache, input) {\n        ++stats.gjkCalls;\n        var proxyA = input.proxyA;\n        var proxyB = input.proxyB;\n        var xfA = input.transformA;\n        var xfB = input.transformB;\n        // Initialize the simplex.\n        var simplex = new Simplex();\n        simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n        // Get simplex vertices as an array.\n        var vertices = simplex.m_v;\n        var k_maxIters = Settings.maxDistnceIterations;\n        // These store the vertices of the last simplex so that we\n        // can check for duplicates and prevent cycling.\n        var saveA = [];\n        var saveB = []; // int[3]\n        var saveCount = 0;\n        // Main iteration loop.\n        var iter = 0;\n        while (iter < k_maxIters) {\n            // Copy simplex so we can identify duplicates.\n            saveCount = simplex.m_count;\n            for (var i = 0; i < saveCount; ++i) {\n                saveA[i] = vertices[i].indexA;\n                saveB[i] = vertices[i].indexB;\n            }\n            simplex.solve();\n            // If we have 3 points, then the origin is in the corresponding triangle.\n            if (simplex.m_count === 3) {\n                break;\n            }\n            // Compute closest point.\n            var p = simplex.getClosestPoint();\n            p.lengthSquared();\n            // Get search direction.\n            var d = simplex.getSearchDirection();\n            // Ensure the search direction is numerically fit.\n            if (d.lengthSquared() < math.EPSILON * math.EPSILON) {\n                // The origin is probably contained by a line segment\n                // or triangle. Thus the shapes are overlapped.\n                // We can't return zero here even though there may be overlap.\n                // In case the simplex is a point, segment, or triangle it is difficult\n                // to determine if the origin is contained in the CSO or very close to it.\n                break;\n            }\n            // Compute a tentative new simplex vertex using support points.\n            var vertex = vertices[simplex.m_count]; // SimplexVertex\n            vertex.indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(d)));\n            vertex.wA = Transform.mulVec2(xfA, proxyA.getVertex(vertex.indexA));\n            vertex.indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, d));\n            vertex.wB = Transform.mulVec2(xfB, proxyB.getVertex(vertex.indexB));\n            vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n            // Iteration count is equated to the number of support point calls.\n            ++iter;\n            ++stats.gjkIters;\n            // Check for duplicate support points. This is the main termination\n            // criteria.\n            var duplicate = false;\n            for (var i = 0; i < saveCount; ++i) {\n                if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n                    duplicate = true;\n                    break;\n                }\n            }\n            // If we found a duplicate support point we must exit to avoid cycling.\n            if (duplicate) {\n                break;\n            }\n            // New vertex is ok and needed.\n            ++simplex.m_count;\n        }\n        stats.gjkMaxIters = math.max(stats.gjkMaxIters, iter);\n        // Prepare output.\n        simplex.getWitnessPoints(output.pointA, output.pointB);\n        output.distance = Vec2.distance(output.pointA, output.pointB);\n        output.iterations = iter;\n        // Cache the simplex.\n        simplex.writeCache(cache);\n        // Apply radii if requested.\n        if (input.useRadii) {\n            var rA = proxyA.m_radius;\n            var rB = proxyB.m_radius;\n            if (output.distance > rA + rB && output.distance > math.EPSILON) {\n                // Shapes are still no overlapped.\n                // Move the witness points to the outer surface.\n                output.distance -= rA + rB;\n                var normal = Vec2.sub(output.pointB, output.pointA);\n                normal.normalize();\n                output.pointA.addMul(rA, normal);\n                output.pointB.subMul(rB, normal);\n            }\n            else {\n                // Shapes are overlapped when radii are considered.\n                // Move the witness points to the middle.\n                var p = Vec2.mid(output.pointA, output.pointB);\n                output.pointA.setVec2(p);\n                output.pointB.setVec2(p);\n                output.distance = 0.0;\n            }\n        }\n    }\n    /**\n     * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n     */\n    var DistanceProxy = /** @class */ (function () {\n        function DistanceProxy() {\n            this.m_buffer = []; // Vec2[2]\n            this.m_vertices = []; // Vec2[]\n            this.m_count = 0;\n            this.m_radius = 0;\n        }\n        /**\n         * Get the vertex count.\n         */\n        DistanceProxy.prototype.getVertexCount = function () {\n            return this.m_count;\n        };\n        /**\n         * Get a vertex by index. Used by Distance.\n         */\n        DistanceProxy.prototype.getVertex = function (index) {\n            return this.m_vertices[index];\n        };\n        /**\n         * Get the supporting vertex index in the given direction.\n         */\n        DistanceProxy.prototype.getSupport = function (d) {\n            var bestIndex = 0;\n            var bestValue = Vec2.dot(this.m_vertices[0], d);\n            for (var i = 0; i < this.m_count; ++i) {\n                var value = Vec2.dot(this.m_vertices[i], d);\n                if (value > bestValue) {\n                    bestIndex = i;\n                    bestValue = value;\n                }\n            }\n            return bestIndex;\n        };\n        /**\n         * Get the supporting vertex in the given direction.\n         */\n        DistanceProxy.prototype.getSupportVertex = function (d) {\n            return this.m_vertices[this.getSupport(d)];\n        };\n        /**\n         * Initialize the proxy using the given shape. The shape must remain in scope\n         * while the proxy is in use.\n         */\n        DistanceProxy.prototype.set = function (shape, index) {\n            shape.computeDistanceProxy(this, index);\n        };\n        return DistanceProxy;\n    }());\n    var SimplexVertex = /** @class */ (function () {\n        function SimplexVertex() {\n            /** support point in proxyA */\n            this.wA = Vec2.zero();\n            /** support point in proxyB */\n            this.wB = Vec2.zero();\n            /** wB - wA; */\n            this.w = Vec2.zero();\n        }\n        SimplexVertex.prototype.set = function (v) {\n            this.indexA = v.indexA;\n            this.indexB = v.indexB;\n            this.wA = Vec2.clone(v.wA);\n            this.wB = Vec2.clone(v.wB);\n            this.w = Vec2.clone(v.w);\n            this.a = v.a;\n        };\n        return SimplexVertex;\n    }());\n    var Simplex = /** @class */ (function () {\n        function Simplex() {\n            this.m_v1 = new SimplexVertex();\n            this.m_v2 = new SimplexVertex();\n            this.m_v3 = new SimplexVertex();\n            this.m_v = [this.m_v1, this.m_v2, this.m_v3];\n            this.m_count;\n        }\n        /** @internal */\n        Simplex.prototype.toString = function () {\n            if (this.m_count === 3) {\n                return [\"+\" + this.m_count,\n                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n                    this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,\n                    this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y\n                ].toString();\n            }\n            else if (this.m_count === 2) {\n                return [\"+\" + this.m_count,\n                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n                    this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y\n                ].toString();\n            }\n            else if (this.m_count === 1) {\n                return [\"+\" + this.m_count,\n                    this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y\n                ].toString();\n            }\n            else {\n                return \"+\" + this.m_count;\n            }\n        };\n        Simplex.prototype.readCache = function (cache, proxyA, transformA, proxyB, transformB) {\n            // Copy data from cache.\n            this.m_count = cache.count;\n            for (var i = 0; i < this.m_count; ++i) {\n                var v = this.m_v[i];\n                v.indexA = cache.indexA[i];\n                v.indexB = cache.indexB[i];\n                var wALocal = proxyA.getVertex(v.indexA);\n                var wBLocal = proxyB.getVertex(v.indexB);\n                v.wA = Transform.mulVec2(transformA, wALocal);\n                v.wB = Transform.mulVec2(transformB, wBLocal);\n                v.w = Vec2.sub(v.wB, v.wA);\n                v.a = 0.0;\n            }\n            // Compute the new simplex metric, if it is substantially different than\n            // old metric then flush the simplex.\n            if (this.m_count > 1) {\n                var metric1 = cache.metric;\n                var metric2 = this.getMetric();\n                if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2\n                    || metric2 < math.EPSILON) {\n                    // Reset the simplex.\n                    this.m_count = 0;\n                }\n            }\n            // If the cache is empty or invalid...\n            if (this.m_count === 0) {\n                var v = this.m_v[0];\n                v.indexA = 0;\n                v.indexB = 0;\n                var wALocal = proxyA.getVertex(0);\n                var wBLocal = proxyB.getVertex(0);\n                v.wA = Transform.mulVec2(transformA, wALocal);\n                v.wB = Transform.mulVec2(transformB, wBLocal);\n                v.w = Vec2.sub(v.wB, v.wA);\n                v.a = 1.0;\n                this.m_count = 1;\n            }\n        };\n        Simplex.prototype.writeCache = function (cache) {\n            cache.metric = this.getMetric();\n            cache.count = this.m_count;\n            for (var i = 0; i < this.m_count; ++i) {\n                cache.indexA[i] = this.m_v[i].indexA;\n                cache.indexB[i] = this.m_v[i].indexB;\n            }\n        };\n        Simplex.prototype.getSearchDirection = function () {\n            switch (this.m_count) {\n                case 1:\n                    return Vec2.neg(this.m_v1.w);\n                case 2: {\n                    var e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);\n                    var sgn = Vec2.crossVec2Vec2(e12, Vec2.neg(this.m_v1.w));\n                    if (sgn > 0.0) {\n                        // Origin is left of e12.\n                        return Vec2.crossNumVec2(1.0, e12);\n                    }\n                    else {\n                        // Origin is right of e12.\n                        return Vec2.crossVec2Num(e12, 1.0);\n                    }\n                }\n                default:\n                    return Vec2.zero();\n            }\n        };\n        Simplex.prototype.getClosestPoint = function () {\n            switch (this.m_count) {\n                case 0:\n                    return Vec2.zero();\n                case 1:\n                    return Vec2.clone(this.m_v1.w);\n                case 2:\n                    return Vec2.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);\n                case 3:\n                    return Vec2.zero();\n                default:\n                    return Vec2.zero();\n            }\n        };\n        Simplex.prototype.getWitnessPoints = function (pA, pB) {\n            switch (this.m_count) {\n                case 0:\n                    break;\n                case 1:\n                    pA.setVec2(this.m_v1.wA);\n                    pB.setVec2(this.m_v1.wB);\n                    break;\n                case 2:\n                    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n                    pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);\n                    break;\n                case 3:\n                    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n                    pA.addMul(this.m_v3.a, this.m_v3.wA);\n                    pB.setVec2(pA);\n                    break;\n            }\n        };\n        Simplex.prototype.getMetric = function () {\n            switch (this.m_count) {\n                case 0:\n                    return 0.0;\n                case 1:\n                    return 0.0;\n                case 2:\n                    return Vec2.distance(this.m_v1.w, this.m_v2.w);\n                case 3:\n                    return Vec2.crossVec2Vec2(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w, this.m_v1.w));\n                default:\n                    return 0.0;\n            }\n        };\n        Simplex.prototype.solve = function () {\n            switch (this.m_count) {\n                case 1:\n                    break;\n                case 2:\n                    this.solve2();\n                    break;\n                case 3:\n                    this.solve3();\n                    break;\n            }\n        };\n        // Solve a line segment using barycentric coordinates.\n        //\n        // p = a1 * w1 + a2 * w2\n        // a1 + a2 = 1\n        //\n        // The vector from the origin to the closest point on the line is\n        // perpendicular to the line.\n        // e12 = w2 - w1\n        // dot(p, e) = 0\n        // a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n        //\n        // 2-by-2 linear system\n        // [1 1 ][a1] = [1]\n        // [w1.e12 w2.e12][a2] = [0]\n        //\n        // Define\n        // d12_1 = dot(w2, e12)\n        // d12_2 = -dot(w1, e12)\n        // d12 = d12_1 + d12_2\n        //\n        // Solution\n        // a1 = d12_1 / d12\n        // a2 = d12_2 / d12\n        Simplex.prototype.solve2 = function () {\n            var w1 = this.m_v1.w;\n            var w2 = this.m_v2.w;\n            var e12 = Vec2.sub(w2, w1);\n            // w1 region\n            var d12_2 = -Vec2.dot(w1, e12);\n            if (d12_2 <= 0.0) {\n                // a2 <= 0, so we clamp it to 0\n                this.m_v1.a = 1.0;\n                this.m_count = 1;\n                return;\n            }\n            // w2 region\n            var d12_1 = Vec2.dot(w2, e12);\n            if (d12_1 <= 0.0) {\n                // a1 <= 0, so we clamp it to 0\n                this.m_v2.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v2);\n                return;\n            }\n            // Must be in e12 region.\n            var inv_d12 = 1.0 / (d12_1 + d12_2);\n            this.m_v1.a = d12_1 * inv_d12;\n            this.m_v2.a = d12_2 * inv_d12;\n            this.m_count = 2;\n        };\n        // Possible regions:\n        // - points[2]\n        // - edge points[0]-points[2]\n        // - edge points[1]-points[2]\n        // - inside the triangle\n        Simplex.prototype.solve3 = function () {\n            var w1 = this.m_v1.w;\n            var w2 = this.m_v2.w;\n            var w3 = this.m_v3.w;\n            // Edge12\n            // [1 1 ][a1] = [1]\n            // [w1.e12 w2.e12][a2] = [0]\n            // a3 = 0\n            var e12 = Vec2.sub(w2, w1);\n            var w1e12 = Vec2.dot(w1, e12);\n            var w2e12 = Vec2.dot(w2, e12);\n            var d12_1 = w2e12;\n            var d12_2 = -w1e12;\n            // Edge13\n            // [1 1 ][a1] = [1]\n            // [w1.e13 w3.e13][a3] = [0]\n            // a2 = 0\n            var e13 = Vec2.sub(w3, w1);\n            var w1e13 = Vec2.dot(w1, e13);\n            var w3e13 = Vec2.dot(w3, e13);\n            var d13_1 = w3e13;\n            var d13_2 = -w1e13;\n            // Edge23\n            // [1 1 ][a2] = [1]\n            // [w2.e23 w3.e23][a3] = [0]\n            // a1 = 0\n            var e23 = Vec2.sub(w3, w2);\n            var w2e23 = Vec2.dot(w2, e23);\n            var w3e23 = Vec2.dot(w3, e23);\n            var d23_1 = w3e23;\n            var d23_2 = -w2e23;\n            // Triangle123\n            var n123 = Vec2.crossVec2Vec2(e12, e13);\n            var d123_1 = n123 * Vec2.crossVec2Vec2(w2, w3);\n            var d123_2 = n123 * Vec2.crossVec2Vec2(w3, w1);\n            var d123_3 = n123 * Vec2.crossVec2Vec2(w1, w2);\n            // w1 region\n            if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n                this.m_v1.a = 1.0;\n                this.m_count = 1;\n                return;\n            }\n            // e12\n            if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n                var inv_d12 = 1.0 / (d12_1 + d12_2);\n                this.m_v1.a = d12_1 * inv_d12;\n                this.m_v2.a = d12_2 * inv_d12;\n                this.m_count = 2;\n                return;\n            }\n            // e13\n            if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n                var inv_d13 = 1.0 / (d13_1 + d13_2);\n                this.m_v1.a = d13_1 * inv_d13;\n                this.m_v3.a = d13_2 * inv_d13;\n                this.m_count = 2;\n                this.m_v2.set(this.m_v3);\n                return;\n            }\n            // w2 region\n            if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n                this.m_v2.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v2);\n                return;\n            }\n            // w3 region\n            if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n                this.m_v3.a = 1.0;\n                this.m_count = 1;\n                this.m_v1.set(this.m_v3);\n                return;\n            }\n            // e23\n            if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n                var inv_d23 = 1.0 / (d23_1 + d23_2);\n                this.m_v2.a = d23_1 * inv_d23;\n                this.m_v3.a = d23_2 * inv_d23;\n                this.m_count = 2;\n                this.m_v1.set(this.m_v3);\n                return;\n            }\n            // Must be in triangle123\n            var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n            this.m_v1.a = d123_1 * inv_d123;\n            this.m_v2.a = d123_2 * inv_d123;\n            this.m_v3.a = d123_3 * inv_d123;\n            this.m_count = 3;\n        };\n        return Simplex;\n    }());\n    /**\n     * Determine if two generic shapes overlap.\n     */\n    function testOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB) {\n        var input = new DistanceInput();\n        input.proxyA.set(shapeA, indexA);\n        input.proxyB.set(shapeB, indexB);\n        input.transformA = xfA;\n        input.transformB = xfB;\n        input.useRadii = true;\n        var cache = new SimplexCache();\n        var output = new DistanceOutput();\n        Distance(output, cache, input);\n        return output.distance < 10.0 * math.EPSILON;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A contact edge is used to connect bodies and contacts together in a contact\n     * graph where each body is a node and each contact is an edge. A contact edge\n     * belongs to a doubly linked list maintained in each attached body. Each\n     * contact has two contact nodes, one for each attached body.\n     *\n     * @prop {Contact} contact The contact\n     * @prop {ContactEdge} prev The previous contact edge in the body's contact list\n     * @prop {ContactEdge} next The next contact edge in the body's contact list\n     * @prop {Body} other Provides quick access to the other body attached.\n     */\n    var ContactEdge = /** @class */ (function () {\n        function ContactEdge(contact) {\n            this.contact = contact;\n        }\n        return ContactEdge;\n    }());\n    /**\n     * Friction mixing law. The idea is to allow either fixture to drive the\n     * restitution to zero. For example, anything slides on ice.\n     */\n    function mixFriction(friction1, friction2) {\n        return math.sqrt(friction1 * friction2);\n    }\n    /**\n     * Restitution mixing law. The idea is allow for anything to bounce off an\n     * inelastic surface. For example, a superball bounces on anything.\n     */\n    function mixRestitution(restitution1, restitution2) {\n        return restitution1 > restitution2 ? restitution1 : restitution2;\n    }\n    // TODO: move this to Settings?\n    var s_registers = [];\n    // TODO: merge with ManifoldPoint?\n    var VelocityConstraintPoint = /** @class */ (function () {\n        function VelocityConstraintPoint() {\n            this.rA = Vec2.zero();\n            this.rB = Vec2.zero();\n            this.normalImpulse = 0;\n            this.tangentImpulse = 0;\n            this.normalMass = 0;\n            this.tangentMass = 0;\n            this.velocityBias = 0;\n        }\n        return VelocityConstraintPoint;\n    }());\n    /**\n     * The class manages contact between two shapes. A contact exists for each\n     * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n     * object may exist that has no contact points.\n     */\n    var Contact = /** @class */ (function () {\n        function Contact(fA, indexA, fB, indexB, evaluateFcn) {\n            /** @internal */\n            this.m_manifold = new Manifold();\n            /** @internal */\n            this.m_prev = null;\n            /** @internal */\n            this.m_next = null;\n            /** @internal */\n            this.m_toi = 1.0;\n            /** @internal */\n            this.m_toiCount = 0;\n            /** @internal This contact has a valid TOI in m_toi */\n            this.m_toiFlag = false;\n            /** @internal */\n            this.m_tangentSpeed = 0.0;\n            /** @internal This contact can be disabled (by user) */\n            this.m_enabledFlag = true;\n            /** @internal Used when crawling contact graph when forming islands. */\n            this.m_islandFlag = false;\n            /** @internal Set when the shapes are touching. */\n            this.m_touchingFlag = false;\n            /** @internal This contact needs filtering because a fixture filter was changed. */\n            this.m_filterFlag = false;\n            /** @internal This bullet contact had a TOI event */\n            this.m_bulletHitFlag = false;\n            /** @internal Contact reporting impulse object cache */\n            this.m_impulse = new ContactImpulse(this);\n            // VelocityConstraint\n            /** @internal */ this.v_points = []; // [maxManifoldPoints];\n            /** @internal */ this.v_normal = Vec2.zero();\n            /** @internal */ this.v_normalMass = new Mat22();\n            /** @internal */ this.v_K = new Mat22();\n            // PositionConstraint\n            /** @internal */ this.p_localPoints = []; // [maxManifoldPoints];\n            /** @internal */ this.p_localNormal = Vec2.zero();\n            /** @internal */ this.p_localPoint = Vec2.zero();\n            /** @internal */ this.p_localCenterA = Vec2.zero();\n            /** @internal */ this.p_localCenterB = Vec2.zero();\n            // Nodes for connecting bodies.\n            this.m_nodeA = new ContactEdge(this);\n            this.m_nodeB = new ContactEdge(this);\n            this.m_fixtureA = fA;\n            this.m_fixtureB = fB;\n            this.m_indexA = indexA;\n            this.m_indexB = indexB;\n            this.m_evaluateFcn = evaluateFcn;\n            this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n            this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n        }\n        Contact.prototype.initConstraint = function (step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var shapeA = fixtureA.getShape();\n            var shapeB = fixtureB.getShape();\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var manifold = this.getManifold();\n            var pointCount = manifold.pointCount;\n            this.v_invMassA = bodyA.m_invMass;\n            this.v_invMassB = bodyB.m_invMass;\n            this.v_invIA = bodyA.m_invI;\n            this.v_invIB = bodyB.m_invI;\n            this.v_friction = this.m_friction;\n            this.v_restitution = this.m_restitution;\n            this.v_tangentSpeed = this.m_tangentSpeed;\n            this.v_pointCount = pointCount;\n            this.v_K.setZero();\n            this.v_normalMass.setZero();\n            this.p_invMassA = bodyA.m_invMass;\n            this.p_invMassB = bodyB.m_invMass;\n            this.p_invIA = bodyA.m_invI;\n            this.p_invIB = bodyB.m_invI;\n            this.p_localCenterA = Vec2.clone(bodyA.m_sweep.localCenter);\n            this.p_localCenterB = Vec2.clone(bodyB.m_sweep.localCenter);\n            this.p_radiusA = shapeA.m_radius;\n            this.p_radiusB = shapeB.m_radius;\n            this.p_type = manifold.type;\n            this.p_localNormal = Vec2.clone(manifold.localNormal);\n            this.p_localPoint = Vec2.clone(manifold.localPoint);\n            this.p_pointCount = pointCount;\n            for (var j = 0; j < pointCount; ++j) {\n                var cp = manifold.points[j];\n                var vcp = this.v_points[j] = new VelocityConstraintPoint();\n                if (step.warmStarting) {\n                    vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n                    vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n                }\n                else {\n                    vcp.normalImpulse = 0.0;\n                    vcp.tangentImpulse = 0.0;\n                }\n                vcp.rA.setZero();\n                vcp.rB.setZero();\n                vcp.normalMass = 0.0;\n                vcp.tangentMass = 0.0;\n                vcp.velocityBias = 0.0;\n                this.p_localPoints[j] = Vec2.clone(cp.localPoint);\n            }\n        };\n        /**\n         * Get the contact manifold. Do not modify the manifold unless you understand\n         * the internals of the library.\n         */\n        Contact.prototype.getManifold = function () {\n            return this.m_manifold;\n        };\n        /**\n         * Get the world manifold.\n         */\n        Contact.prototype.getWorldManifold = function (worldManifold) {\n            var bodyA = this.m_fixtureA.getBody();\n            var bodyB = this.m_fixtureB.getBody();\n            var shapeA = this.m_fixtureA.getShape();\n            var shapeB = this.m_fixtureB.getShape();\n            return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);\n        };\n        /**\n         * Enable/disable this contact. This can be used inside the pre-solve contact\n         * listener. The contact is only disabled for the current time step (or sub-step\n         * in continuous collisions).\n         */\n        Contact.prototype.setEnabled = function (flag) {\n            this.m_enabledFlag = !!flag;\n        };\n        /**\n         * Has this contact been disabled?\n         */\n        Contact.prototype.isEnabled = function () {\n            return this.m_enabledFlag;\n        };\n        /**\n         * Is this contact touching?\n         */\n        Contact.prototype.isTouching = function () {\n            return this.m_touchingFlag;\n        };\n        /**\n         * Get the next contact in the world's contact list.\n         */\n        Contact.prototype.getNext = function () {\n            return this.m_next;\n        };\n        /**\n         * Get fixture A in this contact.\n         */\n        Contact.prototype.getFixtureA = function () {\n            return this.m_fixtureA;\n        };\n        /**\n         * Get fixture B in this contact.\n         */\n        Contact.prototype.getFixtureB = function () {\n            return this.m_fixtureB;\n        };\n        /**\n         * Get the child primitive index for fixture A.\n         */\n        Contact.prototype.getChildIndexA = function () {\n            return this.m_indexA;\n        };\n        /**\n         * Get the child primitive index for fixture B.\n         */\n        Contact.prototype.getChildIndexB = function () {\n            return this.m_indexB;\n        };\n        /**\n         * Flag this contact for filtering. Filtering will occur the next time step.\n         */\n        Contact.prototype.flagForFiltering = function () {\n            this.m_filterFlag = true;\n        };\n        /**\n         * Override the default friction mixture. You can call this in\n         * ContactListener.preSolve. This value persists until set or reset.\n         */\n        Contact.prototype.setFriction = function (friction) {\n            this.m_friction = friction;\n        };\n        /**\n         * Get the friction.\n         */\n        Contact.prototype.getFriction = function () {\n            return this.m_friction;\n        };\n        /**\n         * Reset the friction mixture to the default value.\n         */\n        Contact.prototype.resetFriction = function () {\n            this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n        };\n        /**\n         * Override the default restitution mixture. You can call this in\n         * ContactListener.preSolve. The value persists until you set or reset.\n         */\n        Contact.prototype.setRestitution = function (restitution) {\n            this.m_restitution = restitution;\n        };\n        /**\n         * Get the restitution.\n         */\n        Contact.prototype.getRestitution = function () {\n            return this.m_restitution;\n        };\n        /**\n         * Reset the restitution to the default value.\n         */\n        Contact.prototype.resetRestitution = function () {\n            this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n        };\n        /**\n         * Set the desired tangent speed for a conveyor belt behavior. In meters per\n         * second.\n         */\n        Contact.prototype.setTangentSpeed = function (speed) {\n            this.m_tangentSpeed = speed;\n        };\n        /**\n         * Get the desired tangent speed. In meters per second.\n         */\n        Contact.prototype.getTangentSpeed = function () {\n            return this.m_tangentSpeed;\n        };\n        /**\n         * Called by Update method, and implemented by subclasses.\n         */\n        Contact.prototype.evaluate = function (manifold, xfA, xfB) {\n            this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB, this.m_fixtureB, this.m_indexB);\n        };\n        /**\n         * Updates the contact manifold and touching status.\n         *\n         * Note: do not assume the fixture AABBs are overlapping or are valid.\n         *\n         * @param listener.beginContact\n         * @param listener.endContact\n         * @param listener.preSolve\n         */\n        Contact.prototype.update = function (listener) {\n            // Re-enable this contact.\n            this.m_enabledFlag = true;\n            var touching = false;\n            var wasTouching = this.m_touchingFlag;\n            var sensorA = this.m_fixtureA.isSensor();\n            var sensorB = this.m_fixtureB.isSensor();\n            var sensor = sensorA || sensorB;\n            var bodyA = this.m_fixtureA.getBody();\n            var bodyB = this.m_fixtureB.getBody();\n            var xfA = bodyA.getTransform();\n            var xfB = bodyB.getTransform();\n            var oldManifold;\n            // Is this contact a sensor?\n            if (sensor) {\n                var shapeA = this.m_fixtureA.getShape();\n                var shapeB = this.m_fixtureB.getShape();\n                touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n                // Sensors don't generate manifolds.\n                this.m_manifold.pointCount = 0;\n            }\n            else {\n                // TODO reuse manifold\n                oldManifold = this.m_manifold;\n                this.m_manifold = new Manifold();\n                this.evaluate(this.m_manifold, xfA, xfB);\n                touching = this.m_manifold.pointCount > 0;\n                // Match old contact ids to new contact ids and copy the\n                // stored impulses to warm start the solver.\n                for (var i = 0; i < this.m_manifold.pointCount; ++i) {\n                    var nmp = this.m_manifold.points[i];\n                    nmp.normalImpulse = 0.0;\n                    nmp.tangentImpulse = 0.0;\n                    for (var j = 0; j < oldManifold.pointCount; ++j) {\n                        var omp = oldManifold.points[j];\n                        if (omp.id.key == nmp.id.key) {\n                            nmp.normalImpulse = omp.normalImpulse;\n                            nmp.tangentImpulse = omp.tangentImpulse;\n                            break;\n                        }\n                    }\n                }\n                if (touching != wasTouching) {\n                    bodyA.setAwake(true);\n                    bodyB.setAwake(true);\n                }\n            }\n            this.m_touchingFlag = touching;\n            if (!wasTouching && touching && listener) {\n                listener.beginContact(this);\n            }\n            if (wasTouching && !touching && listener) {\n                listener.endContact(this);\n            }\n            if (!sensor && touching && listener) {\n                listener.preSolve(this, oldManifold);\n            }\n        };\n        Contact.prototype.solvePositionConstraint = function (step) {\n            return this._solvePositionConstraint(step);\n        };\n        Contact.prototype.solvePositionConstraintTOI = function (step, toiA, toiB) {\n            return this._solvePositionConstraint(step, toiA, toiB);\n        };\n        Contact.prototype._solvePositionConstraint = function (step, toiA, toiB) {\n            var toi = !!toiA && !!toiB;\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            bodyA.c_velocity;\n            bodyB.c_velocity;\n            var positionA = bodyA.c_position;\n            var positionB = bodyB.c_position;\n            var localCenterA = Vec2.clone(this.p_localCenterA);\n            var localCenterB = Vec2.clone(this.p_localCenterB);\n            var mA = 0.0;\n            var iA = 0.0;\n            if (!toi || (bodyA == toiA || bodyA == toiB)) {\n                mA = this.p_invMassA;\n                iA = this.p_invIA;\n            }\n            var mB = 0.0;\n            var iB = 0.0;\n            if (!toi || (bodyB == toiA || bodyB == toiB)) {\n                mB = this.p_invMassB;\n                iB = this.p_invIB;\n            }\n            var cA = Vec2.clone(positionA.c);\n            var aA = positionA.a;\n            var cB = Vec2.clone(positionB.c);\n            var aB = positionB.a;\n            var minSeparation = 0.0;\n            // Solve normal constraints\n            for (var j = 0; j < this.p_pointCount; ++j) {\n                var xfA = Transform.identity();\n                var xfB = Transform.identity();\n                xfA.q.setAngle(aA);\n                xfB.q.setAngle(aB);\n                xfA.p = Vec2.sub(cA, Rot.mulVec2(xfA.q, localCenterA));\n                xfB.p = Vec2.sub(cB, Rot.mulVec2(xfB.q, localCenterB));\n                // PositionSolverManifold\n                var normal = void 0;\n                var point = void 0;\n                var separation = void 0;\n                switch (this.p_type) {\n                    case ManifoldType.e_circles: {\n                        var pointA = Transform.mulVec2(xfA, this.p_localPoint);\n                        var pointB = Transform.mulVec2(xfB, this.p_localPoints[0]);\n                        normal = Vec2.sub(pointB, pointA);\n                        normal.normalize();\n                        point = Vec2.combine(0.5, pointA, 0.5, pointB);\n                        separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA - this.p_radiusB;\n                        break;\n                    }\n                    case ManifoldType.e_faceA: {\n                        normal = Rot.mulVec2(xfA.q, this.p_localNormal);\n                        var planePoint = Transform.mulVec2(xfA, this.p_localPoint);\n                        var clipPoint = Transform.mulVec2(xfB, this.p_localPoints[j]);\n                        separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n                        point = clipPoint;\n                        break;\n                    }\n                    case ManifoldType.e_faceB: {\n                        normal = Rot.mulVec2(xfB.q, this.p_localNormal);\n                        var planePoint = Transform.mulVec2(xfB, this.p_localPoint);\n                        var clipPoint = Transform.mulVec2(xfA, this.p_localPoints[j]);\n                        separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n                        point = clipPoint;\n                        // Ensure normal points from A to B\n                        normal.mul(-1);\n                        break;\n                    }\n                }\n                var rA = Vec2.sub(point, cA);\n                var rB = Vec2.sub(point, cB);\n                // Track max constraint error.\n                minSeparation = math.min(minSeparation, separation);\n                var baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n                var linearSlop = Settings.linearSlop;\n                var maxLinearCorrection = Settings.maxLinearCorrection;\n                // Prevent large corrections and allow slop.\n                var C = math.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n                // Compute the effective mass.\n                var rnA = Vec2.crossVec2Vec2(rA, normal);\n                var rnB = Vec2.crossVec2Vec2(rB, normal);\n                var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n                // Compute normal impulse\n                var impulse = K > 0.0 ? -C / K : 0.0;\n                var P = Vec2.mulNumVec2(impulse, normal);\n                cA.subMul(mA, P);\n                aA -= iA * Vec2.crossVec2Vec2(rA, P);\n                cB.addMul(mB, P);\n                aB += iB * Vec2.crossVec2Vec2(rB, P);\n            }\n            positionA.c.setVec2(cA);\n            positionA.a = aA;\n            positionB.c.setVec2(cB);\n            positionB.a = aB;\n            return minSeparation;\n        };\n        Contact.prototype.initVelocityConstraint = function (step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var velocityA = bodyA.c_velocity;\n            var velocityB = bodyB.c_velocity;\n            var positionA = bodyA.c_position;\n            var positionB = bodyB.c_position;\n            var radiusA = this.p_radiusA;\n            var radiusB = this.p_radiusB;\n            var manifold = this.getManifold();\n            var mA = this.v_invMassA;\n            var mB = this.v_invMassB;\n            var iA = this.v_invIA;\n            var iB = this.v_invIB;\n            var localCenterA = Vec2.clone(this.p_localCenterA);\n            var localCenterB = Vec2.clone(this.p_localCenterB);\n            var cA = Vec2.clone(positionA.c);\n            var aA = positionA.a;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var cB = Vec2.clone(positionB.c);\n            var aB = positionB.a;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            xfA.q.setAngle(aA);\n            xfB.q.setAngle(aB);\n            xfA.p.setCombine(1, cA, -1, Rot.mulVec2(xfA.q, localCenterA));\n            xfB.p.setCombine(1, cB, -1, Rot.mulVec2(xfB.q, localCenterB));\n            var worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);\n            this.v_normal.setVec2(worldManifold.normal);\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                vcp.rA.setVec2(Vec2.sub(worldManifold.points[j], cA));\n                vcp.rB.setVec2(Vec2.sub(worldManifold.points[j], cB));\n                var rnA = Vec2.crossVec2Vec2(vcp.rA, this.v_normal);\n                var rnB = Vec2.crossVec2Vec2(vcp.rB, this.v_normal);\n                var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n                vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n                var tangent = Vec2.crossVec2Num(this.v_normal, 1.0);\n                var rtA = Vec2.crossVec2Vec2(vcp.rA, tangent);\n                var rtB = Vec2.crossVec2Vec2(vcp.rB, tangent);\n                var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n                vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n                // Setup a velocity bias for restitution.\n                vcp.velocityBias = 0.0;\n                var vRel = Vec2.dot(this.v_normal, vB)\n                    + Vec2.dot(this.v_normal, Vec2.crossNumVec2(wB, vcp.rB))\n                    - Vec2.dot(this.v_normal, vA)\n                    - Vec2.dot(this.v_normal, Vec2.crossNumVec2(wA, vcp.rA));\n                if (vRel < -Settings.velocityThreshold) {\n                    vcp.velocityBias = -this.v_restitution * vRel;\n                }\n            }\n            // If we have two points, then prepare the block solver.\n            if (this.v_pointCount == 2 && step.blockSolve) {\n                var vcp1 = this.v_points[0]; // VelocityConstraintPoint\n                var vcp2 = this.v_points[1]; // VelocityConstraintPoint\n                var rn1A = Vec2.crossVec2Vec2(vcp1.rA, this.v_normal);\n                var rn1B = Vec2.crossVec2Vec2(vcp1.rB, this.v_normal);\n                var rn2A = Vec2.crossVec2Vec2(vcp2.rA, this.v_normal);\n                var rn2B = Vec2.crossVec2Vec2(vcp2.rB, this.v_normal);\n                var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n                var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n                var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n                // Ensure a reasonable condition number.\n                var k_maxConditionNumber = 1000.0;\n                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n                    // K is safe to invert.\n                    this.v_K.ex.setNum(k11, k12);\n                    this.v_K.ey.setNum(k12, k22);\n                    this.v_normalMass.set(this.v_K.getInverse());\n                }\n                else {\n                    // The constraints are redundant, just use one.\n                    // TODO_ERIN use deepest?\n                    this.v_pointCount = 1;\n                }\n            }\n            positionA.c.setVec2(cA);\n            positionA.a = aA;\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            positionB.c.setVec2(cB);\n            positionB.a = aB;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        Contact.prototype.warmStartConstraint = function (step) {\n            var fixtureA = this.m_fixtureA;\n            var fixtureB = this.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            var velocityA = bodyA.c_velocity;\n            var velocityB = bodyB.c_velocity;\n            bodyA.c_position;\n            bodyB.c_position;\n            var mA = this.v_invMassA;\n            var iA = this.v_invIA;\n            var mB = this.v_invMassB;\n            var iB = this.v_invIB;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var normal = this.v_normal;\n            var tangent = Vec2.crossVec2Num(normal, 1.0);\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                var P = Vec2.combine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n                wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                vA.subMul(mA, P);\n                wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n                vB.addMul(mB, P);\n            }\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        Contact.prototype.storeConstraintImpulses = function (step) {\n            var manifold = this.m_manifold;\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n                manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n            }\n        };\n        Contact.prototype.solveVelocityConstraint = function (step) {\n            var bodyA = this.m_fixtureA.m_body;\n            var bodyB = this.m_fixtureB.m_body;\n            var velocityA = bodyA.c_velocity;\n            bodyA.c_position;\n            var velocityB = bodyB.c_velocity;\n            bodyB.c_position;\n            var mA = this.v_invMassA;\n            var iA = this.v_invIA;\n            var mB = this.v_invMassB;\n            var iB = this.v_invIB;\n            var vA = Vec2.clone(velocityA.v);\n            var wA = velocityA.w;\n            var vB = Vec2.clone(velocityB.v);\n            var wB = velocityB.w;\n            var normal = this.v_normal;\n            var tangent = Vec2.crossVec2Num(normal, 1.0);\n            var friction = this.v_friction;\n            // Solve tangent constraints first because non-penetration is more important\n            // than friction.\n            for (var j = 0; j < this.v_pointCount; ++j) {\n                var vcp = this.v_points[j]; // VelocityConstraintPoint\n                // Relative velocity at contact\n                var dv = Vec2.zero();\n                dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n                dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n                // Compute tangent force\n                var vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;\n                var lambda = vcp.tangentMass * (-vt);\n                // Clamp the accumulated force\n                var maxFriction = friction * vcp.normalImpulse;\n                var newImpulse = math.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n                lambda = newImpulse - vcp.tangentImpulse;\n                vcp.tangentImpulse = newImpulse;\n                // Apply contact impulse\n                var P = Vec2.mulNumVec2(lambda, tangent);\n                vA.subMul(mA, P);\n                wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                vB.addMul(mB, P);\n                wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n            }\n            // Solve normal constraints\n            if (this.v_pointCount == 1 || step.blockSolve == false) {\n                for (var i = 0; i < this.v_pointCount; ++i) {\n                    var vcp = this.v_points[i]; // VelocityConstraintPoint\n                    // Relative velocity at contact\n                    var dv = Vec2.zero();\n                    dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n                    dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n                    // Compute normal impulse\n                    var vn = Vec2.dot(dv, normal);\n                    var lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n                    // Clamp the accumulated impulse\n                    var newImpulse = math.max(vcp.normalImpulse + lambda, 0.0);\n                    lambda = newImpulse - vcp.normalImpulse;\n                    vcp.normalImpulse = newImpulse;\n                    // Apply contact impulse\n                    var P = Vec2.mulNumVec2(lambda, normal);\n                    vA.subMul(mA, P);\n                    wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n                    vB.addMul(mB, P);\n                    wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n                }\n            }\n            else {\n                // Block solver developed in collaboration with Dirk Gregorius (back in\n                // 01/07 on Box2D_Lite).\n                // Build the mini LCP for this contact patch\n                //\n                // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =\n                // 1..2\n                //\n                // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n                // b = vn0 - velocityBias\n                //\n                // The system is solved using the \"Total enumeration method\" (s. Murty).\n                // The complementary constraint vn_i * x_i\n                // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n                // So for the 2D contact problem the cases\n                // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n                // vn1 = 0 need to be tested. The first valid\n                // solution that satisfies the problem is chosen.\n                //\n                // In order to account of the accumulated impulse 'a' (because of the\n                // iterative nature of the solver which only requires\n                // that the accumulated impulse is clamped and not the incremental\n                // impulse) we change the impulse variable (x_i).\n                //\n                // Substitute:\n                //\n                // x = a + d\n                //\n                // a := old total impulse\n                // x := new total impulse\n                // d := incremental impulse\n                //\n                // For the current iteration we extend the formula for the incremental\n                // impulse\n                // to compute the new total impulse:\n                //\n                // vn = A * d + b\n                // = A * (x - a) + b\n                // = A * x + b - A * a\n                // = A * x + b'\n                // b' = b - A * a;\n                var vcp1 = this.v_points[0]; // VelocityConstraintPoint\n                var vcp2 = this.v_points[1]; // VelocityConstraintPoint\n                var a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);\n                // Relative velocity at contact\n                var dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n                var dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n                // Compute normal velocity\n                var vn1 = Vec2.dot(dv1, normal);\n                var vn2 = Vec2.dot(dv2, normal);\n                var b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n                // Compute b'\n                b.sub(Mat22.mulVec2(this.v_K, a));\n                // NOT_USED(k_errorTol);\n                while (true) {\n                    //\n                    // Case 1: vn = 0\n                    //\n                    // 0 = A * x + b'\n                    //\n                    // Solve for x:\n                    //\n                    // x = - inv(A) * b'\n                    //\n                    var x = Mat22.mulVec2(this.v_normalMass, b).neg();\n                    if (x.x >= 0.0 && x.y >= 0.0) {\n                        // Get the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 2: vn1 = 0 and x2 = 0\n                    //\n                    // 0 = a11 * x1 + a12 * 0 + b1'\n                    // vn2 = a21 * x1 + a22 * 0 + b2'\n                    //\n                    x.x = -vcp1.normalMass * b.x;\n                    x.y = 0.0;\n                    vn1 = 0.0;\n                    vn2 = this.v_K.ex.y * x.x + b.y;\n                    if (x.x >= 0.0 && vn2 >= 0.0) {\n                        // Get the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 3: vn2 = 0 and x1 = 0\n                    //\n                    // vn1 = a11 * 0 + a12 * x2 + b1'\n                    // 0 = a21 * 0 + a22 * x2 + b2'\n                    //\n                    x.x = 0.0;\n                    x.y = -vcp2.normalMass * b.y;\n                    vn1 = this.v_K.ey.x * x.y + b.x;\n                    vn2 = 0.0;\n                    if (x.y >= 0.0 && vn1 >= 0.0) {\n                        // Resubstitute for the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    //\n                    // Case 4: x1 = 0 and x2 = 0\n                    //\n                    // vn1 = b1\n                    // vn2 = b2;\n                    //\n                    x.x = 0.0;\n                    x.y = 0.0;\n                    vn1 = b.x;\n                    vn2 = b.y;\n                    if (vn1 >= 0.0 && vn2 >= 0.0) {\n                        // Resubstitute for the incremental impulse\n                        var d = Vec2.sub(x, a);\n                        // Apply incremental impulse\n                        var P1 = Vec2.mulNumVec2(d.x, normal);\n                        var P2 = Vec2.mulNumVec2(d.y, normal);\n                        vA.subCombine(mA, P1, mA, P2);\n                        wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n                        vB.addCombine(mB, P1, mB, P2);\n                        wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n                        // Accumulate\n                        vcp1.normalImpulse = x.x;\n                        vcp2.normalImpulse = x.y;\n                        break;\n                    }\n                    // No solution, give up. This is hit sometimes, but it doesn't seem to\n                    // matter.\n                    break;\n                }\n            }\n            velocityA.v.setVec2(vA);\n            velocityA.w = wA;\n            velocityB.v.setVec2(vB);\n            velocityB.w = wB;\n        };\n        /**\n         * @internal\n         */\n        Contact.addType = function (type1, type2, callback) {\n            s_registers[type1] = s_registers[type1] || {};\n            s_registers[type1][type2] = callback;\n        };\n        /**\n         * @internal\n         */\n        Contact.create = function (fixtureA, indexA, fixtureB, indexB) {\n            var typeA = fixtureA.getType();\n            var typeB = fixtureB.getType();\n            // TODO: pool contacts\n            var contact;\n            var evaluateFcn;\n            if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n                contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n            }\n            else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n                contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n            }\n            else {\n                return null;\n            }\n            // Contact creation may swap fixtures.\n            fixtureA = contact.getFixtureA();\n            fixtureB = contact.getFixtureB();\n            indexA = contact.getChildIndexA();\n            indexB = contact.getChildIndexB();\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            // Connect to body A\n            contact.m_nodeA.contact = contact;\n            contact.m_nodeA.other = bodyB;\n            contact.m_nodeA.prev = null;\n            contact.m_nodeA.next = bodyA.m_contactList;\n            if (bodyA.m_contactList != null) {\n                bodyA.m_contactList.prev = contact.m_nodeA;\n            }\n            bodyA.m_contactList = contact.m_nodeA;\n            // Connect to body B\n            contact.m_nodeB.contact = contact;\n            contact.m_nodeB.other = bodyA;\n            contact.m_nodeB.prev = null;\n            contact.m_nodeB.next = bodyB.m_contactList;\n            if (bodyB.m_contactList != null) {\n                bodyB.m_contactList.prev = contact.m_nodeB;\n            }\n            bodyB.m_contactList = contact.m_nodeB;\n            // Wake up the bodies\n            if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n                bodyA.setAwake(true);\n                bodyB.setAwake(true);\n            }\n            return contact;\n        };\n        /**\n         * @internal\n         */\n        Contact.destroy = function (contact, listener) {\n            var fixtureA = contact.m_fixtureA;\n            var fixtureB = contact.m_fixtureB;\n            var bodyA = fixtureA.getBody();\n            var bodyB = fixtureB.getBody();\n            if (contact.isTouching()) {\n                listener.endContact(contact);\n            }\n            // Remove from body 1\n            if (contact.m_nodeA.prev) {\n                contact.m_nodeA.prev.next = contact.m_nodeA.next;\n            }\n            if (contact.m_nodeA.next) {\n                contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n            }\n            if (contact.m_nodeA == bodyA.m_contactList) {\n                bodyA.m_contactList = contact.m_nodeA.next;\n            }\n            // Remove from body 2\n            if (contact.m_nodeB.prev) {\n                contact.m_nodeB.prev.next = contact.m_nodeB.next;\n            }\n            if (contact.m_nodeB.next) {\n                contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n            }\n            if (contact.m_nodeB == bodyB.m_contactList) {\n                bodyB.m_contactList = contact.m_nodeB.next;\n            }\n            if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false\n                && fixtureB.isSensor() == false) {\n                bodyA.setAwake(true);\n                bodyB.setAwake(true);\n            }\n            fixtureA.getType();\n            fixtureB.getType();\n            // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n            // if (typeof destroyFcn === 'function') {\n            //   destroyFcn(contact);\n            // }\n        };\n        return Contact;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A joint edge is used to connect bodies and joints together in a joint graph\n     * where each body is a node and each joint is an edge. A joint edge belongs to\n     * a doubly linked list maintained in each attached body. Each joint has two\n     * joint nodes, one for each attached body.\n     */\n    var JointEdge = /** @class */ (function () {\n        function JointEdge() {\n            /**\n             * provides quick access to the other body attached.\n             */\n            this.other = null;\n            /**\n             * the joint\n             */\n            this.joint = null;\n            /**\n             * prev the previous joint edge in the body's joint list\n             */\n            this.prev = null;\n            /**\n             * the next joint edge in the body's joint list\n             */\n            this.next = null;\n        }\n        return JointEdge;\n    }());\n    /**\n     * The base joint class. Joints are used to constraint two bodies together in\n     * various fashions. Some joints also feature limits and motors.\n     */\n    var Joint = /** @class */ (function () {\n        function Joint(def, bodyA, bodyB) {\n            /** @internal */ this.m_type = 'unknown-joint';\n            /** @internal */ this.m_prev = null;\n            /** @internal */ this.m_next = null;\n            /** @internal */ this.m_edgeA = new JointEdge();\n            /** @internal */ this.m_edgeB = new JointEdge();\n            /** @internal */ this.m_islandFlag = false;\n            bodyA = 'bodyA' in def ? def.bodyA : bodyA;\n            bodyB = 'bodyB' in def ? def.bodyB : bodyB;\n            this.m_bodyA = bodyA;\n            this.m_bodyB = bodyB;\n            this.m_collideConnected = !!def.collideConnected;\n            this.m_userData = def.userData;\n        }\n        /**\n         * Short-cut function to determine if either body is inactive.\n         */\n        Joint.prototype.isActive = function () {\n            return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n        };\n        /**\n         * Get the type of the concrete joint.\n         */\n        Joint.prototype.getType = function () {\n            return this.m_type;\n        };\n        /**\n         * Get the first body attached to this joint.\n         */\n        Joint.prototype.getBodyA = function () {\n            return this.m_bodyA;\n        };\n        /**\n         * Get the second body attached to this joint.\n         */\n        Joint.prototype.getBodyB = function () {\n            return this.m_bodyB;\n        };\n        /**\n         * Get the next joint the world joint list.\n         */\n        Joint.prototype.getNext = function () {\n            return this.m_next;\n        };\n        Joint.prototype.getUserData = function () {\n            return this.m_userData;\n        };\n        Joint.prototype.setUserData = function (data) {\n            this.m_userData = data;\n        };\n        /**\n         * Get collide connected. Note: modifying the collide connect flag won't work\n         * correctly because the flag is only checked when fixture AABBs begin to\n         * overlap.\n         */\n        Joint.prototype.getCollideConnected = function () {\n            return this.m_collideConnected;\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         */\n        Joint.prototype.shiftOrigin = function (newOrigin) { };\n        return Joint;\n    }());\n\n    var now = function () {\n        return Date.now();\n    };\n    var diff = function (time) {\n        return Date.now() - time;\n    };\n    var Timer = {\n        now: now,\n        diff: diff,\n    };\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * Input parameters for TimeOfImpact.\n     */\n    var TOIInput = /** @class */ (function () {\n        function TOIInput() {\n            this.proxyA = new DistanceProxy();\n            this.proxyB = new DistanceProxy();\n            this.sweepA = new Sweep();\n            this.sweepB = new Sweep();\n        }\n        return TOIInput;\n    }());\n    var TOIOutputState;\n    (function (TOIOutputState) {\n        TOIOutputState[TOIOutputState[\"e_unknown\"] = 0] = \"e_unknown\";\n        TOIOutputState[TOIOutputState[\"e_failed\"] = 1] = \"e_failed\";\n        TOIOutputState[TOIOutputState[\"e_overlapped\"] = 2] = \"e_overlapped\";\n        TOIOutputState[TOIOutputState[\"e_touching\"] = 3] = \"e_touching\";\n        TOIOutputState[TOIOutputState[\"e_separated\"] = 4] = \"e_separated\";\n    })(TOIOutputState || (TOIOutputState = {}));\n    /**\n     * Output parameters for TimeOfImpact.\n     */\n    var TOIOutput = /** @class */ (function () {\n        function TOIOutput() {\n        }\n        return TOIOutput;\n    }());\n    stats.toiTime = 0;\n    stats.toiMaxTime = 0;\n    stats.toiCalls = 0;\n    stats.toiIters = 0;\n    stats.toiMaxIters = 0;\n    stats.toiRootIters = 0;\n    stats.toiMaxRootIters = 0;\n    /**\n     * Compute the upper bound on time before two shapes penetrate. Time is\n     * represented as a fraction between [0,tMax]. This uses a swept separating axis\n     * and may miss some intermediate, non-tunneling collision. If you change the\n     * time interval, you should call this function again.\n     *\n     * Note: use Distance to compute the contact point and normal at the time of\n     * impact.\n     *\n     * CCD via the local separating axis method. This seeks progression by computing\n     * the largest time at which separation is maintained.\n     */\n    function TimeOfImpact(output, input) {\n        var timer = Timer.now();\n        ++stats.toiCalls;\n        output.state = TOIOutputState.e_unknown;\n        output.t = input.tMax;\n        var proxyA = input.proxyA; // DistanceProxy\n        var proxyB = input.proxyB; // DistanceProxy\n        var sweepA = input.sweepA; // Sweep\n        var sweepB = input.sweepB; // Sweep\n        // Large rotations can make the root finder fail, so we normalize the\n        // sweep angles.\n        sweepA.normalize();\n        sweepB.normalize();\n        var tMax = input.tMax;\n        var totalRadius = proxyA.m_radius + proxyB.m_radius;\n        var target = math.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n        var tolerance = 0.25 * Settings.linearSlop;\n        var t1 = 0.0;\n        var k_maxIterations = Settings.maxTOIIterations;\n        var iter = 0;\n        // Prepare input for distance query.\n        var cache = new SimplexCache();\n        var distanceInput = new DistanceInput();\n        distanceInput.proxyA = input.proxyA;\n        distanceInput.proxyB = input.proxyB;\n        distanceInput.useRadii = false;\n        // The outer loop progressively attempts to compute new separating axes.\n        // This loop terminates when an axis is repeated (no progress is made).\n        while (true) {\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            sweepA.getTransform(xfA, t1);\n            sweepB.getTransform(xfB, t1);\n            // Get the distance between shapes. We can also use the results\n            // to get a separating axis.\n            distanceInput.transformA = xfA;\n            distanceInput.transformB = xfB;\n            var distanceOutput = new DistanceOutput();\n            Distance(distanceOutput, cache, distanceInput);\n            // If the shapes are overlapped, we give up on continuous collision.\n            if (distanceOutput.distance <= 0.0) {\n                // Failure!\n                output.state = TOIOutputState.e_overlapped;\n                output.t = 0.0;\n                break;\n            }\n            if (distanceOutput.distance < target + tolerance) {\n                // Victory!\n                output.state = TOIOutputState.e_touching;\n                output.t = t1;\n                break;\n            }\n            // Initialize the separating axis.\n            var fcn = new SeparationFunction();\n            fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n            // if (false) {\n            //   // Dump the curve seen by the root finder\n            //   const N = 100;\n            //   const dx = 1.0 / N;\n            //   const xs = []; // [ N + 1 ];\n            //   const fs = []; // [ N + 1 ];\n            //   const x = 0.0;\n            //   for (const i = 0; i <= N; ++i) {\n            //     sweepA.getTransform(xfA, x);\n            //     sweepB.getTransform(xfB, x);\n            //     const f = fcn.evaluate(xfA, xfB) - target;\n            //     printf(\"%g %g\\n\", x, f);\n            //     xs[i] = x;\n            //     fs[i] = f;\n            //     x += dx;\n            //   }\n            // }\n            // Compute the TOI on the separating axis. We do this by successively\n            // resolving the deepest point. This loop is bounded by the number of\n            // vertices.\n            var done = false;\n            var t2 = tMax;\n            var pushBackIter = 0;\n            while (true) {\n                // Find the deepest point at t2. Store the witness point indices.\n                var s2 = fcn.findMinSeparation(t2);\n                // const indexA = fcn.indexA;\n                // const indexB = fcn.indexB;\n                // Is the final configuration separated?\n                if (s2 > target + tolerance) {\n                    // Victory!\n                    output.state = TOIOutputState.e_separated;\n                    output.t = tMax;\n                    done = true;\n                    break;\n                }\n                // Has the separation reached tolerance?\n                if (s2 > target - tolerance) {\n                    // Advance the sweeps\n                    t1 = t2;\n                    break;\n                }\n                // Compute the initial separation of the witness points.\n                var s1 = fcn.evaluate(t1);\n                // const indexA = fcn.indexA;\n                // const indexB = fcn.indexB;\n                // Check for initial overlap. This might happen if the root finder\n                // runs out of iterations.\n                if (s1 < target - tolerance) {\n                    output.state = TOIOutputState.e_failed;\n                    output.t = t1;\n                    done = true;\n                    break;\n                }\n                // Check for touching\n                if (s1 <= target + tolerance) {\n                    // Victory! t1 should hold the TOI (could be 0.0).\n                    output.state = TOIOutputState.e_touching;\n                    output.t = t1;\n                    done = true;\n                    break;\n                }\n                // Compute 1D root of: f(x) - target = 0\n                var rootIterCount = 0;\n                var a1 = t1;\n                var a2 = t2;\n                while (true) {\n                    // Use a mix of the secant rule and bisection.\n                    var t = void 0;\n                    if (rootIterCount & 1) {\n                        // Secant rule to improve convergence.\n                        t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n                    }\n                    else {\n                        // Bisection to guarantee progress.\n                        t = 0.5 * (a1 + a2);\n                    }\n                    ++rootIterCount;\n                    ++stats.toiRootIters;\n                    var s = fcn.evaluate(t);\n                    fcn.indexA;\n                    fcn.indexB;\n                    if (math.abs(s - target) < tolerance) {\n                        // t2 holds a tentative value for t1\n                        t2 = t;\n                        break;\n                    }\n                    // Ensure we continue to bracket the root.\n                    if (s > target) {\n                        a1 = t;\n                        s1 = s;\n                    }\n                    else {\n                        a2 = t;\n                        s2 = s;\n                    }\n                    if (rootIterCount === 50) {\n                        break;\n                    }\n                }\n                stats.toiMaxRootIters = math.max(stats.toiMaxRootIters, rootIterCount);\n                ++pushBackIter;\n                if (pushBackIter === Settings.maxPolygonVertices) {\n                    break;\n                }\n            }\n            ++iter;\n            ++stats.toiIters;\n            if (done) {\n                break;\n            }\n            if (iter === k_maxIterations) {\n                // Root finder got stuck. Semi-victory.\n                output.state = TOIOutputState.e_failed;\n                output.t = t1;\n                break;\n            }\n        }\n        stats.toiMaxIters = math.max(stats.toiMaxIters, iter);\n        var time = Timer.diff(timer);\n        stats.toiMaxTime = math.max(stats.toiMaxTime, time);\n        stats.toiTime += time;\n    }\n    var SeparationFunctionType;\n    (function (SeparationFunctionType) {\n        SeparationFunctionType[SeparationFunctionType[\"e_points\"] = 1] = \"e_points\";\n        SeparationFunctionType[SeparationFunctionType[\"e_faceA\"] = 2] = \"e_faceA\";\n        SeparationFunctionType[SeparationFunctionType[\"e_faceB\"] = 3] = \"e_faceB\";\n    })(SeparationFunctionType || (SeparationFunctionType = {}));\n    var SeparationFunction = /** @class */ (function () {\n        function SeparationFunction() {\n            this.m_proxyA = new DistanceProxy();\n            this.m_proxyB = new DistanceProxy();\n            this.m_localPoint = Vec2.zero();\n            this.m_axis = Vec2.zero();\n        }\n        // TODO_ERIN might not need to return the separation\n        SeparationFunction.prototype.initialize = function (cache, proxyA, sweepA, proxyB, sweepB, t1) {\n            this.m_proxyA = proxyA;\n            this.m_proxyB = proxyB;\n            var count = cache.count;\n            this.m_sweepA = sweepA;\n            this.m_sweepB = sweepB;\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            this.m_sweepA.getTransform(xfA, t1);\n            this.m_sweepB.getTransform(xfB, t1);\n            if (count === 1) {\n                this.m_type = SeparationFunctionType.e_points;\n                var localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n                var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n                var pointA = Transform.mulVec2(xfA, localPointA);\n                var pointB = Transform.mulVec2(xfB, localPointB);\n                this.m_axis.setCombine(1, pointB, -1, pointA);\n                var s = this.m_axis.normalize();\n                return s;\n            }\n            else if (cache.indexA[0] === cache.indexA[1]) {\n                // Two points on B and one on A.\n                this.m_type = SeparationFunctionType.e_faceB;\n                var localPointB1 = proxyB.getVertex(cache.indexB[0]);\n                var localPointB2 = proxyB.getVertex(cache.indexB[1]);\n                this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointB2, localPointB1), 1.0);\n                this.m_axis.normalize();\n                var normal = Rot.mulVec2(xfB.q, this.m_axis);\n                this.m_localPoint = Vec2.mid(localPointB1, localPointB2);\n                var pointB = Transform.mulVec2(xfB, this.m_localPoint);\n                var localPointA = proxyA.getVertex(cache.indexA[0]);\n                var pointA = Transform.mulVec2(xfA, localPointA);\n                var s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n                if (s < 0.0) {\n                    this.m_axis = Vec2.neg(this.m_axis);\n                    s = -s;\n                }\n                return s;\n            }\n            else {\n                // Two points on A and one or two points on B.\n                this.m_type = SeparationFunctionType.e_faceA;\n                var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n                var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n                this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointA2, localPointA1), 1.0);\n                this.m_axis.normalize();\n                var normal = Rot.mulVec2(xfA.q, this.m_axis);\n                this.m_localPoint = Vec2.mid(localPointA1, localPointA2);\n                var pointA = Transform.mulVec2(xfA, this.m_localPoint);\n                var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n                var pointB = Transform.mulVec2(xfB, localPointB);\n                var s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n                if (s < 0.0) {\n                    this.m_axis = Vec2.neg(this.m_axis);\n                    s = -s;\n                }\n                return s;\n            }\n        };\n        SeparationFunction.prototype.compute = function (find, t) {\n            // It was findMinSeparation and evaluate\n            var xfA = Transform.identity();\n            var xfB = Transform.identity();\n            this.m_sweepA.getTransform(xfA, t);\n            this.m_sweepB.getTransform(xfB, t);\n            switch (this.m_type) {\n                case SeparationFunctionType.e_points: {\n                    if (find) {\n                        var axisA = Rot.mulTVec2(xfA.q, this.m_axis);\n                        var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(this.m_axis));\n                        this.indexA = this.m_proxyA.getSupport(axisA);\n                        this.indexB = this.m_proxyB.getSupport(axisB);\n                    }\n                    var localPointA = this.m_proxyA.getVertex(this.indexA);\n                    var localPointB = this.m_proxyB.getVertex(this.indexB);\n                    var pointA = Transform.mulVec2(xfA, localPointA);\n                    var pointB = Transform.mulVec2(xfB, localPointB);\n                    var sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);\n                    return sep;\n                }\n                case SeparationFunctionType.e_faceA: {\n                    var normal = Rot.mulVec2(xfA.q, this.m_axis);\n                    var pointA = Transform.mulVec2(xfA, this.m_localPoint);\n                    if (find) {\n                        var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(normal));\n                        this.indexA = -1;\n                        this.indexB = this.m_proxyB.getSupport(axisB);\n                    }\n                    var localPointB = this.m_proxyB.getVertex(this.indexB);\n                    var pointB = Transform.mulVec2(xfB, localPointB);\n                    var sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n                    return sep;\n                }\n                case SeparationFunctionType.e_faceB: {\n                    var normal = Rot.mulVec2(xfB.q, this.m_axis);\n                    var pointB = Transform.mulVec2(xfB, this.m_localPoint);\n                    if (find) {\n                        var axisA = Rot.mulTVec2(xfA.q, Vec2.neg(normal));\n                        this.indexB = -1;\n                        this.indexA = this.m_proxyA.getSupport(axisA);\n                    }\n                    var localPointA = this.m_proxyA.getVertex(this.indexA);\n                    var pointA = Transform.mulVec2(xfA, localPointA);\n                    var sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n                    return sep;\n                }\n                default:\n                    if (find) {\n                        this.indexA = -1;\n                        this.indexB = -1;\n                    }\n                    return 0.0;\n            }\n        };\n        SeparationFunction.prototype.findMinSeparation = function (t) {\n            return this.compute(true, t);\n        };\n        SeparationFunction.prototype.evaluate = function (t) {\n            return this.compute(false, t);\n        };\n        return SeparationFunction;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var TimeStep = /** @class */ (function () {\n        function TimeStep() {\n            /** time step */\n            this.dt = 0;\n            /** inverse time step (0 if dt == 0) */\n            this.inv_dt = 0;\n            this.velocityIterations = 0;\n            this.positionIterations = 0;\n            this.warmStarting = false;\n            this.blockSolve = true;\n            /** timestep ratio for variable timestep */\n            this.inv_dt0 = 0.0;\n            /** dt * inv_dt0 */\n            this.dtRatio = 1;\n        }\n        TimeStep.prototype.reset = function (dt) {\n            if (this.dt > 0.0) {\n                this.inv_dt0 = this.inv_dt;\n            }\n            this.dt = dt;\n            this.inv_dt = dt == 0 ? 0 : 1 / dt;\n            this.dtRatio = dt * this.inv_dt0;\n        };\n        return TimeStep;\n    }());\n    // reuse\n    var s_subStep = new TimeStep();\n    /**\n     * Contact impulses for reporting. Impulses are used instead of forces because\n     * sub-step forces may approach infinity for rigid body collisions. These match\n     * up one-to-one with the contact points in Manifold.\n     */\n    var ContactImpulse = /** @class */ (function () {\n        function ContactImpulse(contact) {\n            this.contact = contact;\n            this.normals = [];\n            this.tangents = [];\n        }\n        Object.defineProperty(ContactImpulse.prototype, \"normalImpulses\", {\n            get: function () {\n                var contact = this.contact;\n                var normals = this.normals;\n                normals.length = 0;\n                for (var p = 0; p < contact.v_points.length; ++p) {\n                    normals.push(contact.v_points[p].normalImpulse);\n                }\n                return normals;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ContactImpulse.prototype, \"tangentImpulses\", {\n            get: function () {\n                var contact = this.contact;\n                var tangents = this.tangents;\n                tangents.length = 0;\n                for (var p = 0; p < contact.v_points.length; ++p) {\n                    tangents.push(contact.v_points[p].tangentImpulse);\n                }\n                return tangents;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return ContactImpulse;\n    }());\n    /**\n     * Finds and solves islands. An island is a connected subset of the world.\n     */\n    var Solver = /** @class */ (function () {\n        function Solver(world) {\n            this.m_world = world;\n            this.m_stack = [];\n            this.m_bodies = [];\n            this.m_contacts = [];\n            this.m_joints = [];\n        }\n        Solver.prototype.clear = function () {\n            this.m_stack.length = 0;\n            this.m_bodies.length = 0;\n            this.m_contacts.length = 0;\n            this.m_joints.length = 0;\n        };\n        Solver.prototype.addBody = function (body) {\n            this.m_bodies.push(body);\n            // why?\n            // body.c_position.c.setZero();\n            // body.c_position.a = 0;\n            // body.c_velocity.v.setZero();\n            // body.c_velocity.w = 0;\n        };\n        Solver.prototype.addContact = function (contact) {\n            this.m_contacts.push(contact);\n        };\n        Solver.prototype.addJoint = function (joint) {\n            this.m_joints.push(joint);\n        };\n        Solver.prototype.solveWorld = function (step) {\n            var world = this.m_world;\n            // Clear all the island flags.\n            for (var b = world.m_bodyList; b; b = b.m_next) {\n                b.m_islandFlag = false;\n            }\n            for (var c = world.m_contactList; c; c = c.m_next) {\n                c.m_islandFlag = false;\n            }\n            for (var j = world.m_jointList; j; j = j.m_next) {\n                j.m_islandFlag = false;\n            }\n            // Build and simulate all awake islands.\n            var stack = this.m_stack;\n            for (var seed = world.m_bodyList; seed; seed = seed.m_next) {\n                if (seed.m_islandFlag) {\n                    continue;\n                }\n                if (seed.isAwake() == false || seed.isActive() == false) {\n                    continue;\n                }\n                // The seed can be dynamic or kinematic.\n                if (seed.isStatic()) {\n                    continue;\n                }\n                // Reset island and stack.\n                this.clear();\n                stack.push(seed);\n                seed.m_islandFlag = true;\n                // Perform a depth first search (DFS) on the constraint graph.\n                while (stack.length > 0) {\n                    // Grab the next body off the stack and add it to the island.\n                    var b = stack.pop();\n                    this.addBody(b);\n                    // Make sure the body is awake.\n                    b.setAwake(true);\n                    // To keep islands as small as possible, we don't\n                    // propagate islands across static bodies.\n                    if (b.isStatic()) {\n                        continue;\n                    }\n                    // Search all contacts connected to this body.\n                    for (var ce = b.m_contactList; ce; ce = ce.next) {\n                        var contact = ce.contact;\n                        // Has this contact already been added to an island?\n                        if (contact.m_islandFlag) {\n                            continue;\n                        }\n                        // Is this contact solid and touching?\n                        if (contact.isEnabled() == false || contact.isTouching() == false) {\n                            continue;\n                        }\n                        // Skip sensors.\n                        var sensorA = contact.m_fixtureA.m_isSensor;\n                        var sensorB = contact.m_fixtureB.m_isSensor;\n                        if (sensorA || sensorB) {\n                            continue;\n                        }\n                        this.addContact(contact);\n                        contact.m_islandFlag = true;\n                        var other = ce.other;\n                        // Was the other body already added to this island?\n                        if (other.m_islandFlag) {\n                            continue;\n                        }\n                        // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n                        stack.push(other);\n                        other.m_islandFlag = true;\n                    }\n                    // Search all joints connect to this body.\n                    for (var je = b.m_jointList; je; je = je.next) {\n                        if (je.joint.m_islandFlag == true) {\n                            continue;\n                        }\n                        var other = je.other;\n                        // Don't simulate joints connected to inactive bodies.\n                        if (other.isActive() == false) {\n                            continue;\n                        }\n                        this.addJoint(je.joint);\n                        je.joint.m_islandFlag = true;\n                        if (other.m_islandFlag) {\n                            continue;\n                        }\n                        // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n                        stack.push(other);\n                        other.m_islandFlag = true;\n                    }\n                }\n                this.solveIsland(step);\n                // Post solve cleanup.\n                for (var i = 0; i < this.m_bodies.length; ++i) {\n                    // Allow static bodies to participate in other islands.\n                    // TODO: are they added at all?\n                    var b = this.m_bodies[i];\n                    if (b.isStatic()) {\n                        b.m_islandFlag = false;\n                    }\n                }\n            }\n        };\n        Solver.prototype.solveIsland = function (step) {\n            // B2: Island Solve\n            var world = this.m_world;\n            var gravity = world.m_gravity;\n            var allowSleep = world.m_allowSleep;\n            var h = step.dt;\n            // Integrate velocities and apply damping. Initialize the body state.\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.m_sweep.c);\n                var a = body.m_sweep.a;\n                var v = Vec2.clone(body.m_linearVelocity);\n                var w = body.m_angularVelocity;\n                // Store positions for continuous collision.\n                body.m_sweep.c0.setVec2(body.m_sweep.c);\n                body.m_sweep.a0 = body.m_sweep.a;\n                if (body.isDynamic()) {\n                    // Integrate velocities.\n                    v.addMul(h * body.m_gravityScale, gravity);\n                    v.addMul(h * body.m_invMass, body.m_force);\n                    w += h * body.m_invI * body.m_torque;\n                    /**\n                     * <pre>\n                     * Apply damping.\n                     * ODE: dv/dt + c * v = 0\n                     * Solution: v(t) = v0 * exp(-c * t)\n                     * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n                     * v2 = exp(-c * dt) * v1\n                     * Pade approximation:\n                     * v2 = v1 * 1 / (1 + c * dt)\n                     * </pre>\n                     */\n                    v.mul(1.0 / (1.0 + h * body.m_linearDamping));\n                    w *= 1.0 / (1.0 + h * body.m_angularDamping);\n                }\n                body.c_position.c = c;\n                body.c_position.a = a;\n                body.c_velocity.v = v;\n                body.c_velocity.w = w;\n            }\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initConstraint(step);\n            }\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initVelocityConstraint(step);\n            }\n            if (step.warmStarting) {\n                // Warm start.\n                for (var i = 0; i < this.m_contacts.length; ++i) {\n                    var contact = this.m_contacts[i];\n                    contact.warmStartConstraint(step);\n                }\n            }\n            for (var i = 0; i < this.m_joints.length; ++i) {\n                var joint = this.m_joints[i];\n                joint.initVelocityConstraints(step);\n            }\n            // Solve velocity constraints\n            for (var i = 0; i < step.velocityIterations; ++i) {\n                for (var j = 0; j < this.m_joints.length; ++j) {\n                    var joint = this.m_joints[j];\n                    joint.solveVelocityConstraints(step);\n                }\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    contact.solveVelocityConstraint(step);\n                }\n            }\n            // Store impulses for warm starting\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.storeConstraintImpulses(step);\n            }\n            // Integrate positions\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.c_position.c);\n                var a = body.c_position.a;\n                var v = Vec2.clone(body.c_velocity.v);\n                var w = body.c_velocity.w;\n                // Check for large velocities\n                var translation = Vec2.mulNumVec2(h, v);\n                if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {\n                    var ratio = Settings.maxTranslation / translation.length();\n                    v.mul(ratio);\n                }\n                var rotation = h * w;\n                if (rotation * rotation > Settings.maxRotationSquared) {\n                    var ratio = Settings.maxRotation / math.abs(rotation);\n                    w *= ratio;\n                }\n                // Integrate\n                c.addMul(h, v);\n                a += h * w;\n                body.c_position.c.setVec2(c);\n                body.c_position.a = a;\n                body.c_velocity.v.setVec2(v);\n                body.c_velocity.w = w;\n            }\n            // Solve position constraints\n            var positionSolved = false;\n            for (var i = 0; i < step.positionIterations; ++i) {\n                var minSeparation = 0.0;\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    var separation = contact.solvePositionConstraint(step);\n                    minSeparation = math.min(minSeparation, separation);\n                }\n                // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n                // push the separation above -Settings.linearSlop.\n                var contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;\n                var jointsOkay = true;\n                for (var j = 0; j < this.m_joints.length; ++j) {\n                    var joint = this.m_joints[j];\n                    var jointOkay = joint.solvePositionConstraints(step);\n                    jointsOkay = jointsOkay && jointOkay;\n                }\n                if (contactsOkay && jointsOkay) {\n                    // Exit early if the position errors are small.\n                    positionSolved = true;\n                    break;\n                }\n            }\n            // Copy state buffers back to the bodies\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                body.m_sweep.c.setVec2(body.c_position.c);\n                body.m_sweep.a = body.c_position.a;\n                body.m_linearVelocity.setVec2(body.c_velocity.v);\n                body.m_angularVelocity = body.c_velocity.w;\n                body.synchronizeTransform();\n            }\n            this.postSolveIsland();\n            if (allowSleep) {\n                var minSleepTime = Infinity;\n                var linTolSqr = Settings.linearSleepToleranceSqr;\n                var angTolSqr = Settings.angularSleepToleranceSqr;\n                for (var i = 0; i < this.m_bodies.length; ++i) {\n                    var body = this.m_bodies[i];\n                    if (body.isStatic()) {\n                        continue;\n                    }\n                    if ((body.m_autoSleepFlag == false)\n                        || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)\n                        || (Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr)) {\n                        body.m_sleepTime = 0.0;\n                        minSleepTime = 0.0;\n                    }\n                    else {\n                        body.m_sleepTime += h;\n                        minSleepTime = math.min(minSleepTime, body.m_sleepTime);\n                    }\n                }\n                if (minSleepTime >= Settings.timeToSleep && positionSolved) {\n                    for (var i = 0; i < this.m_bodies.length; ++i) {\n                        var body = this.m_bodies[i];\n                        body.setAwake(false);\n                    }\n                }\n            }\n        };\n        /** @internal */\n        Solver.prototype.printBodies = function (tag) {\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var b = this.m_bodies[i];\n                common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);\n            }\n        };\n        /**\n         * Find TOI contacts and solve them.\n         */\n        Solver.prototype.solveWorldTOI = function (step) {\n            var world = this.m_world;\n            if (world.m_stepComplete) {\n                for (var b = world.m_bodyList; b; b = b.m_next) {\n                    b.m_islandFlag = false;\n                    b.m_sweep.alpha0 = 0.0;\n                }\n                for (var c = world.m_contactList; c; c = c.m_next) {\n                    // Invalidate TOI\n                    c.m_toiFlag = false;\n                    c.m_islandFlag = false;\n                    c.m_toiCount = 0;\n                    c.m_toi = 1.0;\n                }\n            }\n            // Find TOI events and solve them.\n            while (true) {\n                // Find the first TOI.\n                var minContact = null; // Contact\n                var minAlpha = 1.0;\n                for (var c = world.m_contactList; c; c = c.m_next) {\n                    // Is this contact disabled?\n                    if (c.isEnabled() == false) {\n                        continue;\n                    }\n                    // Prevent excessive sub-stepping.\n                    if (c.m_toiCount > Settings.maxSubSteps) {\n                        continue;\n                    }\n                    var alpha = 1.0;\n                    if (c.m_toiFlag) {\n                        // This contact has a valid cached TOI.\n                        alpha = c.m_toi;\n                    }\n                    else {\n                        var fA_1 = c.getFixtureA();\n                        var fB_1 = c.getFixtureB();\n                        // Is there a sensor?\n                        if (fA_1.isSensor() || fB_1.isSensor()) {\n                            continue;\n                        }\n                        var bA_1 = fA_1.getBody();\n                        var bB_1 = fB_1.getBody();\n                        var activeA = bA_1.isAwake() && !bA_1.isStatic();\n                        var activeB = bB_1.isAwake() && !bB_1.isStatic();\n                        // Is at least one body active (awake and dynamic or kinematic)?\n                        if (activeA == false && activeB == false) {\n                            continue;\n                        }\n                        var collideA = bA_1.isBullet() || !bA_1.isDynamic();\n                        var collideB = bB_1.isBullet() || !bB_1.isDynamic();\n                        // Are these two non-bullet dynamic bodies?\n                        if (collideA == false && collideB == false) {\n                            continue;\n                        }\n                        // Compute the TOI for this contact.\n                        // Put the sweeps onto the same time interval.\n                        var alpha0 = bA_1.m_sweep.alpha0;\n                        if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {\n                            alpha0 = bB_1.m_sweep.alpha0;\n                            bA_1.m_sweep.advance(alpha0);\n                        }\n                        else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {\n                            alpha0 = bA_1.m_sweep.alpha0;\n                            bB_1.m_sweep.advance(alpha0);\n                        }\n                        var indexA = c.getChildIndexA();\n                        var indexB = c.getChildIndexB();\n                        bA_1.m_sweep;\n                        bB_1.m_sweep;\n                        // Compute the time of impact in interval [0, minTOI]\n                        var input = new TOIInput(); // TODO: reuse\n                        input.proxyA.set(fA_1.getShape(), indexA);\n                        input.proxyB.set(fB_1.getShape(), indexB);\n                        input.sweepA.set(bA_1.m_sweep);\n                        input.sweepB.set(bB_1.m_sweep);\n                        input.tMax = 1.0;\n                        var output = new TOIOutput(); // TODO: reuse\n                        TimeOfImpact(output, input);\n                        // Beta is the fraction of the remaining portion of the [time?].\n                        var beta = output.t;\n                        if (output.state == TOIOutputState.e_touching) {\n                            alpha = math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n                        }\n                        else {\n                            alpha = 1.0;\n                        }\n                        c.m_toi = alpha;\n                        c.m_toiFlag = true;\n                    }\n                    if (alpha < minAlpha) {\n                        // This is the minimum TOI found so far.\n                        minContact = c;\n                        minAlpha = alpha;\n                    }\n                }\n                if (minContact == null || 1.0 - 10.0 * math.EPSILON < minAlpha) {\n                    // No more TOI events. Done!\n                    world.m_stepComplete = true;\n                    break;\n                }\n                // Advance the bodies to the TOI.\n                var fA = minContact.getFixtureA();\n                var fB = minContact.getFixtureB();\n                var bA = fA.getBody();\n                var bB = fB.getBody();\n                var backup1 = bA.m_sweep.clone();\n                var backup2 = bB.m_sweep.clone();\n                bA.advance(minAlpha);\n                bB.advance(minAlpha);\n                // The TOI contact likely has some new contact points.\n                minContact.update(world);\n                minContact.m_toiFlag = false;\n                ++minContact.m_toiCount;\n                // Is the contact solid?\n                if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n                    // Restore the sweeps.\n                    minContact.setEnabled(false);\n                    bA.m_sweep.set(backup1);\n                    bB.m_sweep.set(backup2);\n                    bA.synchronizeTransform();\n                    bB.synchronizeTransform();\n                    continue;\n                }\n                bA.setAwake(true);\n                bB.setAwake(true);\n                // Build the island\n                this.clear();\n                this.addBody(bA);\n                this.addBody(bB);\n                this.addContact(minContact);\n                bA.m_islandFlag = true;\n                bB.m_islandFlag = true;\n                minContact.m_islandFlag = true;\n                // Get contacts on bodyA and bodyB.\n                var bodies = [bA, bB];\n                for (var i = 0; i < bodies.length; ++i) {\n                    var body = bodies[i];\n                    if (body.isDynamic()) {\n                        for (var ce = body.m_contactList; ce; ce = ce.next) {\n                            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n                            // if (this.m_contactCount == this.m_contactCapacity) { break; }\n                            var contact = ce.contact;\n                            // Has this contact already been added to the island?\n                            if (contact.m_islandFlag) {\n                                continue;\n                            }\n                            // Only add if either is static, kinematic or bullet.\n                            var other = ce.other;\n                            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n                                continue;\n                            }\n                            // Skip sensors.\n                            var sensorA = contact.m_fixtureA.m_isSensor;\n                            var sensorB = contact.m_fixtureB.m_isSensor;\n                            if (sensorA || sensorB) {\n                                continue;\n                            }\n                            // Tentatively advance the body to the TOI.\n                            var backup = other.m_sweep.clone();\n                            if (other.m_islandFlag == false) {\n                                other.advance(minAlpha);\n                            }\n                            // Update the contact points\n                            contact.update(world);\n                            // Was the contact disabled by the user?\n                            // Are there contact points?\n                            if (contact.isEnabled() == false || contact.isTouching() == false) {\n                                other.m_sweep.set(backup);\n                                other.synchronizeTransform();\n                                continue;\n                            }\n                            // Add the contact to the island\n                            contact.m_islandFlag = true;\n                            this.addContact(contact);\n                            // Has the other body already been added to the island?\n                            if (other.m_islandFlag) {\n                                continue;\n                            }\n                            // Add the other body to the island.\n                            other.m_islandFlag = true;\n                            if (!other.isStatic()) {\n                                other.setAwake(true);\n                            }\n                            this.addBody(other);\n                        }\n                    }\n                }\n                s_subStep.reset((1.0 - minAlpha) * step.dt);\n                s_subStep.dtRatio = 1.0;\n                s_subStep.positionIterations = 20;\n                s_subStep.velocityIterations = step.velocityIterations;\n                s_subStep.warmStarting = false;\n                this.solveIslandTOI(s_subStep, bA, bB);\n                // Reset island flags and synchronize broad-phase proxies.\n                for (var i = 0; i < this.m_bodies.length; ++i) {\n                    var body = this.m_bodies[i];\n                    body.m_islandFlag = false;\n                    if (!body.isDynamic()) {\n                        continue;\n                    }\n                    body.synchronizeFixtures();\n                    // Invalidate all contact TOIs on this displaced body.\n                    for (var ce = body.m_contactList; ce; ce = ce.next) {\n                        ce.contact.m_toiFlag = false;\n                        ce.contact.m_islandFlag = false;\n                    }\n                }\n                // Commit fixture proxy movements to the broad-phase so that new contacts\n                // are created.\n                // Also, some contacts can be destroyed.\n                world.findNewContacts();\n                if (world.m_subStepping) {\n                    world.m_stepComplete = false;\n                    break;\n                }\n            }\n            var b, c; \n        };\n        Solver.prototype.solveIslandTOI = function (subStep, toiA, toiB) {\n            this.m_world;\n            // Initialize the body state.\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                body.c_position.c.setVec2(body.m_sweep.c);\n                body.c_position.a = body.m_sweep.a;\n                body.c_velocity.v.setVec2(body.m_linearVelocity);\n                body.c_velocity.w = body.m_angularVelocity;\n            }\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initConstraint(subStep);\n            }\n            // Solve position constraints.\n            for (var i = 0; i < subStep.positionIterations; ++i) {\n                var minSeparation = 0.0;\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n                    minSeparation = math.min(minSeparation, separation);\n                }\n                // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n                // push the separation above -Settings.linearSlop.\n                var contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n                if (contactsOkay) {\n                    break;\n                }\n            }\n            var i, c; \n            // Leap of faith to new safe state.\n            toiA.m_sweep.c0.setVec2(toiA.c_position.c);\n            toiA.m_sweep.a0 = toiA.c_position.a;\n            toiB.m_sweep.c0.setVec2(toiB.c_position.c);\n            toiB.m_sweep.a0 = toiB.c_position.a;\n            // No warm starting is needed for TOI events because warm\n            // starting impulses were applied in the discrete solver.\n            for (var i = 0; i < this.m_contacts.length; ++i) {\n                var contact = this.m_contacts[i];\n                contact.initVelocityConstraint(subStep);\n            }\n            // Solve velocity constraints.\n            for (var i = 0; i < subStep.velocityIterations; ++i) {\n                for (var j = 0; j < this.m_contacts.length; ++j) {\n                    var contact = this.m_contacts[j];\n                    contact.solveVelocityConstraint(subStep);\n                }\n            }\n            // Don't store the TOI contact forces for warm starting\n            // because they can be quite large.\n            var h = subStep.dt;\n            // Integrate positions\n            for (var i = 0; i < this.m_bodies.length; ++i) {\n                var body = this.m_bodies[i];\n                var c = Vec2.clone(body.c_position.c);\n                var a = body.c_position.a;\n                var v = Vec2.clone(body.c_velocity.v);\n                var w = body.c_velocity.w;\n                // Check for large velocities\n                var translation = Vec2.mulNumVec2(h, v);\n                if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {\n                    var ratio = Settings.maxTranslation / translation.length();\n                    v.mul(ratio);\n                }\n                var rotation = h * w;\n                if (rotation * rotation > Settings.maxRotationSquared) {\n                    var ratio = Settings.maxRotation / math.abs(rotation);\n                    w *= ratio;\n                }\n                // Integrate\n                c.addMul(h, v);\n                a += h * w;\n                body.c_position.c = c;\n                body.c_position.a = a;\n                body.c_velocity.v = v;\n                body.c_velocity.w = w;\n                // Sync bodies\n                body.m_sweep.c = c;\n                body.m_sweep.a = a;\n                body.m_linearVelocity = v;\n                body.m_angularVelocity = w;\n                body.synchronizeTransform();\n            }\n            this.postSolveIsland();\n        };\n        /** @internal */\n        Solver.prototype.postSolveIsland = function () {\n            for (var c = 0; c < this.m_contacts.length; ++c) {\n                var contact = this.m_contacts[c];\n                this.m_world.postSolve(contact, contact.m_impulse);\n            }\n        };\n        return Solver;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var WorldDefDefault = {\n        gravity: Vec2.zero(),\n        allowSleep: true,\n        warmStarting: true,\n        continuousPhysics: true,\n        subStepping: false,\n        blockSolve: true,\n        velocityIterations: 8,\n        positionIterations: 3\n    };\n    var World = /** @class */ (function () {\n        /**\n         * @param def World definition or gravity vector.\n         */\n        function World(def) {\n            var _this = this;\n            /** @internal */\n            this.s_step = new TimeStep(); // reuse\n            /**\n             * @internal\n             * Callback for broad-phase.\n             */\n            this.createContact = function (proxyA, proxyB) {\n                var fixtureA = proxyA.fixture;\n                var fixtureB = proxyB.fixture;\n                var indexA = proxyA.childIndex;\n                var indexB = proxyB.childIndex;\n                var bodyA = fixtureA.getBody();\n                var bodyB = fixtureB.getBody();\n                // Are the fixtures on the same body?\n                if (bodyA == bodyB) {\n                    return;\n                }\n                // TODO_ERIN use a hash table to remove a potential bottleneck when both\n                // bodies have a lot of contacts.\n                // Does a contact already exist?\n                var edge = bodyB.getContactList(); // ContactEdge\n                while (edge) {\n                    if (edge.other == bodyA) {\n                        var fA = edge.contact.getFixtureA();\n                        var fB = edge.contact.getFixtureB();\n                        var iA = edge.contact.getChildIndexA();\n                        var iB = edge.contact.getChildIndexB();\n                        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n                            // A contact already exists.\n                            return;\n                        }\n                        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n                            // A contact already exists.\n                            return;\n                        }\n                    }\n                    edge = edge.next;\n                }\n                if (bodyB.shouldCollide(bodyA) == false) {\n                    return;\n                }\n                if (fixtureB.shouldCollide(fixtureA) == false) {\n                    return;\n                }\n                // Call the factory.\n                var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n                if (contact == null) {\n                    return;\n                }\n                // Insert into the world.\n                contact.m_prev = null;\n                if (_this.m_contactList != null) {\n                    contact.m_next = _this.m_contactList;\n                    _this.m_contactList.m_prev = contact;\n                }\n                _this.m_contactList = contact;\n                ++_this.m_contactCount;\n            };\n            if (!(this instanceof World)) {\n                return new World(def);\n            }\n            if (def && Vec2.isValid(def)) {\n                def = { gravity: def };\n            }\n            def = options(def, WorldDefDefault);\n            this.m_solver = new Solver(this);\n            this.m_broadPhase = new BroadPhase();\n            this.m_contactList = null;\n            this.m_contactCount = 0;\n            this.m_bodyList = null;\n            this.m_bodyCount = 0;\n            this.m_jointList = null;\n            this.m_jointCount = 0;\n            this.m_stepComplete = true;\n            this.m_allowSleep = def.allowSleep;\n            this.m_gravity = Vec2.clone(def.gravity);\n            this.m_clearForces = true;\n            this.m_newFixture = false;\n            this.m_locked = false;\n            // These are for debugging the solver.\n            this.m_warmStarting = def.warmStarting;\n            this.m_continuousPhysics = def.continuousPhysics;\n            this.m_subStepping = def.subStepping;\n            this.m_blockSolve = def.blockSolve;\n            this.m_velocityIterations = def.velocityIterations;\n            this.m_positionIterations = def.positionIterations;\n            this.m_t = 0;\n        }\n        /** @internal */\n        World.prototype._serialize = function () {\n            var bodies = [];\n            var joints = [];\n            for (var b = this.getBodyList(); b; b = b.getNext()) {\n                bodies.push(b);\n            }\n            for (var j = this.getJointList(); j; j = j.getNext()) {\n                // @ts-ignore\n                if (typeof j._serialize === 'function') {\n                    joints.push(j);\n                }\n            }\n            return {\n                gravity: this.m_gravity,\n                bodies: bodies,\n                joints: joints,\n            };\n        };\n        /** @internal */\n        World._deserialize = function (data, context, restore) {\n            if (!data) {\n                return new World();\n            }\n            var world = new World(data.gravity);\n            if (data.bodies) {\n                for (var i = data.bodies.length - 1; i >= 0; i -= 1) {\n                    world._addBody(restore(Body, data.bodies[i], world));\n                }\n            }\n            if (data.joints) {\n                for (var i = data.joints.length - 1; i >= 0; i--) {\n                    world.createJoint(restore(Joint, data.joints[i], world));\n                }\n            }\n            return world;\n        };\n        /**\n         * Get the world body list. With the returned body, use Body.getNext to get the\n         * next body in the world list. A null body indicates the end of the list.\n         *\n         * @return the head of the world body list.\n         */\n        World.prototype.getBodyList = function () {\n            return this.m_bodyList;\n        };\n        /**\n         * Get the world joint list. With the returned joint, use Joint.getNext to get\n         * the next joint in the world list. A null joint indicates the end of the list.\n         *\n         * @return the head of the world joint list.\n         */\n        World.prototype.getJointList = function () {\n            return this.m_jointList;\n        };\n        /**\n         * Get the world contact list. With the returned contact, use Contact.getNext to\n         * get the next contact in the world list. A null contact indicates the end of\n         * the list.\n         *\n         * Warning: contacts are created and destroyed in the middle of a time step.\n         * Use ContactListener to avoid missing contacts.\n         *\n         * @return the head of the world contact list.\n         */\n        World.prototype.getContactList = function () {\n            return this.m_contactList;\n        };\n        World.prototype.getBodyCount = function () {\n            return this.m_bodyCount;\n        };\n        World.prototype.getJointCount = function () {\n            return this.m_jointCount;\n        };\n        /**\n         * Get the number of contacts (each may have 0 or more contact points).\n         */\n        World.prototype.getContactCount = function () {\n            return this.m_contactCount;\n        };\n        /**\n         * Change the global gravity vector.\n         */\n        World.prototype.setGravity = function (gravity) {\n            this.m_gravity = gravity;\n        };\n        /**\n         * Get the global gravity vector.\n         */\n        World.prototype.getGravity = function () {\n            return this.m_gravity;\n        };\n        /**\n         * Is the world locked (in the middle of a time step).\n         */\n        World.prototype.isLocked = function () {\n            return this.m_locked;\n        };\n        /**\n         * Enable/disable sleep.\n         */\n        World.prototype.setAllowSleeping = function (flag) {\n            if (flag == this.m_allowSleep) {\n                return;\n            }\n            this.m_allowSleep = flag;\n            if (this.m_allowSleep == false) {\n                for (var b = this.m_bodyList; b; b = b.m_next) {\n                    b.setAwake(true);\n                }\n            }\n        };\n        World.prototype.getAllowSleeping = function () {\n            return this.m_allowSleep;\n        };\n        /**\n         * Enable/disable warm starting. For testing.\n         */\n        World.prototype.setWarmStarting = function (flag) {\n            this.m_warmStarting = flag;\n        };\n        World.prototype.getWarmStarting = function () {\n            return this.m_warmStarting;\n        };\n        /**\n         * Enable/disable continuous physics. For testing.\n         */\n        World.prototype.setContinuousPhysics = function (flag) {\n            this.m_continuousPhysics = flag;\n        };\n        World.prototype.getContinuousPhysics = function () {\n            return this.m_continuousPhysics;\n        };\n        /**\n         * Enable/disable single stepped continuous physics. For testing.\n         */\n        World.prototype.setSubStepping = function (flag) {\n            this.m_subStepping = flag;\n        };\n        World.prototype.getSubStepping = function () {\n            return this.m_subStepping;\n        };\n        /**\n         * Set flag to control automatic clearing of forces after each time step.\n         */\n        World.prototype.setAutoClearForces = function (flag) {\n            this.m_clearForces = flag;\n        };\n        /**\n         * Get the flag that controls automatic clearing of forces after each time step.\n         */\n        World.prototype.getAutoClearForces = function () {\n            return this.m_clearForces;\n        };\n        /**\n         * Manually clear the force buffer on all bodies. By default, forces are cleared\n         * automatically after each call to step. The default behavior is modified by\n         * calling setAutoClearForces. The purpose of this function is to support\n         * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n         * under a variable frame-rate. When you perform sub-stepping you will disable\n         * auto clearing of forces and instead call clearForces after all sub-steps are\n         * complete in one pass of your game loop.\n         *\n         * See {@link World.setAutoClearForces}\n         */\n        World.prototype.clearForces = function () {\n            for (var body = this.m_bodyList; body; body = body.getNext()) {\n                body.m_force.setZero();\n                body.m_torque = 0.0;\n            }\n        };\n        /**\n         * Query the world for all fixtures that potentially overlap the provided AABB.\n         *\n         * @param aabb The query box.\n         * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n         */\n        World.prototype.queryAABB = function (aabb, callback) {\n            var broadPhase = this.m_broadPhase;\n            this.m_broadPhase.query(aabb, function (proxyId) {\n                var proxy = broadPhase.getUserData(proxyId);\n                return callback(proxy.fixture);\n            });\n        };\n        /**\n         * Ray-cast the world for all fixtures in the path of the ray. Your callback\n         * controls whether you get the closest point, any point, or n-points. The\n         * ray-cast ignores shapes that contain the starting point.\n         *\n         * @param point1 The ray starting point\n         * @param point2 The ray ending point\n         * @param callback A user implemented callback function.\n         */\n        World.prototype.rayCast = function (point1, point2, callback) {\n            var broadPhase = this.m_broadPhase;\n            this.m_broadPhase.rayCast({\n                maxFraction: 1.0,\n                p1: point1,\n                p2: point2\n            }, function (input, proxyId) {\n                var proxy = broadPhase.getUserData(proxyId);\n                var fixture = proxy.fixture;\n                var index = proxy.childIndex;\n                // @ts-ignore\n                var output = {}; // TODO GC\n                var hit = fixture.rayCast(output, input, index);\n                if (hit) {\n                    var fraction = output.fraction;\n                    var point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));\n                    return callback(fixture, point, output.normal, fraction);\n                }\n                return input.maxFraction;\n            });\n        };\n        /**\n         * Get the number of broad-phase proxies.\n         */\n        World.prototype.getProxyCount = function () {\n            return this.m_broadPhase.getProxyCount();\n        };\n        /**\n         * Get the height of broad-phase dynamic tree.\n         */\n        World.prototype.getTreeHeight = function () {\n            return this.m_broadPhase.getTreeHeight();\n        };\n        /**\n         * Get the balance of broad-phase dynamic tree.\n         */\n        World.prototype.getTreeBalance = function () {\n            return this.m_broadPhase.getTreeBalance();\n        };\n        /**\n         * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n         * The minimum is 1.\n         */\n        World.prototype.getTreeQuality = function () {\n            return this.m_broadPhase.getTreeQuality();\n        };\n        /**\n         * Shift the world origin. Useful for large worlds. The body shift formula is:\n         * position -= newOrigin\n         *\n         * @param newOrigin The new origin with respect to the old origin\n         */\n        World.prototype.shiftOrigin = function (newOrigin) {\n            if (this.m_locked) {\n                return;\n            }\n            for (var b = this.m_bodyList; b; b = b.m_next) {\n                b.m_xf.p.sub(newOrigin);\n                b.m_sweep.c0.sub(newOrigin);\n                b.m_sweep.c.sub(newOrigin);\n            }\n            for (var j = this.m_jointList; j; j = j.m_next) {\n                j.shiftOrigin(newOrigin);\n            }\n            this.m_broadPhase.shiftOrigin(newOrigin);\n        };\n        /**\n         * @internal Used for deserialize.\n         */\n        World.prototype._addBody = function (body) {\n            if (this.isLocked()) {\n                return;\n            }\n            // Add to world doubly linked list.\n            body.m_prev = null;\n            body.m_next = this.m_bodyList;\n            if (this.m_bodyList) {\n                this.m_bodyList.m_prev = body;\n            }\n            this.m_bodyList = body;\n            ++this.m_bodyCount;\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createBody = function (arg1, arg2) {\n            if (this.isLocked()) {\n                return null;\n            }\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) {\n                def = { position: arg1, angle: arg2 };\n            }\n            else if (typeof arg1 === 'object') {\n                def = arg1;\n            }\n            var body = new Body(this, def);\n            this._addBody(body);\n            return body;\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createDynamicBody = function (arg1, arg2) {\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) {\n                def = { position: arg1, angle: arg2 };\n            }\n            else if (typeof arg1 === 'object') {\n                def = arg1;\n            }\n            def.type = 'dynamic';\n            return this.createBody(def);\n        };\n        // tslint:disable-next-line:typedef\n        World.prototype.createKinematicBody = function (arg1, arg2) {\n            var def = {};\n            if (!arg1) ;\n            else if (Vec2.isValid(arg1)) {\n                def = { position: arg1, angle: arg2 };\n            }\n            else if (typeof arg1 === 'object') {\n                def = arg1;\n            }\n            def.type = 'kinematic';\n            return this.createBody(def);\n        };\n        /**\n         * Destroy a rigid body given a definition. No reference to the definition is\n         * retained.\n         *\n         * Warning: This automatically deletes all associated shapes and joints.\n         *\n         * Warning: This function is locked during callbacks.\n         */\n        World.prototype.destroyBody = function (b) {\n            if (this.isLocked()) {\n                return;\n            }\n            if (b.m_destroyed) {\n                return false;\n            }\n            // Delete the attached joints.\n            var je = b.m_jointList;\n            while (je) {\n                var je0 = je;\n                je = je.next;\n                this.publish('remove-joint', je0.joint);\n                this.destroyJoint(je0.joint);\n                b.m_jointList = je;\n            }\n            b.m_jointList = null;\n            // Delete the attached contacts.\n            var ce = b.m_contactList;\n            while (ce) {\n                var ce0 = ce;\n                ce = ce.next;\n                this.destroyContact(ce0.contact);\n                b.m_contactList = ce;\n            }\n            b.m_contactList = null;\n            // Delete the attached fixtures. This destroys broad-phase proxies.\n            var f = b.m_fixtureList;\n            while (f) {\n                var f0 = f;\n                f = f.m_next;\n                this.publish('remove-fixture', f0);\n                f0.destroyProxies(this.m_broadPhase);\n                b.m_fixtureList = f;\n            }\n            b.m_fixtureList = null;\n            // Remove world body list.\n            if (b.m_prev) {\n                b.m_prev.m_next = b.m_next;\n            }\n            if (b.m_next) {\n                b.m_next.m_prev = b.m_prev;\n            }\n            if (b == this.m_bodyList) {\n                this.m_bodyList = b.m_next;\n            }\n            b.m_destroyed = true;\n            --this.m_bodyCount;\n            this.publish('remove-body', b);\n            return true;\n        };\n        /**\n         * Create a joint to constrain bodies together. No reference to the definition\n         * is retained. This may cause the connected bodies to cease colliding.\n         *\n         * Warning: This function is locked during callbacks.\n         */\n        World.prototype.createJoint = function (joint) {\n            if (this.isLocked()) {\n                return null;\n            }\n            // Connect to the world list.\n            joint.m_prev = null;\n            joint.m_next = this.m_jointList;\n            if (this.m_jointList) {\n                this.m_jointList.m_prev = joint;\n            }\n            this.m_jointList = joint;\n            ++this.m_jointCount;\n            // Connect to the bodies' doubly linked lists.\n            joint.m_edgeA.joint = joint;\n            joint.m_edgeA.other = joint.m_bodyB;\n            joint.m_edgeA.prev = null;\n            joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n            if (joint.m_bodyA.m_jointList)\n                joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n            joint.m_bodyA.m_jointList = joint.m_edgeA;\n            joint.m_edgeB.joint = joint;\n            joint.m_edgeB.other = joint.m_bodyA;\n            joint.m_edgeB.prev = null;\n            joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n            if (joint.m_bodyB.m_jointList)\n                joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n            joint.m_bodyB.m_jointList = joint.m_edgeB;\n            // If the joint prevents collisions, then flag any contacts for filtering.\n            if (joint.m_collideConnected == false) {\n                for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n                    if (edge.other == joint.m_bodyA) {\n                        // Flag the contact for filtering at the next time step (where either\n                        // body is awake).\n                        edge.contact.flagForFiltering();\n                    }\n                }\n            }\n            // Note: creating a joint doesn't wake the bodies.\n            return joint;\n        };\n        /**\n         * Destroy a joint. This may cause the connected bodies to begin colliding.\n         * Warning: This function is locked during callbacks.\n         */\n        World.prototype.destroyJoint = function (joint) {\n            if (this.isLocked()) {\n                return;\n            }\n            // Remove from the doubly linked list.\n            if (joint.m_prev) {\n                joint.m_prev.m_next = joint.m_next;\n            }\n            if (joint.m_next) {\n                joint.m_next.m_prev = joint.m_prev;\n            }\n            if (joint == this.m_jointList) {\n                this.m_jointList = joint.m_next;\n            }\n            // Disconnect from bodies.\n            var bodyA = joint.m_bodyA;\n            var bodyB = joint.m_bodyB;\n            // Wake up connected bodies.\n            bodyA.setAwake(true);\n            bodyB.setAwake(true);\n            // Remove from body 1.\n            if (joint.m_edgeA.prev) {\n                joint.m_edgeA.prev.next = joint.m_edgeA.next;\n            }\n            if (joint.m_edgeA.next) {\n                joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n            }\n            if (joint.m_edgeA == bodyA.m_jointList) {\n                bodyA.m_jointList = joint.m_edgeA.next;\n            }\n            joint.m_edgeA.prev = null;\n            joint.m_edgeA.next = null;\n            // Remove from body 2\n            if (joint.m_edgeB.prev) {\n                joint.m_edgeB.prev.next = joint.m_edgeB.next;\n            }\n            if (joint.m_edgeB.next) {\n                joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n            }\n            if (joint.m_edgeB == bodyB.m_jointList) {\n                bodyB.m_jointList = joint.m_edgeB.next;\n            }\n            joint.m_edgeB.prev = null;\n            joint.m_edgeB.next = null;\n            --this.m_jointCount;\n            // If the joint prevents collisions, then flag any contacts for filtering.\n            if (joint.m_collideConnected == false) {\n                var edge = bodyB.getContactList();\n                while (edge) {\n                    if (edge.other == bodyA) {\n                        // Flag the contact for filtering at the next time step (where either\n                        // body is awake).\n                        edge.contact.flagForFiltering();\n                    }\n                    edge = edge.next;\n                }\n            }\n            this.publish('remove-joint', joint);\n        };\n        /**\n         * Take a time step. This performs collision detection, integration, and\n         * constraint solution.\n         *\n         * Broad-phase, narrow-phase, solve and solve time of impacts.\n         *\n         * @param timeStep Time step, this should not vary.\n         */\n        World.prototype.step = function (timeStep, velocityIterations, positionIterations) {\n            this.publish('pre-step', timeStep);\n            if ((velocityIterations | 0) !== velocityIterations) {\n                // TODO: remove this in future\n                velocityIterations = 0;\n            }\n            velocityIterations = velocityIterations || this.m_velocityIterations;\n            positionIterations = positionIterations || this.m_positionIterations;\n            // If new fixtures were added, we need to find the new contacts.\n            if (this.m_newFixture) {\n                this.findNewContacts();\n                this.m_newFixture = false;\n            }\n            this.m_locked = true;\n            this.s_step.reset(timeStep);\n            this.s_step.velocityIterations = velocityIterations;\n            this.s_step.positionIterations = positionIterations;\n            this.s_step.warmStarting = this.m_warmStarting;\n            this.s_step.blockSolve = this.m_blockSolve;\n            // Update contacts. This is where some contacts are destroyed.\n            this.updateContacts();\n            // Integrate velocities, solve velocity constraints, and integrate positions.\n            if (this.m_stepComplete && timeStep > 0.0) {\n                this.m_solver.solveWorld(this.s_step);\n                // Synchronize fixtures, check for out of range bodies.\n                for (var b = this.m_bodyList; b; b = b.getNext()) {\n                    // If a body was not in an island then it did not move.\n                    if (b.m_islandFlag == false) {\n                        continue;\n                    }\n                    if (b.isStatic()) {\n                        continue;\n                    }\n                    // Update fixtures (for broad-phase).\n                    b.synchronizeFixtures();\n                }\n                // Look for new contacts.\n                this.findNewContacts();\n            }\n            // Handle TOI events.\n            if (this.m_continuousPhysics && timeStep > 0.0) {\n                this.m_solver.solveWorldTOI(this.s_step);\n            }\n            if (this.m_clearForces) {\n                this.clearForces();\n            }\n            this.m_locked = false;\n            this.publish('post-step', timeStep);\n        };\n        /**\n         * @internal\n         * Call this method to find new contacts.\n         */\n        World.prototype.findNewContacts = function () {\n            this.m_broadPhase.updatePairs(this.createContact);\n        };\n        /**\n         * @internal\n         * Removes old non-overlapping contacts, applies filters and updates contacts.\n         */\n        World.prototype.updateContacts = function () {\n            // Update awake contacts.\n            var c;\n            var next_c = this.m_contactList;\n            while (c = next_c) {\n                next_c = c.getNext();\n                var fixtureA = c.getFixtureA();\n                var fixtureB = c.getFixtureB();\n                var indexA = c.getChildIndexA();\n                var indexB = c.getChildIndexB();\n                var bodyA = fixtureA.getBody();\n                var bodyB = fixtureB.getBody();\n                // Is this contact flagged for filtering?\n                if (c.m_filterFlag) {\n                    if (bodyB.shouldCollide(bodyA) == false) {\n                        this.destroyContact(c);\n                        continue;\n                    }\n                    if (fixtureB.shouldCollide(fixtureA) == false) {\n                        this.destroyContact(c);\n                        continue;\n                    }\n                    // Clear the filtering flag.\n                    c.m_filterFlag = false;\n                }\n                var activeA = bodyA.isAwake() && !bodyA.isStatic();\n                var activeB = bodyB.isAwake() && !bodyB.isStatic();\n                // At least one body must be awake and it must be dynamic or kinematic.\n                if (activeA == false && activeB == false) {\n                    continue;\n                }\n                var proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n                var proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n                var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n                // Here we destroy contacts that cease to overlap in the broad-phase.\n                if (overlap == false) {\n                    this.destroyContact(c);\n                    continue;\n                }\n                // The contact persists.\n                c.update(this);\n            }\n        };\n        /**\n         * @internal\n         */\n        World.prototype.destroyContact = function (contact) {\n            Contact.destroy(contact, this);\n            // Remove from the world.\n            if (contact.m_prev) {\n                contact.m_prev.m_next = contact.m_next;\n            }\n            if (contact.m_next) {\n                contact.m_next.m_prev = contact.m_prev;\n            }\n            if (contact == this.m_contactList) {\n                this.m_contactList = contact.m_next;\n            }\n            --this.m_contactCount;\n        };\n        /**\n         * Register an event listener.\n         */\n        // tslint:disable-next-line:typedef\n        World.prototype.on = function (name, listener) {\n            if (typeof name !== 'string' || typeof listener !== 'function') {\n                return this;\n            }\n            if (!this._listeners) {\n                this._listeners = {};\n            }\n            if (!this._listeners[name]) {\n                this._listeners[name] = [];\n            }\n            this._listeners[name].push(listener);\n            return this;\n        };\n        /**\n         * Remove an event listener.\n         */\n        // tslint:disable-next-line:typedef\n        World.prototype.off = function (name, listener) {\n            if (typeof name !== 'string' || typeof listener !== 'function') {\n                return this;\n            }\n            var listeners = this._listeners && this._listeners[name];\n            if (!listeners || !listeners.length) {\n                return this;\n            }\n            var index = listeners.indexOf(listener);\n            if (index >= 0) {\n                listeners.splice(index, 1);\n            }\n            return this;\n        };\n        World.prototype.publish = function (name, arg1, arg2, arg3) {\n            var listeners = this._listeners && this._listeners[name];\n            if (!listeners || !listeners.length) {\n                return 0;\n            }\n            for (var l = 0; l < listeners.length; l++) {\n                listeners[l].call(this, arg1, arg2, arg3);\n            }\n            return listeners.length;\n        };\n        /**\n         * @internal\n         */\n        World.prototype.beginContact = function (contact) {\n            this.publish('begin-contact', contact);\n        };\n        /**\n         * @internal\n         */\n        World.prototype.endContact = function (contact) {\n            this.publish('end-contact', contact);\n        };\n        /**\n         * @internal\n         */\n        World.prototype.preSolve = function (contact, oldManifold) {\n            this.publish('pre-solve', contact, oldManifold);\n        };\n        /**\n         * @internal\n         */\n        World.prototype.postSolve = function (contact, impulse) {\n            this.publish('post-solve', contact, impulse);\n        };\n        return World;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var Vec3 = /** @class */ (function () {\n        // tslint:disable-next-line:typedef\n        function Vec3(x, y, z) {\n            if (!(this instanceof Vec3)) {\n                return new Vec3(x, y, z);\n            }\n            if (typeof x === 'undefined') {\n                this.x = 0;\n                this.y = 0;\n                this.z = 0;\n            }\n            else if (typeof x === 'object') {\n                this.x = x.x;\n                this.y = x.y;\n                this.z = x.z;\n            }\n            else {\n                this.x = x;\n                this.y = y;\n                this.z = z;\n            }\n        }\n        /** @internal */\n        Vec3.prototype._serialize = function () {\n            return {\n                x: this.x,\n                y: this.y,\n                z: this.z\n            };\n        };\n        /** @internal */\n        Vec3._deserialize = function (data) {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = data.x;\n            obj.y = data.y;\n            obj.z = data.z;\n            return obj;\n        };\n        /** @internal */\n        Vec3.neo = function (x, y, z) {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = x;\n            obj.y = y;\n            obj.z = z;\n            return obj;\n        };\n        Vec3.zero = function () {\n            var obj = Object.create(Vec3.prototype);\n            obj.x = 0;\n            obj.y = 0;\n            obj.z = 0;\n            return obj;\n        };\n        Vec3.clone = function (v) {\n            return Vec3.neo(v.x, v.y, v.z);\n        };\n        /** @internal */\n        Vec3.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        /**\n         * Does this vector contain finite coordinates?\n         */\n        Vec3.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return math.isFinite(obj.x) && math.isFinite(obj.y) && math.isFinite(obj.z);\n        };\n        Vec3.assert = function (o) {\n            return;\n        };\n        Vec3.prototype.setZero = function () {\n            this.x = 0.0;\n            this.y = 0.0;\n            this.z = 0.0;\n            return this;\n        };\n        Vec3.prototype.set = function (x, y, z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            return this;\n        };\n        Vec3.prototype.add = function (w) {\n            this.x += w.x;\n            this.y += w.y;\n            this.z += w.z;\n            return this;\n        };\n        Vec3.prototype.sub = function (w) {\n            this.x -= w.x;\n            this.y -= w.y;\n            this.z -= w.z;\n            return this;\n        };\n        Vec3.prototype.mul = function (m) {\n            this.x *= m;\n            this.y *= m;\n            this.z *= m;\n            return this;\n        };\n        Vec3.areEqual = function (v, w) {\n            return v === w ||\n                typeof v === 'object' && v !== null &&\n                    typeof w === 'object' && w !== null &&\n                    v.x === w.x && v.y === w.y && v.z === w.z;\n        };\n        /**\n         * Perform the dot product on two vectors.\n         */\n        Vec3.dot = function (v, w) {\n            return v.x * w.x + v.y * w.y + v.z * w.z;\n        };\n        /**\n         * Perform the cross product on two vectors. In 2D this produces a scalar.\n         */\n        Vec3.cross = function (v, w) {\n            return new Vec3(v.y * w.z - v.z * w.y, v.z * w.x - v.x * w.z, v.x * w.y - v.y * w.x);\n        };\n        Vec3.add = function (v, w) {\n            return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n        };\n        Vec3.sub = function (v, w) {\n            return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n        };\n        Vec3.mul = function (v, m) {\n            return new Vec3(m * v.x, m * v.y, m * v.z);\n        };\n        Vec3.prototype.neg = function () {\n            this.x = -this.x;\n            this.y = -this.y;\n            this.z = -this.z;\n            return this;\n        };\n        Vec3.neg = function (v) {\n            return new Vec3(-v.x, -v.y, -v.z);\n        };\n        return Vec3;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A line segment (edge) shape. These can be connected in chains or loops to\n     * other edge shapes. The connectivity information is used to ensure correct\n     * contact normals.\n     */\n    var EdgeShape = /** @class */ (function (_super) {\n        __extends(EdgeShape, _super);\n        function EdgeShape(v1, v2) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof EdgeShape)) {\n                return new EdgeShape(v1, v2);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = EdgeShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n            _this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n            _this.m_vertex0 = Vec2.zero();\n            _this.m_vertex3 = Vec2.zero();\n            _this.m_hasVertex0 = false;\n            _this.m_hasVertex3 = false;\n            return _this;\n        }\n        /** @internal */\n        EdgeShape.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                vertex1: this.m_vertex1,\n                vertex2: this.m_vertex2,\n                vertex0: this.m_vertex0,\n                vertex3: this.m_vertex3,\n                hasVertex0: this.m_hasVertex0,\n                hasVertex3: this.m_hasVertex3,\n            };\n        };\n        /** @internal */\n        EdgeShape._deserialize = function (data) {\n            var shape = new EdgeShape(data.vertex1, data.vertex2);\n            if (shape.m_hasVertex0) {\n                shape.setPrevVertex(data.vertex0);\n            }\n            if (shape.m_hasVertex3) {\n                shape.setNextVertex(data.vertex3);\n            }\n            return shape;\n        };\n        /** @internal @deprecated */\n        EdgeShape.prototype.setNext = function (v) {\n            return this.setNextVertex(v);\n        };\n        /**\n         * Optional next vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.setNextVertex = function (v) {\n            if (v) {\n                this.m_vertex3.setVec2(v);\n                this.m_hasVertex3 = true;\n            }\n            else {\n                this.m_vertex3.setZero();\n                this.m_hasVertex3 = false;\n            }\n            return this;\n        };\n        /**\n         * Optional next vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.getNextVertex = function () {\n            return this.m_vertex3;\n        };\n        /** @internal @deprecated */\n        EdgeShape.prototype.setPrev = function (v) {\n            return this.setPrevVertex(v);\n        };\n        /**\n         * Optional prev vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.setPrevVertex = function (v) {\n            if (v) {\n                this.m_vertex0.setVec2(v);\n                this.m_hasVertex0 = true;\n            }\n            else {\n                this.m_vertex0.setZero();\n                this.m_hasVertex0 = false;\n            }\n            return this;\n        };\n        /**\n         * Optional prev vertex, used for smooth collision.\n         */\n        EdgeShape.prototype.getPrevVertex = function () {\n            return this.m_vertex0;\n        };\n        /**\n         * Set this as an isolated edge.\n         */\n        EdgeShape.prototype._set = function (v1, v2) {\n            this.m_vertex1.setVec2(v1);\n            this.m_vertex2.setVec2(v2);\n            this.m_hasVertex0 = false;\n            this.m_hasVertex3 = false;\n            return this;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        EdgeShape.prototype._clone = function () {\n            var clone = new EdgeShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_vertex1.setVec2(this.m_vertex1);\n            clone.m_vertex2.setVec2(this.m_vertex2);\n            clone.m_vertex0.setVec2(this.m_vertex0);\n            clone.m_vertex3.setVec2(this.m_vertex3);\n            clone.m_hasVertex0 = this.m_hasVertex0;\n            clone.m_hasVertex3 = this.m_hasVertex3;\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        EdgeShape.prototype.getChildCount = function () {\n            return 1;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        EdgeShape.prototype.testPoint = function (xf, p) {\n            return false;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        EdgeShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            // p = p1 + t * d\n            // v = v1 + s * e\n            // p1 + t * d = v1 + s * e\n            // s * e - t * d = p1 - v1\n            // NOT_USED(childIndex);\n            // Put the ray into the edge's frame of reference.\n            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n            var d = Vec2.sub(p2, p1);\n            var v1 = this.m_vertex1;\n            var v2 = this.m_vertex2;\n            var e = Vec2.sub(v2, v1);\n            var normal = Vec2.neo(e.y, -e.x);\n            normal.normalize();\n            // q = p1 + t * d\n            // dot(normal, q - v1) = 0\n            // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n            var numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n            var denominator = Vec2.dot(normal, d);\n            if (denominator == 0.0) {\n                return false;\n            }\n            var t = numerator / denominator;\n            if (t < 0.0 || input.maxFraction < t) {\n                return false;\n            }\n            var q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n            // q = v1 + s * r\n            // s = dot(q - v1, r) / dot(r, r)\n            var r = Vec2.sub(v2, v1);\n            var rr = Vec2.dot(r, r);\n            if (rr == 0.0) {\n                return false;\n            }\n            var s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n            if (s < 0.0 || 1.0 < s) {\n                return false;\n            }\n            output.fraction = t;\n            if (numerator > 0.0) {\n                output.normal = Rot.mulVec2(xf.q, normal).neg();\n            }\n            else {\n                output.normal = Rot.mulVec2(xf.q, normal);\n            }\n            return true;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        EdgeShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var v1 = Transform.mulVec2(xf, this.m_vertex1);\n            var v2 = Transform.mulVec2(xf, this.m_vertex2);\n            aabb.combinePoints(v1, v2);\n            aabb.extend(this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        EdgeShape.prototype.computeMass = function (massData, density) {\n            massData.mass = 0.0;\n            massData.center.setCombine(0.5, this.m_vertex1, 0.5, this.m_vertex2);\n            massData.I = 0.0;\n        };\n        EdgeShape.prototype.computeDistanceProxy = function (proxy) {\n            proxy.m_vertices.push(this.m_vertex1);\n            proxy.m_vertices.push(this.m_vertex2);\n            proxy.m_count = 2;\n            proxy.m_radius = this.m_radius;\n        };\n        EdgeShape.TYPE = 'edge';\n        return EdgeShape;\n    }(Shape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A chain shape is a free form sequence of line segments. The chain has\n     * two-sided collision, so you can use inside and outside collision. Therefore,\n     * you may use any winding order. Connectivity information is used to create\n     * smooth collisions.\n     *\n     * WARNING: The chain will not collide properly if there are self-intersections.\n     */\n    var ChainShape = /** @class */ (function (_super) {\n        __extends(ChainShape, _super);\n        function ChainShape(vertices, loop) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof ChainShape)) {\n                return new ChainShape(vertices, loop);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = ChainShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_vertices = [];\n            _this.m_count = 0;\n            _this.m_prevVertex = null;\n            _this.m_nextVertex = null;\n            _this.m_hasPrevVertex = false;\n            _this.m_hasNextVertex = false;\n            _this.m_isLoop = !!loop;\n            if (vertices && vertices.length) {\n                if (loop) {\n                    _this._createLoop(vertices);\n                }\n                else {\n                    _this._createChain(vertices);\n                }\n            }\n            return _this;\n        }\n        /** @internal */\n        ChainShape.prototype._serialize = function () {\n            var data = {\n                type: this.m_type,\n                vertices: this.m_vertices,\n                isLoop: this.m_isLoop,\n                hasPrevVertex: this.m_hasPrevVertex,\n                hasNextVertex: this.m_hasNextVertex,\n                prevVertex: null,\n                nextVertex: null,\n            };\n            if (this.m_prevVertex) {\n                data.prevVertex = this.m_prevVertex;\n            }\n            if (this.m_nextVertex) {\n                data.nextVertex = this.m_nextVertex;\n            }\n            return data;\n        };\n        /** @internal */\n        ChainShape._deserialize = function (data, fixture, restore) {\n            var vertices = [];\n            if (data.vertices) {\n                for (var i = 0; i < data.vertices.length; i++) {\n                    vertices.push(restore(Vec2, data.vertices[i]));\n                }\n            }\n            var shape = new ChainShape(vertices, data.isLoop);\n            if (data.prevVertex) {\n                shape.setPrevVertex(data.prevVertex);\n            }\n            if (data.nextVertex) {\n                shape.setNextVertex(data.nextVertex);\n            }\n            return shape;\n        };\n        // clear() {\n        //   this.m_vertices.length = 0;\n        //   this.m_count = 0;\n        // }\n        /**\n         * @internal\n         * Create a loop. This automatically adjusts connectivity.\n         *\n         * @param vertices an array of vertices, these are copied\n         * @param count the vertex count\n         */\n        ChainShape.prototype._createLoop = function (vertices) {\n            for (var i = 1; i < vertices.length; ++i) {\n                vertices[i - 1];\n                vertices[i];\n            }\n            this.m_vertices = [];\n            this.m_count = vertices.length + 1;\n            for (var i = 0; i < vertices.length; ++i) {\n                this.m_vertices[i] = Vec2.clone(vertices[i]);\n            }\n            this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n            this.m_prevVertex = this.m_vertices[this.m_count - 2];\n            this.m_nextVertex = this.m_vertices[1];\n            this.m_hasPrevVertex = true;\n            this.m_hasNextVertex = true;\n            return this;\n        };\n        /**\n         * @internal\n         * Create a chain with isolated end vertices.\n         *\n         * @param vertices an array of vertices, these are copied\n         * @param count the vertex count\n         */\n        ChainShape.prototype._createChain = function (vertices) {\n            for (var i = 1; i < vertices.length; ++i) {\n                // If the code crashes here, it means your vertices are too close together.\n                vertices[i - 1];\n                vertices[i];\n            }\n            this.m_count = vertices.length;\n            for (var i = 0; i < vertices.length; ++i) {\n                this.m_vertices[i] = Vec2.clone(vertices[i]);\n            }\n            this.m_hasPrevVertex = false;\n            this.m_hasNextVertex = false;\n            this.m_prevVertex = null;\n            this.m_nextVertex = null;\n            return this;\n        };\n        /** @internal */\n        ChainShape.prototype._reset = function () {\n            if (this.m_isLoop) {\n                this._createLoop(this.m_vertices);\n            }\n            else {\n                this._createChain(this.m_vertices);\n            }\n        };\n        /**\n         * Establish connectivity to a vertex that precedes the first vertex. Don't call\n         * this for loops.\n         */\n        ChainShape.prototype.setPrevVertex = function (prevVertex) {\n            this.m_prevVertex = prevVertex;\n            this.m_hasPrevVertex = true;\n        };\n        ChainShape.prototype.getPrevVertex = function () {\n            return this.m_prevVertex;\n        };\n        /**\n         * Establish connectivity to a vertex that follows the last vertex. Don't call\n         * this for loops.\n         */\n        ChainShape.prototype.setNextVertex = function (nextVertex) {\n            this.m_nextVertex = nextVertex;\n            this.m_hasNextVertex = true;\n        };\n        ChainShape.prototype.getNextVertex = function () {\n            return this.m_nextVertex;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        ChainShape.prototype._clone = function () {\n            var clone = new ChainShape();\n            clone._createChain(this.m_vertices);\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_prevVertex = this.m_prevVertex;\n            clone.m_nextVertex = this.m_nextVertex;\n            clone.m_hasPrevVertex = this.m_hasPrevVertex;\n            clone.m_hasNextVertex = this.m_hasNextVertex;\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        ChainShape.prototype.getChildCount = function () {\n            // edge count = vertex count - 1\n            return this.m_count - 1;\n        };\n        // Get a child edge.\n        ChainShape.prototype.getChildEdge = function (edge, childIndex) {\n            edge.m_type = EdgeShape.TYPE;\n            edge.m_radius = this.m_radius;\n            edge.m_vertex1 = this.m_vertices[childIndex];\n            edge.m_vertex2 = this.m_vertices[childIndex + 1];\n            if (childIndex > 0) {\n                edge.m_vertex0 = this.m_vertices[childIndex - 1];\n                edge.m_hasVertex0 = true;\n            }\n            else {\n                edge.m_vertex0 = this.m_prevVertex;\n                edge.m_hasVertex0 = this.m_hasPrevVertex;\n            }\n            if (childIndex < this.m_count - 2) {\n                edge.m_vertex3 = this.m_vertices[childIndex + 2];\n                edge.m_hasVertex3 = true;\n            }\n            else {\n                edge.m_vertex3 = this.m_nextVertex;\n                edge.m_hasVertex3 = this.m_hasNextVertex;\n            }\n        };\n        ChainShape.prototype.getVertex = function (index) {\n            if (index < this.m_count) {\n                return this.m_vertices[index];\n            }\n            else {\n                return this.m_vertices[0];\n            }\n        };\n        ChainShape.prototype.isLoop = function () {\n            return this.m_isLoop;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * This always return false.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        ChainShape.prototype.testPoint = function (xf, p) {\n            return false;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        ChainShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n            return edgeShape.rayCast(output, input, xf, 0);\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        ChainShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var v1 = Transform.mulVec2(xf, this.getVertex(childIndex));\n            var v2 = Transform.mulVec2(xf, this.getVertex(childIndex + 1));\n            aabb.combinePoints(v1, v2);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * Chains have zero mass.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        ChainShape.prototype.computeMass = function (massData, density) {\n            massData.mass = 0.0;\n            massData.center = Vec2.zero();\n            massData.I = 0.0;\n        };\n        ChainShape.prototype.computeDistanceProxy = function (proxy, childIndex) {\n            proxy.m_buffer[0] = this.getVertex(childIndex);\n            proxy.m_buffer[1] = this.getVertex(childIndex + 1);\n            proxy.m_vertices = proxy.m_buffer;\n            proxy.m_count = 2;\n            proxy.m_radius = this.m_radius;\n        };\n        ChainShape.TYPE = 'chain';\n        return ChainShape;\n    }(Shape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A convex polygon. It is assumed that the interior of the polygon is to the\n     * left of each edge. Polygons have a maximum number of vertices equal to\n     * Settings.maxPolygonVertices. In most cases you should not need many vertices\n     * for a convex polygon. extends Shape\n     */\n    var PolygonShape = /** @class */ (function (_super) {\n        __extends(PolygonShape, _super);\n        // @ts-ignore\n        function PolygonShape(vertices) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PolygonShape)) {\n                return new PolygonShape(vertices);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = PolygonShape.TYPE;\n            _this.m_radius = Settings.polygonRadius;\n            _this.m_centroid = Vec2.zero();\n            _this.m_vertices = [];\n            _this.m_normals = [];\n            _this.m_count = 0;\n            if (vertices && vertices.length) {\n                _this._set(vertices);\n            }\n            return _this;\n        }\n        /** @internal */\n        PolygonShape.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                vertices: this.m_vertices,\n            };\n        };\n        /** @internal */\n        PolygonShape._deserialize = function (data, fixture, restore) {\n            var vertices = [];\n            if (data.vertices) {\n                for (var i = 0; i < data.vertices.length; i++) {\n                    vertices.push(restore(Vec2, data.vertices[i]));\n                }\n            }\n            var shape = new PolygonShape(vertices);\n            return shape;\n        };\n        PolygonShape.prototype.getVertex = function (index) {\n            return this.m_vertices[index];\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        PolygonShape.prototype._clone = function () {\n            var clone = new PolygonShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_count = this.m_count;\n            clone.m_centroid.setVec2(this.m_centroid);\n            for (var i = 0; i < this.m_count; i++) {\n                clone.m_vertices.push(this.m_vertices[i].clone());\n            }\n            for (var i = 0; i < this.m_normals.length; i++) {\n                clone.m_normals.push(this.m_normals[i].clone());\n            }\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        PolygonShape.prototype.getChildCount = function () {\n            return 1;\n        };\n        /** @internal */\n        PolygonShape.prototype._reset = function () {\n            this._set(this.m_vertices);\n        };\n        /**\n         * @internal\n         *\n         * Create a convex hull from the given array of local points. The count must be\n         * in the range [3, Settings.maxPolygonVertices].\n         *\n         * Warning: the points may be re-ordered, even if they form a convex polygon\n         * Warning: collinear points are handled but not removed. Collinear points may\n         * lead to poor stacking behavior.\n         */\n        PolygonShape.prototype._set = function (vertices) {\n            if (vertices.length < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            var n = math.min(vertices.length, Settings.maxPolygonVertices);\n            // Perform welding and copy vertices into local buffer.\n            var ps = []; // [Settings.maxPolygonVertices];\n            for (var i = 0; i < n; ++i) {\n                var v = vertices[i];\n                var unique = true;\n                for (var j = 0; j < ps.length; ++j) {\n                    if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n                        unique = false;\n                        break;\n                    }\n                }\n                if (unique) {\n                    ps.push(v);\n                }\n            }\n            n = ps.length;\n            if (n < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            // Create the convex hull using the Gift wrapping algorithm\n            // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n            // Find the right most point on the hull (in case of multiple points bottom most is used)\n            var i0 = 0;\n            var x0 = ps[0].x;\n            for (var i = 1; i < n; ++i) {\n                var x = ps[i].x;\n                if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\n                    i0 = i;\n                    x0 = x;\n                }\n            }\n            var hull = []; // [Settings.maxPolygonVertices];\n            var m = 0;\n            var ih = i0;\n            while (true) {\n                hull[m] = ih;\n                var ie = 0;\n                for (var j = 1; j < n; ++j) {\n                    if (ie === ih) {\n                        ie = j;\n                        continue;\n                    }\n                    var r = Vec2.sub(ps[ie], ps[hull[m]]);\n                    var v = Vec2.sub(ps[j], ps[hull[m]]);\n                    var c = Vec2.crossVec2Vec2(r, v);\n                    // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n                    if (c < 0.0) {\n                        ie = j;\n                    }\n                    // Collinearity check\n                    if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {\n                        ie = j;\n                    }\n                }\n                ++m;\n                ih = ie;\n                if (ie === i0) {\n                    break;\n                }\n            }\n            if (m < 3) {\n                this._setAsBox(1.0, 1.0);\n                return;\n            }\n            this.m_count = m;\n            // Copy vertices.\n            this.m_vertices = [];\n            for (var i = 0; i < m; ++i) {\n                this.m_vertices[i] = ps[hull[i]];\n            }\n            // Compute normals. Ensure the edges have non-zero length.\n            for (var i = 0; i < m; ++i) {\n                var i1 = i;\n                var i2 = i + 1 < m ? i + 1 : 0;\n                var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n                this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n                this.m_normals[i].normalize();\n            }\n            // Compute the polygon centroid.\n            this.m_centroid = ComputeCentroid(this.m_vertices, m);\n        };\n        /** @internal */\n        PolygonShape.prototype._setAsBox = function (hx, hy, center, angle) {\n            // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n            this.m_vertices[0] = Vec2.neo(hx, -hy);\n            this.m_vertices[1] = Vec2.neo(hx, hy);\n            this.m_vertices[2] = Vec2.neo(-hx, hy);\n            this.m_vertices[3] = Vec2.neo(-hx, -hy);\n            this.m_normals[0] = Vec2.neo(1.0, 0.0);\n            this.m_normals[1] = Vec2.neo(0.0, 1.0);\n            this.m_normals[2] = Vec2.neo(-1.0, 0.0);\n            this.m_normals[3] = Vec2.neo(0.0, -1.0);\n            this.m_count = 4;\n            if (Vec2.isValid(center)) {\n                angle = angle || 0;\n                this.m_centroid.setVec2(center);\n                var xf = Transform.identity();\n                xf.p.setVec2(center);\n                xf.q.setAngle(angle);\n                // Transform vertices and normals.\n                for (var i = 0; i < this.m_count; ++i) {\n                    this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n                    this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n                }\n            }\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        PolygonShape.prototype.testPoint = function (xf, p) {\n            var pLocal = Rot.mulTVec2(xf.q, Vec2.sub(p, xf.p));\n            for (var i = 0; i < this.m_count; ++i) {\n                var dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));\n                if (dot > 0.0) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        PolygonShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            // Put the ray into the polygon's frame of reference.\n            var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n            var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n            var d = Vec2.sub(p2, p1);\n            var lower = 0.0;\n            var upper = input.maxFraction;\n            var index = -1;\n            for (var i = 0; i < this.m_count; ++i) {\n                // p = p1 + a * d\n                // dot(normal, p - v) = 0\n                // dot(normal, p1 - v) + a * dot(normal, d) = 0\n                var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n                var denominator = Vec2.dot(this.m_normals[i], d);\n                if (denominator == 0.0) {\n                    if (numerator < 0.0) {\n                        return false;\n                    }\n                }\n                else {\n                    // Note: we want this predicate without division:\n                    // lower < numerator / denominator, where denominator < 0\n                    // Since denominator < 0, we have to flip the inequality:\n                    // lower < numerator / denominator <==> denominator * lower > numerator.\n                    if (denominator < 0.0 && numerator < lower * denominator) {\n                        // Increase lower.\n                        // The segment enters this half-space.\n                        lower = numerator / denominator;\n                        index = i;\n                    }\n                    else if (denominator > 0.0 && numerator < upper * denominator) {\n                        // Decrease upper.\n                        // The segment exits this half-space.\n                        upper = numerator / denominator;\n                    }\n                }\n                // The use of epsilon here causes the assert on lower to trip\n                // in some cases. Apparently the use of epsilon was to make edge\n                // shapes work, but now those are handled separately.\n                // if (upper < lower - Math.EPSILON)\n                if (upper < lower) {\n                    return false;\n                }\n            }\n            if (index >= 0) {\n                output.fraction = lower;\n                output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        PolygonShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var minX = Infinity;\n            var minY = Infinity;\n            var maxX = -Infinity;\n            var maxY = -Infinity;\n            for (var i = 0; i < this.m_count; ++i) {\n                var v = Transform.mulVec2(xf, this.m_vertices[i]);\n                minX = math.min(minX, v.x);\n                maxX = math.max(maxX, v.x);\n                minY = math.min(minY, v.y);\n                maxY = math.max(maxY, v.y);\n            }\n            aabb.lowerBound.setNum(minX, minY);\n            aabb.upperBound.setNum(maxX, maxY);\n            aabb.extend(this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        PolygonShape.prototype.computeMass = function (massData, density) {\n            var center = Vec2.zero();\n            var area = 0.0;\n            var I = 0.0;\n            // s is the reference point for forming triangles.\n            // It's location doesn't change the result (except for rounding error).\n            var s = Vec2.zero();\n            // This code would put the reference point inside the polygon.\n            for (var i = 0; i < this.m_count; ++i) {\n                s.add(this.m_vertices[i]);\n            }\n            s.mul(1.0 / this.m_count);\n            var k_inv3 = 1.0 / 3.0;\n            for (var i = 0; i < this.m_count; ++i) {\n                // Triangle vertices.\n                var e1 = Vec2.sub(this.m_vertices[i], s);\n                var e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2.sub(this.m_vertices[0], s);\n                var D = Vec2.crossVec2Vec2(e1, e2);\n                var triangleArea = 0.5 * D;\n                area += triangleArea;\n                // Area weighted centroid\n                center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);\n                var ex1 = e1.x;\n                var ey1 = e1.y;\n                var ex2 = e2.x;\n                var ey2 = e2.y;\n                var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n                var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n                I += (0.25 * k_inv3 * D) * (intx2 + inty2);\n            }\n            // Total mass\n            massData.mass = density * area;\n            center.mul(1.0 / area);\n            massData.center.setCombine(1, center, 1, s);\n            // Inertia tensor relative to the local origin (point s).\n            massData.I = density * I;\n            // Shift to center of mass then to original body origin.\n            massData.I += massData.mass * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));\n        };\n        /**\n         * Validate convexity. This is a very time consuming operation.\n         * @returns true if valid\n         */\n        PolygonShape.prototype.validate = function () {\n            for (var i = 0; i < this.m_count; ++i) {\n                var i1 = i;\n                var i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n                var p = this.m_vertices[i1];\n                var e = Vec2.sub(this.m_vertices[i2], p);\n                for (var j = 0; j < this.m_count; ++j) {\n                    if (j == i1 || j == i2) {\n                        continue;\n                    }\n                    var v = Vec2.sub(this.m_vertices[j], p);\n                    var c = Vec2.crossVec2Vec2(e, v);\n                    if (c < 0.0) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        PolygonShape.prototype.computeDistanceProxy = function (proxy) {\n            proxy.m_vertices = this.m_vertices;\n            proxy.m_count = this.m_count;\n            proxy.m_radius = this.m_radius;\n        };\n        PolygonShape.TYPE = 'polygon';\n        return PolygonShape;\n    }(Shape));\n    function ComputeCentroid(vs, count) {\n        var c = Vec2.zero();\n        var area = 0.0;\n        // pRef is the reference point for forming triangles.\n        // It's location doesn't change the result (except for rounding error).\n        var pRef = Vec2.zero();\n        var i; \n        var inv3 = 1.0 / 3.0;\n        for (var i = 0; i < count; ++i) {\n            // Triangle vertices.\n            var p1 = pRef;\n            var p2 = vs[i];\n            var p3 = i + 1 < count ? vs[i + 1] : vs[0];\n            var e1 = Vec2.sub(p2, p1);\n            var e2 = Vec2.sub(p3, p1);\n            var D = Vec2.crossVec2Vec2(e1, e2);\n            var triangleArea = 0.5 * D;\n            area += triangleArea;\n            // Area weighted centroid\n            c.addMul(triangleArea * inv3, p1);\n            c.addMul(triangleArea * inv3, p2);\n            c.addMul(triangleArea * inv3, p3);\n        }\n        c.mul(1.0 / area);\n        return c;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A rectangle polygon which extend PolygonShape.\n     */\n    var BoxShape = /** @class */ (function (_super) {\n        __extends(BoxShape, _super);\n        function BoxShape(hx, hy, center, angle) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof BoxShape)) {\n                return new BoxShape(hx, hy, center, angle);\n            }\n            _this = _super.call(this) || this;\n            _this._setAsBox(hx, hy, center, angle);\n            return _this;\n        }\n        BoxShape.TYPE = 'polygon';\n        return BoxShape;\n    }(PolygonShape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var CircleShape = /** @class */ (function (_super) {\n        __extends(CircleShape, _super);\n        // tslint:disable-next-line:typedef\n        function CircleShape(a, b) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof CircleShape)) {\n                return new CircleShape(a, b);\n            }\n            _this = _super.call(this) || this;\n            _this.m_type = CircleShape.TYPE;\n            _this.m_p = Vec2.zero();\n            _this.m_radius = 1;\n            if (typeof a === 'object' && Vec2.isValid(a)) {\n                _this.m_p.setVec2(a);\n                if (typeof b === 'number') {\n                    _this.m_radius = b;\n                }\n            }\n            else if (typeof a === 'number') {\n                _this.m_radius = a;\n            }\n            return _this;\n        }\n        /** @internal */\n        CircleShape.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                p: this.m_p,\n                radius: this.m_radius,\n            };\n        };\n        /** @internal */\n        CircleShape._deserialize = function (data) {\n            return new CircleShape(data.p, data.radius);\n        };\n        // TODO: already defined in Shape\n        CircleShape.prototype.getRadius = function () {\n            return this.m_radius;\n        };\n        CircleShape.prototype.getCenter = function () {\n            return this.m_p;\n        };\n        CircleShape.prototype.getVertex = function (index) {\n            return this.m_p;\n        };\n        /**\n         * @internal\n         * @deprecated Shapes should be treated as immutable.\n         *\n         * clone the concrete shape.\n         */\n        CircleShape.prototype._clone = function () {\n            var clone = new CircleShape();\n            clone.m_type = this.m_type;\n            clone.m_radius = this.m_radius;\n            clone.m_p = this.m_p.clone();\n            return clone;\n        };\n        /**\n         * Get the number of child primitives.\n         */\n        CircleShape.prototype.getChildCount = function () {\n            return 1;\n        };\n        /**\n         * Test a point for containment in this shape. This only works for convex\n         * shapes.\n         *\n         * @param xf The shape world transform.\n         * @param p A point in world coordinates.\n         */\n        CircleShape.prototype.testPoint = function (xf, p) {\n            var center = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            var d = Vec2.sub(p, center);\n            return Vec2.dot(d, d) <= this.m_radius * this.m_radius;\n        };\n        /**\n         * Cast a ray against a child shape.\n         *\n         * @param output The ray-cast results.\n         * @param input The ray-cast input parameters.\n         * @param xf The transform to be applied to the shape.\n         * @param childIndex The child shape index\n         */\n        CircleShape.prototype.rayCast = function (output, input, xf, childIndex) {\n            // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n            // From Section 3.1.2\n            // x = s + a * r\n            // norm(x) = radius\n            var position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            var s = Vec2.sub(input.p1, position);\n            var b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n            // Solve quadratic equation.\n            var r = Vec2.sub(input.p2, input.p1);\n            var c = Vec2.dot(s, r);\n            var rr = Vec2.dot(r, r);\n            var sigma = c * c - rr * b;\n            // Check for negative discriminant and short segment.\n            if (sigma < 0.0 || rr < math.EPSILON) {\n                return false;\n            }\n            // Find the point of intersection of the line with the circle.\n            var a = -(c + math.sqrt(sigma));\n            // Is the intersection point on the segment?\n            if (0.0 <= a && a <= input.maxFraction * rr) {\n                a /= rr;\n                output.fraction = a;\n                output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n                output.normal.normalize();\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Given a transform, compute the associated axis aligned bounding box for a\n         * child shape.\n         *\n         * @param aabb Returns the axis aligned box.\n         * @param xf The world transform of the shape.\n         * @param childIndex The child shape\n         */\n        CircleShape.prototype.computeAABB = function (aabb, xf, childIndex) {\n            var p = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n            aabb.lowerBound.setNum(p.x - this.m_radius, p.y - this.m_radius);\n            aabb.upperBound.setNum(p.x + this.m_radius, p.y + this.m_radius);\n        };\n        /**\n         * Compute the mass properties of this shape using its dimensions and density.\n         * The inertia tensor is computed about the local origin.\n         *\n         * @param massData Returns the mass data for this shape.\n         * @param density The density in kilograms per meter squared.\n         */\n        CircleShape.prototype.computeMass = function (massData, density) {\n            massData.mass = density * math.PI * this.m_radius * this.m_radius;\n            massData.center = this.m_p;\n            // inertia about the local origin\n            massData.I = massData.mass\n                * (0.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));\n        };\n        CircleShape.prototype.computeDistanceProxy = function (proxy) {\n            proxy.m_vertices.push(this.m_p);\n            proxy.m_count = 1;\n            proxy.m_radius = this.m_radius;\n        };\n        CircleShape.TYPE = 'circle';\n        return CircleShape;\n    }(Shape));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$a = {\n        frequencyHz: 0.0,\n        dampingRatio: 0.0\n    };\n    /**\n     * A distance joint constrains two points on two bodies to remain at a fixed\n     * distance from each other. You can view this as a massless, rigid rod.\n     *\n     * @param anchorA Anchor A in global coordination.\n     * @param anchorB Anchor B in global coordination.\n     */\n    var DistanceJoint = /** @class */ (function (_super) {\n        __extends(DistanceJoint, _super);\n        function DistanceJoint(def, bodyA, bodyB, anchorA, anchorB) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof DistanceJoint)) {\n                return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n            }\n            // order of constructor arguments is changed in v0.2\n            if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {\n                var temp = bodyB;\n                bodyB = anchorA;\n                anchorA = temp;\n            }\n            def = options(def, DEFAULTS$a);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = DistanceJoint.TYPE;\n            // Solver shared\n            _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n            _this.m_length = math.isFinite(def.length) ? def.length :\n                Vec2.distance(bodyA.getWorldPoint(_this.m_localAnchorA), bodyB.getWorldPoint(_this.m_localAnchorB));\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_impulse = 0.0;\n            _this.m_gamma = 0.0;\n            _this.m_bias = 0.0;\n            return _this;\n            // 1-D constrained system\n            // m (v2 - v1) = lambda\n            // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n            // x2 = x1 + h * v2\n            // 1-D mass-damper-spring system\n            // m (v2 - v1) + h * d * v2 + h * k *\n            // C = norm(p2 - p1) - L\n            // u = (p2 - p1) / norm(p2 - p1)\n            // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n            // J = [-u -cross(r1, u) u cross(r2, u)]\n            // K = J * invM * JT\n            // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n        }\n        /** @internal */\n        DistanceJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                length: this.m_length,\n                impulse: this.m_impulse,\n                gamma: this.m_gamma,\n                bias: this.m_bias,\n            };\n        };\n        /** @internal */\n        DistanceJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new DistanceJoint(data);\n            return joint;\n        };\n        /** @internal */\n        DistanceJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n            if (def.length > 0) {\n                this.m_length = +def.length;\n            }\n            else if (def.length < 0) ;\n            else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n                this.m_length = Vec2.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA), this.m_bodyB.getWorldPoint(this.m_localAnchorB));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        DistanceJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        DistanceJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the natural length. Manipulating the length can lead to non-physical\n         * behavior when the frequency is zero.\n         */\n        DistanceJoint.prototype.setLength = function (length) {\n            this.m_length = length;\n        };\n        /**\n         * Get the natural length.\n         */\n        DistanceJoint.prototype.getLength = function () {\n            return this.m_length;\n        };\n        DistanceJoint.prototype.setFrequency = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        DistanceJoint.prototype.getFrequency = function () {\n            return this.m_frequencyHz;\n        };\n        DistanceJoint.prototype.setDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        DistanceJoint.prototype.getDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        DistanceJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        DistanceJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        DistanceJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        DistanceJoint.prototype.getReactionTorque = function (inv_dt) {\n            return 0.0;\n        };\n        DistanceJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n            // Handle singularity.\n            var length = this.m_u.length();\n            if (length > Settings.linearSlop) {\n                this.m_u.mul(1.0 / length);\n            }\n            else {\n                this.m_u.setNum(0.0, 0.0);\n            }\n            var crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n            var crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n            var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB\n                + this.m_invIB * crBu * crBu;\n            // Compute the effective mass matrix.\n            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            if (this.m_frequencyHz > 0.0) {\n                var C = length - this.m_length;\n                // Frequency\n                var omega = 2.0 * math.PI * this.m_frequencyHz;\n                // Damping coefficient\n                var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n                // Spring stiffness\n                var k = this.m_mass * omega * omega;\n                // magic formulas\n                var h = step.dt;\n                this.m_gamma = h * (d + h * k);\n                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n                this.m_bias = C * h * k * this.m_gamma;\n                invMass += this.m_gamma;\n                this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            }\n            else {\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            if (step.warmStarting) {\n                // Scale the impulse to support a variable time step.\n                this.m_impulse *= step.dtRatio;\n                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        DistanceJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Cdot = dot(u, v + cross(w, r))\n            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n            var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n            var impulse = -this.m_mass\n                * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n            this.m_impulse += impulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_u);\n            vA.subMul(this.m_invMassA, P);\n            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n            vB.addMul(this.m_invMassB, P);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        DistanceJoint.prototype.solvePositionConstraints = function (step) {\n            if (this.m_frequencyHz > 0.0) {\n                // There is no position correction for soft distance constraints.\n                return true;\n            }\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            var u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n            var length = u.normalize();\n            var C = length - this.m_length;\n            C = math\n                .clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n            var impulse = -this.m_mass * C;\n            var P = Vec2.mulNumVec2(impulse, u);\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return math.abs(C) < Settings.linearSlop;\n        };\n        DistanceJoint.TYPE = 'distance-joint';\n        return DistanceJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$9 = {\n        maxForce: 0.0,\n        maxTorque: 0.0,\n    };\n    /**\n     * Friction joint. This is used for top-down friction. It provides 2D\n     * translational friction and angular friction.\n     *\n     * @param anchor Anchor in global coordination.\n     */\n    var FrictionJoint = /** @class */ (function (_super) {\n        __extends(FrictionJoint, _super);\n        function FrictionJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof FrictionJoint)) {\n                return new FrictionJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$9);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = FrictionJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            // Solver shared\n            _this.m_linearImpulse = Vec2.zero();\n            _this.m_angularImpulse = 0.0;\n            _this.m_maxForce = def.maxForce;\n            _this.m_maxTorque = def.maxTorque;\n            return _this;\n            // Point-to-point constraint\n            // Cdot = v2 - v1\n            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Angle constraint\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        FrictionJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                maxForce: this.m_maxForce,\n                maxTorque: this.m_maxTorque,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n            };\n        };\n        /** @internal */\n        FrictionJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new FrictionJoint(data);\n            return joint;\n        };\n        /** @internal */\n        FrictionJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        FrictionJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        FrictionJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the maximum friction force in N.\n         */\n        FrictionJoint.prototype.setMaxForce = function (force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum friction force in N.\n         */\n        FrictionJoint.prototype.getMaxForce = function () {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the maximum friction torque in N*m.\n         */\n        FrictionJoint.prototype.setMaxTorque = function (torque) {\n            this.m_maxTorque = torque;\n        };\n        /**\n         * Get the maximum friction torque in N*m.\n         */\n        FrictionJoint.prototype.getMaxTorque = function () {\n            return this.m_maxTorque;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        FrictionJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        FrictionJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        FrictionJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        FrictionJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_angularImpulse;\n        };\n        FrictionJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective mass matrix.\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat22();\n            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y\n                * this.m_rB.y;\n            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x\n                * this.m_rB.x;\n            this.m_linearMass = K.getInverse();\n            this.m_angularMass = iA + iB;\n            if (this.m_angularMass > 0.0) {\n                this.m_angularMass = 1.0 / this.m_angularMass;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_linearImpulse.mul(step.dtRatio);\n                this.m_angularImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n            }\n            else {\n                this.m_linearImpulse.setZero();\n                this.m_angularImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        FrictionJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var h = step.dt; // float\n            // Solve angular friction\n            {\n                var Cdot = wB - wA; // float\n                var impulse = -this.m_angularMass * Cdot; // float\n                var oldImpulse = this.m_angularImpulse; // float\n                var maxImpulse = h * this.m_maxTorque; // float\n                this.m_angularImpulse = math.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_angularImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve linear friction\n            {\n                var Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA))); // Vec2\n                var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2\n                var oldImpulse = this.m_linearImpulse; // Vec2\n                this.m_linearImpulse.add(impulse);\n                var maxImpulse = h * this.m_maxForce; // float\n                if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n                    this.m_linearImpulse.normalize();\n                    this.m_linearImpulse.mul(maxImpulse);\n                }\n                impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n                vA.subMul(mA, impulse);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n                vB.addMul(mB, impulse);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        FrictionJoint.prototype.solvePositionConstraints = function (step) {\n            return true;\n        };\n        FrictionJoint.TYPE = 'friction-joint';\n        return FrictionJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    /**\n     * A 3-by-3 matrix. Stored in column-major order.\n     */\n    var Mat33 = /** @class */ (function () {\n        function Mat33(a, b, c) {\n            if (typeof a === 'object' && a !== null) {\n                this.ex = Vec3.clone(a);\n                this.ey = Vec3.clone(b);\n                this.ez = Vec3.clone(c);\n            }\n            else {\n                this.ex = Vec3.zero();\n                this.ey = Vec3.zero();\n                this.ez = Vec3.zero();\n            }\n        }\n        /** @internal */\n        Mat33.prototype.toString = function () {\n            return JSON.stringify(this);\n        };\n        Mat33.isValid = function (obj) {\n            if (obj === null || typeof obj === 'undefined') {\n                return false;\n            }\n            return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n        };\n        Mat33.assert = function (o) {\n            return;\n        };\n        /**\n         * Set this matrix to all zeros.\n         */\n        Mat33.prototype.setZero = function () {\n            this.ex.setZero();\n            this.ey.setZero();\n            this.ez.setZero();\n            return this;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases.\n         */\n        Mat33.prototype.solve33 = function (v) {\n            var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var r = new Vec3();\n            r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));\n            r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));\n            r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));\n            return r;\n        };\n        /**\n         * Solve A * x = b, where b is a column vector. This is more efficient than\n         * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n         * equation.\n         */\n        Mat33.prototype.solve22 = function (v) {\n            var a11 = this.ex.x;\n            var a12 = this.ey.x;\n            var a21 = this.ex.y;\n            var a22 = this.ey.y;\n            var det = a11 * a22 - a12 * a21;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var r = Vec2.zero();\n            r.x = det * (a22 * v.x - a12 * v.y);\n            r.y = det * (a11 * v.y - a21 * v.x);\n            return r;\n        };\n        /**\n         * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n         * singular.\n         */\n        Mat33.prototype.getInverse22 = function (M) {\n            var a = this.ex.x;\n            var b = this.ey.x;\n            var c = this.ex.y;\n            var d = this.ey.y;\n            var det = a * d - b * c;\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            M.ex.x = det * d;\n            M.ey.x = -det * b;\n            M.ex.z = 0.0;\n            M.ex.y = -det * c;\n            M.ey.y = det * a;\n            M.ey.z = 0.0;\n            M.ez.x = 0.0;\n            M.ez.y = 0.0;\n            M.ez.z = 0.0;\n        };\n        /**\n         * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n         * if singular.\n         */\n        Mat33.prototype.getSymInverse33 = function (M) {\n            var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n            if (det !== 0.0) {\n                det = 1.0 / det;\n            }\n            var a11 = this.ex.x;\n            var a12 = this.ey.x;\n            var a13 = this.ez.x;\n            var a22 = this.ey.y;\n            var a23 = this.ez.y;\n            var a33 = this.ez.z;\n            M.ex.x = det * (a22 * a33 - a23 * a23);\n            M.ex.y = det * (a13 * a23 - a12 * a33);\n            M.ex.z = det * (a12 * a23 - a13 * a22);\n            M.ey.x = M.ex.y;\n            M.ey.y = det * (a11 * a33 - a13 * a13);\n            M.ey.z = det * (a13 * a12 - a11 * a23);\n            M.ez.x = M.ex.z;\n            M.ez.y = M.ey.z;\n            M.ez.z = det * (a11 * a22 - a12 * a12);\n        };\n        // tslint:disable-next-line:typedef\n        Mat33.mul = function (a, b) {\n            if (b && 'z' in b && 'y' in b && 'x' in b) {\n                var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n                var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n                var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n                return new Vec3(x, y, z);\n            }\n            else if (b && 'y' in b && 'x' in b) {\n                var x = a.ex.x * b.x + a.ey.x * b.y;\n                var y = a.ex.y * b.x + a.ey.y * b.y;\n                return Vec2.neo(x, y);\n            }\n        };\n        Mat33.mulVec3 = function (a, b) {\n            var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n            var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n            var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n            return new Vec3(x, y, z);\n        };\n        Mat33.mulVec2 = function (a, b) {\n            var x = a.ex.x * b.x + a.ey.x * b.y;\n            var y = a.ex.y * b.x + a.ey.y * b.y;\n            return Vec2.neo(x, y);\n        };\n        Mat33.add = function (a, b) {\n            return new Mat33(Vec3.add(a.ex, b.ex), Vec3.add(a.ey, b.ey), Vec3.add(a.ez, b.ez));\n        };\n        return Mat33;\n    }());\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var inactiveLimit$2 = 0;\n    var atLowerLimit$1 = 1;\n    var atUpperLimit$2 = 2;\n    var equalLimits$1 = 3;\n    var DEFAULTS$8 = {\n        lowerAngle: 0.0,\n        upperAngle: 0.0,\n        maxMotorTorque: 0.0,\n        motorSpeed: 0.0,\n        enableLimit: false,\n        enableMotor: false\n    };\n    /**\n     * A revolute joint constrains two bodies to share a common point while they are\n     * free to rotate about the point. The relative rotation about the shared point\n     * is the joint angle. You can limit the relative rotation with a joint limit\n     * that specifies a lower and upper angle. You can use a motor to drive the\n     * relative rotation about the shared point. A maximum motor torque is provided\n     * so that infinite forces are not generated.\n     */\n    var RevoluteJoint = /** @class */ (function (_super) {\n        __extends(RevoluteJoint, _super);\n        // @ts-ignore\n        function RevoluteJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof RevoluteJoint)) {\n                return new RevoluteJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$8);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            // effective mass for point-to-point constraint.\n            /** @internal */ _this.m_mass = new Mat33();\n            /** @internal */ _this.m_limitState = inactiveLimit$2; // TODO enum\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = RevoluteJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_referenceAngle = math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_impulse = new Vec3();\n            _this.m_motorImpulse = 0.0;\n            _this.m_lowerAngle = def.lowerAngle;\n            _this.m_upperAngle = def.upperAngle;\n            _this.m_maxMotorTorque = def.maxMotorTorque;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableLimit = def.enableLimit;\n            _this.m_enableMotor = def.enableMotor;\n            return _this;\n            // Point-to-point constraint\n            // C = p2 - p1\n            // Cdot = v2 - v1\n            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Motor constraint\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        RevoluteJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                lowerAngle: this.m_lowerAngle,\n                upperAngle: this.m_upperAngle,\n                maxMotorTorque: this.m_maxMotorTorque,\n                motorSpeed: this.m_motorSpeed,\n                enableLimit: this.m_enableLimit,\n                enableMotor: this.m_enableMotor,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                referenceAngle: this.m_referenceAngle,\n            };\n        };\n        /** @internal */\n        RevoluteJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new RevoluteJoint(data);\n            return joint;\n        };\n        /** @internal */\n        RevoluteJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        RevoluteJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        RevoluteJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Get the reference angle.\n         */\n        RevoluteJoint.prototype.getReferenceAngle = function () {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint angle in radians.\n         */\n        RevoluteJoint.prototype.getJointAngle = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint angle speed in radians per second.\n         */\n        RevoluteJoint.prototype.getJointSpeed = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            return bB.m_angularVelocity - bA.m_angularVelocity;\n        };\n        /**\n         * Is the joint motor enabled?\n         */\n        RevoluteJoint.prototype.isMotorEnabled = function () {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */\n        RevoluteJoint.prototype.enableMotor = function (flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Get the current motor torque given the inverse time step. Unit is N*m.\n         */\n        RevoluteJoint.prototype.getMotorTorque = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Set the motor speed in radians per second.\n         */\n        RevoluteJoint.prototype.setMotorSpeed = function (speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Get the motor speed in radians per second.\n         */\n        RevoluteJoint.prototype.getMotorSpeed = function () {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Set the maximum motor torque, usually in N-m.\n         */\n        RevoluteJoint.prototype.setMaxMotorTorque = function (torque) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorTorque = torque;\n        };\n        RevoluteJoint.prototype.getMaxMotorTorque = function () {\n            return this.m_maxMotorTorque;\n        };\n        /**\n         * Is the joint limit enabled?\n         */\n        RevoluteJoint.prototype.isLimitEnabled = function () {\n            return this.m_enableLimit;\n        };\n        /**\n         * Enable/disable the joint limit.\n         */\n        RevoluteJoint.prototype.enableLimit = function (flag) {\n            if (flag != this.m_enableLimit) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_enableLimit = flag;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Get the lower joint limit in radians.\n         */\n        RevoluteJoint.prototype.getLowerLimit = function () {\n            return this.m_lowerAngle;\n        };\n        /**\n         * Get the upper joint limit in radians.\n         */\n        RevoluteJoint.prototype.getUpperLimit = function () {\n            return this.m_upperAngle;\n        };\n        /**\n         * Set the joint limits in radians.\n         */\n        RevoluteJoint.prototype.setLimits = function (lower, upper) {\n            if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_impulse.z = 0.0;\n                this.m_lowerAngle = lower;\n                this.m_upperAngle = upper;\n            }\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        RevoluteJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        RevoluteJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force given the inverse time step. Unit is N.\n         */\n        RevoluteJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque due to the joint limit given the inverse time step.\n         * Unit is N*m.\n         */\n        RevoluteJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_impulse.z;\n        };\n        RevoluteJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var fixedRotation = (iA + iB === 0.0); // bool\n            this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y\n                * this.m_rB.y * iB;\n            this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y\n                * this.m_rB.x * iB;\n            this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n            this.m_mass.ex.y = this.m_mass.ey.x;\n            this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x\n                * this.m_rB.x * iB;\n            this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n            this.m_mass.ex.z = this.m_mass.ez.x;\n            this.m_mass.ey.z = this.m_mass.ez.y;\n            this.m_mass.ez.z = iA + iB;\n            this.m_motorMass = iA + iB;\n            if (this.m_motorMass > 0.0) {\n                this.m_motorMass = 1.0 / this.m_motorMass;\n            }\n            if (this.m_enableMotor == false || fixedRotation) {\n                this.m_motorImpulse = 0.0;\n            }\n            if (this.m_enableLimit && fixedRotation == false) {\n                var jointAngle = aB - aA - this.m_referenceAngle; // float\n                if (math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {\n                    this.m_limitState = equalLimits$1;\n                }\n                else if (jointAngle <= this.m_lowerAngle) {\n                    if (this.m_limitState != atLowerLimit$1) {\n                        this.m_impulse.z = 0.0;\n                    }\n                    this.m_limitState = atLowerLimit$1;\n                }\n                else if (jointAngle >= this.m_upperAngle) {\n                    if (this.m_limitState != atUpperLimit$2) {\n                        this.m_impulse.z = 0.0;\n                    }\n                    this.m_limitState = atUpperLimit$2;\n                }\n                else {\n                    this.m_limitState = inactiveLimit$2;\n                    this.m_impulse.z = 0.0;\n                }\n            }\n            else {\n                this.m_limitState = inactiveLimit$2;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n            }\n            else {\n                this.m_impulse.setZero();\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        RevoluteJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var fixedRotation = (iA + iB === 0.0); // bool\n            // Solve motor constraint.\n            if (this.m_enableMotor && this.m_limitState != equalLimits$1\n                && fixedRotation == false) {\n                var Cdot = wB - wA - this.m_motorSpeed; // float\n                var impulse = -this.m_motorMass * Cdot; // float\n                var oldImpulse = this.m_motorImpulse; // float\n                var maxImpulse = step.dt * this.m_maxMotorTorque; // float\n                this.m_motorImpulse = math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve limit constraint.\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$2\n                && fixedRotation == false) {\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                var Cdot2 = wB - wA; // float\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n                var impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3\n                if (this.m_limitState == equalLimits$1) {\n                    this.m_impulse.add(impulse);\n                }\n                else if (this.m_limitState == atLowerLimit$1) {\n                    var newImpulse = this.m_impulse.z + impulse.z; // float\n                    if (newImpulse < 0.0) {\n                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n                        var reduced = this.m_mass.solve22(rhs); // Vec2\n                        impulse.x = reduced.x;\n                        impulse.y = reduced.y;\n                        impulse.z = -this.m_impulse.z;\n                        this.m_impulse.x += reduced.x;\n                        this.m_impulse.y += reduced.y;\n                        this.m_impulse.z = 0.0;\n                    }\n                    else {\n                        this.m_impulse.add(impulse);\n                    }\n                }\n                else if (this.m_limitState == atUpperLimit$2) {\n                    var newImpulse = this.m_impulse.z + impulse.z; // float\n                    if (newImpulse > 0.0) {\n                        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n                        var reduced = this.m_mass.solve22(rhs); // Vec2\n                        impulse.x = reduced.x;\n                        impulse.y = reduced.y;\n                        impulse.z = -this.m_impulse.z;\n                        this.m_impulse.x += reduced.x;\n                        this.m_impulse.y += reduced.y;\n                        this.m_impulse.z = 0.0;\n                    }\n                    else {\n                        this.m_impulse.add(impulse);\n                    }\n                }\n                var P = Vec2.neo(impulse.x, impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n            }\n            else {\n                // Solve point-to-point constraint\n                var Cdot = Vec2.zero();\n                Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                var impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2\n                this.m_impulse.x += impulse.x;\n                this.m_impulse.y += impulse.y;\n                vA.subMul(mA, impulse);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n                vB.addMul(mB, impulse);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        RevoluteJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var angularError = 0.0; // float\n            var positionError = 0.0; // float\n            var fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool\n            // Solve angular limit constraint.\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$2\n                && fixedRotation == false) {\n                var angle = aB - aA - this.m_referenceAngle; // float\n                var limitImpulse = 0.0; // float\n                if (this.m_limitState == equalLimits$1) {\n                    // Prevent large angular corrections\n                    var C = math.clamp(angle - this.m_lowerAngle, -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float\n                    limitImpulse = -this.m_motorMass * C;\n                    angularError = math.abs(C);\n                }\n                else if (this.m_limitState == atLowerLimit$1) {\n                    var C = angle - this.m_lowerAngle; // float\n                    angularError = -C;\n                    // Prevent large angular corrections and allow some slop.\n                    C = math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection, 0.0);\n                    limitImpulse = -this.m_motorMass * C;\n                }\n                else if (this.m_limitState == atUpperLimit$2) {\n                    var C = angle - this.m_upperAngle; // float\n                    angularError = C;\n                    // Prevent large angular corrections and allow some slop.\n                    C = math.clamp(C - Settings.angularSlop, 0.0, Settings.maxAngularCorrection);\n                    limitImpulse = -this.m_motorMass * C;\n                }\n                aA -= this.m_invIA * limitImpulse;\n                aB += this.m_invIB * limitImpulse;\n            }\n            // Solve point-to-point constraint.\n            {\n                qA.setAngle(aA);\n                qB.setAngle(aB);\n                var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n                var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n                var C = Vec2.zero();\n                C.addCombine(1, cB, 1, rB);\n                C.subCombine(1, cA, 1, rA);\n                positionError = C.length();\n                var mA = this.m_invMassA;\n                var mB = this.m_invMassB; // float\n                var iA = this.m_invIA;\n                var iB = this.m_invIB; // float\n                var K = new Mat22();\n                K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n                K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n                K.ey.x = K.ex.y;\n                K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n                var impulse = Vec2.neg(K.solve(C)); // Vec2\n                cA.subMul(mA, impulse);\n                aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n                cB.addMul(mB, impulse);\n                aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n            }\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return positionError <= Settings.linearSlop\n                && angularError <= Settings.angularSlop;\n        };\n        RevoluteJoint.TYPE = 'revolute-joint';\n        return RevoluteJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var inactiveLimit$1 = 0;\n    var atLowerLimit = 1;\n    var atUpperLimit$1 = 2;\n    var equalLimits = 3;\n    var DEFAULTS$7 = {\n        enableLimit: false,\n        lowerTranslation: 0.0,\n        upperTranslation: 0.0,\n        enableMotor: false,\n        maxMotorForce: 0.0,\n        motorSpeed: 0.0\n    };\n    /**\n     * A prismatic joint. This joint provides one degree of freedom: translation\n     * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n     * joint limit to restrict the range of motion and a joint motor to drive the\n     * motion or to model joint friction.\n     */\n    var PrismaticJoint = /** @class */ (function (_super) {\n        __extends(PrismaticJoint, _super);\n        function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PrismaticJoint)) {\n                return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n            }\n            def = options(def, DEFAULTS$7);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = PrismaticJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n            _this.m_localXAxisA.normalize();\n            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);\n            _this.m_referenceAngle = math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_impulse = new Vec3();\n            _this.m_motorMass = 0.0;\n            _this.m_motorImpulse = 0.0;\n            _this.m_lowerTranslation = def.lowerTranslation;\n            _this.m_upperTranslation = def.upperTranslation;\n            _this.m_maxMotorForce = def.maxMotorForce;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableLimit = def.enableLimit;\n            _this.m_enableMotor = def.enableMotor;\n            _this.m_limitState = inactiveLimit$1;\n            _this.m_axis = Vec2.zero();\n            _this.m_perp = Vec2.zero();\n            _this.m_K = new Mat33();\n            return _this;\n            // Linear constraint (point-to-line)\n            // d = p2 - p1 = x2 + r2 - x1 - r1\n            // C = dot(perp, d)\n            // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n            // cross(w1, r1))\n            // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n            // dot(cross(r2, perp), v2)\n            // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n            //\n            // Angular constraint\n            // C = a2 - a1 + a_initial\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            //\n            // K = J * invM * JT\n            //\n            // J = [-a -s1 a s2]\n            // [0 -1 0 1]\n            // a = perp\n            // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n            // s2 = cross(r2, a) = cross(p2 - x2, a)\n            // Motor/Limit linear constraint\n            // C = dot(ax1, d)\n            // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n            // dot(cross(r2, ax1), v2)\n            // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n            // Block Solver\n            // We develop a block solver that includes the joint limit. This makes the\n            // limit stiff (inelastic) even\n            // when the mass has poor distribution (leading to large torques about the\n            // joint anchor points).\n            //\n            // The Jacobian has 3 rows:\n            // J = [-uT -s1 uT s2] // linear\n            // [0 -1 0 1] // angular\n            // [-vT -a1 vT a2] // limit\n            //\n            // u = perp\n            // v = axis\n            // s1 = cross(d + r1, u), s2 = cross(r2, u)\n            // a1 = cross(d + r1, v), a2 = cross(r2, v)\n            // M * (v2 - v1) = JT * df\n            // J * v2 = bias\n            //\n            // v2 = v1 + invM * JT * df\n            // J * (v1 + invM * JT * df) = bias\n            // K * df = bias - J * v1 = -Cdot\n            // K = J * invM * JT\n            // Cdot = J * v1 - bias\n            //\n            // Now solve for f2.\n            // df = f2 - f1\n            // K * (f2 - f1) = -Cdot\n            // f2 = invK * (-Cdot) + f1\n            //\n            // Clamp accumulated limit impulse.\n            // lower: f2(3) = max(f2(3), 0)\n            // upper: f2(3) = min(f2(3), 0)\n            //\n            // Solve for correct f2(1:2)\n            // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n            // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n            // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n            // K(1:2,1:2) * f1(1:2)\n            // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n            // f1(1:2)\n            //\n            // Now compute impulse to be applied:\n            // df = f2 - f1\n        }\n        /** @internal */\n        PrismaticJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                lowerTranslation: this.m_lowerTranslation,\n                upperTranslation: this.m_upperTranslation,\n                maxMotorForce: this.m_maxMotorForce,\n                motorSpeed: this.m_motorSpeed,\n                enableLimit: this.m_enableLimit,\n                enableMotor: this.m_enableMotor,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                localAxisA: this.m_localXAxisA,\n                referenceAngle: this.m_referenceAngle,\n            };\n        };\n        /** @internal */\n        PrismaticJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.localAxisA = Vec2.clone(data.localAxisA);\n            var joint = new PrismaticJoint(data);\n            return joint;\n        };\n        /** @internal */\n        PrismaticJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n            if (def.localAxisA) {\n                this.m_localXAxisA.setVec2(def.localAxisA);\n                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        PrismaticJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        PrismaticJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * The local joint axis relative to bodyA.\n         */\n        PrismaticJoint.prototype.getLocalAxisA = function () {\n            return this.m_localXAxisA;\n        };\n        /**\n         * Get the reference angle.\n         */\n        PrismaticJoint.prototype.getReferenceAngle = function () {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Get the current joint translation, usually in meters.\n         */\n        PrismaticJoint.prototype.getJointTranslation = function () {\n            var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n            var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n            var d = Vec2.sub(pB, pA);\n            var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n            var translation = Vec2.dot(d, axis);\n            return translation;\n        };\n        /**\n         * Get the current joint translation speed, usually in meters per second.\n         */\n        PrismaticJoint.prototype.getJointSpeed = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            var rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2\n            var rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2\n            var p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2\n            var p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2\n            var d = Vec2.sub(p2, p1); // Vec2\n            var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2\n            var vA = bA.m_linearVelocity; // Vec2\n            var vB = bB.m_linearVelocity; // Vec2\n            var wA = bA.m_angularVelocity; // float\n            var wB = bB.m_angularVelocity; // float\n            var speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis))\n                + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA))); // float\n            return speed;\n        };\n        /**\n         * Is the joint limit enabled?\n         */\n        PrismaticJoint.prototype.isLimitEnabled = function () {\n            return this.m_enableLimit;\n        };\n        /**\n         * Enable/disable the joint limit.\n         */\n        PrismaticJoint.prototype.enableLimit = function (flag) {\n            if (flag != this.m_enableLimit) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_enableLimit = flag;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Get the lower joint limit, usually in meters.\n         */\n        PrismaticJoint.prototype.getLowerLimit = function () {\n            return this.m_lowerTranslation;\n        };\n        /**\n         * Get the upper joint limit, usually in meters.\n         */\n        PrismaticJoint.prototype.getUpperLimit = function () {\n            return this.m_upperTranslation;\n        };\n        /**\n         * Set the joint limits, usually in meters.\n         */\n        PrismaticJoint.prototype.setLimits = function (lower, upper) {\n            if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_lowerTranslation = lower;\n                this.m_upperTranslation = upper;\n                this.m_impulse.z = 0.0;\n            }\n        };\n        /**\n         * Is the joint motor enabled?\n         */\n        PrismaticJoint.prototype.isMotorEnabled = function () {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */\n        PrismaticJoint.prototype.enableMotor = function (flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Set the motor speed, usually in meters per second.\n         */\n        PrismaticJoint.prototype.setMotorSpeed = function (speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Set the maximum motor force, usually in N.\n         */\n        PrismaticJoint.prototype.setMaxMotorForce = function (force) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorForce = force;\n        };\n        PrismaticJoint.prototype.getMaxMotorForce = function () {\n            return this.m_maxMotorForce;\n        };\n        /**\n         * Get the motor speed, usually in meters per second.\n         */\n        PrismaticJoint.prototype.getMotorSpeed = function () {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Get the current motor force given the inverse time step, usually in N.\n         */\n        PrismaticJoint.prototype.getMotorForce = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        PrismaticJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        PrismaticJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        PrismaticJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        PrismaticJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_impulse.y;\n        };\n        PrismaticJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective masses.\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Compute motor Jacobian and effective mass.\n            {\n                this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n                this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n                this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n                this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2\n                    * this.m_a2;\n                if (this.m_motorMass > 0.0) {\n                    this.m_motorMass = 1.0 / this.m_motorMass;\n                }\n            }\n            // Prismatic constraint.\n            {\n                this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n                this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n                this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n                Vec2.crossVec2Vec2(rA, this.m_perp);\n                var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n                var k12 = iA * this.m_s1 + iB * this.m_s2;\n                var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n                var k22 = iA + iB;\n                if (k22 == 0.0) {\n                    // For bodies with fixed rotation.\n                    k22 = 1.0;\n                }\n                var k23 = iA * this.m_a1 + iB * this.m_a2;\n                var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n                this.m_K.ex.set(k11, k12, k13);\n                this.m_K.ey.set(k12, k22, k23);\n                this.m_K.ez.set(k13, k23, k33);\n            }\n            // Compute motor and limit terms.\n            if (this.m_enableLimit) {\n                var jointTranslation = Vec2.dot(this.m_axis, d); // float\n                if (math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {\n                    this.m_limitState = equalLimits;\n                }\n                else if (jointTranslation <= this.m_lowerTranslation) {\n                    if (this.m_limitState != atLowerLimit) {\n                        this.m_limitState = atLowerLimit;\n                        this.m_impulse.z = 0.0;\n                    }\n                }\n                else if (jointTranslation >= this.m_upperTranslation) {\n                    if (this.m_limitState != atUpperLimit$1) {\n                        this.m_limitState = atUpperLimit$1;\n                        this.m_impulse.z = 0.0;\n                    }\n                }\n                else {\n                    this.m_limitState = inactiveLimit$1;\n                    this.m_impulse.z = 0.0;\n                }\n            }\n            else {\n                this.m_limitState = inactiveLimit$1;\n                this.m_impulse.z = 0.0;\n            }\n            if (this.m_enableMotor == false) {\n                this.m_motorImpulse = 0.0;\n            }\n            if (step.warmStarting) {\n                // Account for variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse\n                    + this.m_impulse.z, this.m_axis);\n                var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y\n                    + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n                var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y\n                    + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            else {\n                this.m_impulse.setZero();\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        PrismaticJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Solve linear motor constraint.\n            if (this.m_enableMotor && this.m_limitState != equalLimits) {\n                var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB\n                    - this.m_a1 * wA;\n                var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n                var oldImpulse = this.m_motorImpulse;\n                var maxImpulse = step.dt * this.m_maxMotorForce;\n                this.m_motorImpulse = math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                var P = Vec2.mulNumVec2(impulse, this.m_axis);\n                var LA = impulse * this.m_a1;\n                var LB = impulse * this.m_a2;\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            var Cdot1 = Vec2.zero();\n            Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n            Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n            Cdot1.y = wB - wA;\n            if (this.m_enableLimit && this.m_limitState != inactiveLimit$1) {\n                // Solve prismatic and limit constraint in block form.\n                var Cdot2 = 0;\n                Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n                Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n                var f1 = Vec3.clone(this.m_impulse);\n                var df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3\n                this.m_impulse.add(df);\n                if (this.m_limitState == atLowerLimit) {\n                    this.m_impulse.z = math.max(this.m_impulse.z, 0.0);\n                }\n                else if (this.m_limitState == atUpperLimit$1) {\n                    this.m_impulse.z = math.min(this.m_impulse.z, 0.0);\n                }\n                // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n                // f1(1:2)\n                var b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2\n                var f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2\n                this.m_impulse.x = f2r.x;\n                this.m_impulse.y = f2r.y;\n                df = Vec3.sub(this.m_impulse, f1);\n                var P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2\n                var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float\n                var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            else {\n                // Limit is inactive, just solve the prismatic constraint in block form.\n                var df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2\n                this.m_impulse.x += df.x;\n                this.m_impulse.y += df.y;\n                var P = Vec2.mulNumVec2(df.x, this.m_perp); // Vec2\n                var LA = df.x * this.m_s1 + df.y; // float\n                var LB = df.x * this.m_s2 + df.y; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        PrismaticJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            // Compute fresh Jacobians\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n            var d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2\n            var axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2\n            var a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis); // float\n            var a2 = Vec2.crossVec2Vec2(rB, axis); // float\n            var perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2\n            var s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp); // float\n            var s2 = Vec2.crossVec2Vec2(rB, perp); // float\n            var impulse = new Vec3();\n            var C1 = Vec2.zero(); // Vec2\n            C1.x = Vec2.dot(perp, d);\n            C1.y = aB - aA - this.m_referenceAngle;\n            var linearError = math.abs(C1.x); // float\n            var angularError = math.abs(C1.y); // float\n            var linearSlop = Settings.linearSlop;\n            var maxLinearCorrection = Settings.maxLinearCorrection;\n            var active = false; // bool\n            var C2 = 0.0; // float\n            if (this.m_enableLimit) {\n                var translation = Vec2.dot(axis, d); // float\n                if (math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n                    // Prevent large angular corrections\n                    C2 = math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n                    linearError = math.max(linearError, math.abs(translation));\n                    active = true;\n                }\n                else if (translation <= this.m_lowerTranslation) {\n                    // Prevent large linear corrections and allow some slop.\n                    C2 = math.clamp(translation - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0.0);\n                    linearError = math\n                        .max(linearError, this.m_lowerTranslation - translation);\n                    active = true;\n                }\n                else if (translation >= this.m_upperTranslation) {\n                    // Prevent large linear corrections and allow some slop.\n                    C2 = math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0, maxLinearCorrection);\n                    linearError = math\n                        .max(linearError, translation - this.m_upperTranslation);\n                    active = true;\n                }\n            }\n            if (active) {\n                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n                var k12 = iA * s1 + iB * s2; // float\n                var k13 = iA * s1 * a1 + iB * s2 * a2; // float\n                var k22 = iA + iB; // float\n                if (k22 == 0.0) {\n                    // For fixed rotation\n                    k22 = 1.0;\n                }\n                var k23 = iA * a1 + iB * a2; // float\n                var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float\n                var K = new Mat33();\n                K.ex.set(k11, k12, k13);\n                K.ey.set(k12, k22, k23);\n                K.ez.set(k13, k23, k33);\n                var C = new Vec3();\n                C.x = C1.x;\n                C.y = C1.y;\n                C.z = C2;\n                impulse = K.solve33(Vec3.neg(C));\n            }\n            else {\n                var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n                var k12 = iA * s1 + iB * s2; // float\n                var k22 = iA + iB; // float\n                if (k22 == 0.0) {\n                    k22 = 1.0;\n                }\n                var K = new Mat22();\n                K.ex.setNum(k11, k12);\n                K.ey.setNum(k12, k22);\n                var impulse1 = K.solve(Vec2.neg(C1)); // Vec2\n                impulse.x = impulse1.x;\n                impulse.y = impulse1.y;\n                impulse.z = 0.0;\n            }\n            var P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2\n            var LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float\n            var LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float\n            cA.subMul(mA, P);\n            aA -= iA * LA;\n            cB.addMul(mB, P);\n            aB += iB * LB;\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return linearError <= Settings.linearSlop\n                && angularError <= Settings.angularSlop;\n        };\n        PrismaticJoint.TYPE = 'prismatic-joint';\n        return PrismaticJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$6 = {\n        ratio: 1.0\n    };\n    /**\n     * A gear joint is used to connect two joints together. Either joint can be a\n     * revolute or prismatic joint. You specify a gear ratio to bind the motions\n     * together: coordinate1 + ratio * coordinate2 = constant\n     *\n     * The ratio can be negative or positive. If one joint is a revolute joint and\n     * the other joint is a prismatic joint, then the ratio will have units of\n     * length or units of 1/length. Warning: You have to manually destroy the gear\n     * joint if joint1 or joint2 is destroyed.\n     *\n     * This definition requires two existing revolute or prismatic joints (any\n     * combination will work).\n     */\n    var GearJoint = /** @class */ (function (_super) {\n        __extends(GearJoint, _super);\n        function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof GearJoint)) {\n                return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n            }\n            def = options(def, DEFAULTS$6);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = GearJoint.TYPE;\n            _this.m_joint1 = joint1 ? joint1 : def.joint1;\n            _this.m_joint2 = joint2 ? joint2 : def.joint2;\n            _this.m_ratio = math.isFinite(ratio) ? ratio : def.ratio;\n            _this.m_type1 = _this.m_joint1.getType();\n            _this.m_type2 = _this.m_joint2.getType();\n            // joint1 connects body A to body C\n            // joint2 connects body B to body D\n            var coordinateA;\n            var coordinateB;\n            // TODO_ERIN there might be some problem with the joint edges in Joint.\n            _this.m_bodyC = _this.m_joint1.getBodyA();\n            _this.m_bodyA = _this.m_joint1.getBodyB();\n            // Get geometry of joint1\n            var xfA = _this.m_bodyA.m_xf;\n            var aA = _this.m_bodyA.m_sweep.a;\n            var xfC = _this.m_bodyC.m_xf;\n            var aC = _this.m_bodyC.m_sweep.a;\n            if (_this.m_type1 === RevoluteJoint.TYPE) {\n                var revolute = _this.m_joint1;\n                _this.m_localAnchorC = revolute.m_localAnchorA;\n                _this.m_localAnchorA = revolute.m_localAnchorB;\n                _this.m_referenceAngleA = revolute.m_referenceAngle;\n                _this.m_localAxisC = Vec2.zero();\n                coordinateA = aA - aC - _this.m_referenceAngleA;\n            }\n            else {\n                var prismatic = _this.m_joint1;\n                _this.m_localAnchorC = prismatic.m_localAnchorA;\n                _this.m_localAnchorA = prismatic.m_localAnchorB;\n                _this.m_referenceAngleA = prismatic.m_referenceAngle;\n                _this.m_localAxisC = prismatic.m_localXAxisA;\n                var pC = _this.m_localAnchorC;\n                var pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, _this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n                coordinateA = Vec2.dot(pA, _this.m_localAxisC) - Vec2.dot(pC, _this.m_localAxisC);\n            }\n            _this.m_bodyD = _this.m_joint2.getBodyA();\n            _this.m_bodyB = _this.m_joint2.getBodyB();\n            // Get geometry of joint2\n            var xfB = _this.m_bodyB.m_xf;\n            var aB = _this.m_bodyB.m_sweep.a;\n            var xfD = _this.m_bodyD.m_xf;\n            var aD = _this.m_bodyD.m_sweep.a;\n            if (_this.m_type2 === RevoluteJoint.TYPE) {\n                var revolute = _this.m_joint2;\n                _this.m_localAnchorD = revolute.m_localAnchorA;\n                _this.m_localAnchorB = revolute.m_localAnchorB;\n                _this.m_referenceAngleB = revolute.m_referenceAngle;\n                _this.m_localAxisD = Vec2.zero();\n                coordinateB = aB - aD - _this.m_referenceAngleB;\n            }\n            else {\n                var prismatic = _this.m_joint2;\n                _this.m_localAnchorD = prismatic.m_localAnchorA;\n                _this.m_localAnchorB = prismatic.m_localAnchorB;\n                _this.m_referenceAngleB = prismatic.m_referenceAngle;\n                _this.m_localAxisD = prismatic.m_localXAxisA;\n                var pD = _this.m_localAnchorD;\n                var pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, _this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n                coordinateB = Vec2.dot(pB, _this.m_localAxisD) - Vec2.dot(pD, _this.m_localAxisD);\n            }\n            _this.m_constant = coordinateA + _this.m_ratio * coordinateB;\n            _this.m_impulse = 0.0;\n            return _this;\n            // Gear Joint:\n            // C0 = (coordinate1 + ratio * coordinate2)_initial\n            // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n            // J = [J1 ratio * J2]\n            // K = J * invM * JT\n            // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n            //\n            // Revolute:\n            // coordinate = rotation\n            // Cdot = angularVelocity\n            // J = [0 0 1]\n            // K = J * invM * JT = invI\n            //\n            // Prismatic:\n            // coordinate = dot(p - pg, ug)\n            // Cdot = dot(v + cross(w, r), ug)\n            // J = [ug cross(r, ug)]\n            // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n        }\n        /** @internal */\n        GearJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                joint1: this.m_joint1,\n                joint2: this.m_joint2,\n                ratio: this.m_ratio,\n                // _constant: this.m_constant,\n            };\n        };\n        /** @internal */\n        GearJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.joint1 = restore(Joint, data.joint1, world);\n            data.joint2 = restore(Joint, data.joint2, world);\n            var joint = new GearJoint(data);\n            // if (data._constant) joint.m_constant = data._constant;\n            return joint;\n        };\n        /**\n         * Get the first joint.\n         */\n        GearJoint.prototype.getJoint1 = function () {\n            return this.m_joint1;\n        };\n        /**\n         * Get the second joint.\n         */\n        GearJoint.prototype.getJoint2 = function () {\n            return this.m_joint2;\n        };\n        /**\n         * Set the gear ratio.\n         */\n        GearJoint.prototype.setRatio = function (ratio) {\n            this.m_ratio = ratio;\n        };\n        /**\n         * Get the gear ratio.\n         */\n        GearJoint.prototype.getRatio = function () {\n            return this.m_ratio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        GearJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        GearJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        GearJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        GearJoint.prototype.getReactionTorque = function (inv_dt) {\n            var L = this.m_impulse * this.m_JwA; // float\n            return inv_dt * L;\n        };\n        GearJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n            this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n            this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n            this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n            this.m_mA = this.m_bodyA.m_invMass;\n            this.m_mB = this.m_bodyB.m_invMass;\n            this.m_mC = this.m_bodyC.m_invMass;\n            this.m_mD = this.m_bodyD.m_invMass;\n            this.m_iA = this.m_bodyA.m_invI;\n            this.m_iB = this.m_bodyB.m_invI;\n            this.m_iC = this.m_bodyC.m_invI;\n            this.m_iD = this.m_bodyD.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var aC = this.m_bodyC.c_position.a;\n            var vC = this.m_bodyC.c_velocity.v;\n            var wC = this.m_bodyC.c_velocity.w;\n            var aD = this.m_bodyD.c_position.a;\n            var vD = this.m_bodyD.c_velocity.v;\n            var wD = this.m_bodyD.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var qC = Rot.neo(aC);\n            var qD = Rot.neo(aD);\n            this.m_mass = 0.0;\n            if (this.m_type1 == RevoluteJoint.TYPE) {\n                this.m_JvAC = Vec2.zero();\n                this.m_JwA = 1.0;\n                this.m_JwC = 1.0;\n                this.m_mass += this.m_iA + this.m_iC;\n            }\n            else {\n                var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n                this.m_JvAC = u;\n                this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n                this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n                this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n            }\n            if (this.m_type2 == RevoluteJoint.TYPE) {\n                this.m_JvBD = Vec2.zero();\n                this.m_JwB = this.m_ratio;\n                this.m_JwD = this.m_ratio;\n                this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n            }\n            else {\n                var u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2\n                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2\n                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2\n                this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n                this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n                this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n                this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n            }\n            // Compute effective mass.\n            this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n            if (step.warmStarting) {\n                vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n                wA += this.m_iA * this.m_impulse * this.m_JwA;\n                vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n                wB += this.m_iB * this.m_impulse * this.m_JwB;\n                vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n                wC -= this.m_iC * this.m_impulse * this.m_JwC;\n                vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n                wD -= this.m_iD * this.m_impulse * this.m_JwD;\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n            this.m_bodyC.c_velocity.v.setVec2(vC);\n            this.m_bodyC.c_velocity.w = wC;\n            this.m_bodyD.c_velocity.v.setVec2(vD);\n            this.m_bodyD.c_velocity.w = wD;\n        };\n        GearJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var vC = this.m_bodyC.c_velocity.v;\n            var wC = this.m_bodyC.c_velocity.w;\n            var vD = this.m_bodyD.c_velocity.v;\n            var wD = this.m_bodyD.c_velocity.w;\n            var Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC)\n                + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float\n            Cdot += (this.m_JwA * wA - this.m_JwC * wC)\n                + (this.m_JwB * wB - this.m_JwD * wD);\n            var impulse = -this.m_mass * Cdot; // float\n            this.m_impulse += impulse;\n            vA.addMul(this.m_mA * impulse, this.m_JvAC);\n            wA += this.m_iA * impulse * this.m_JwA;\n            vB.addMul(this.m_mB * impulse, this.m_JvBD);\n            wB += this.m_iB * impulse * this.m_JwB;\n            vC.subMul(this.m_mC * impulse, this.m_JvAC);\n            wC -= this.m_iC * impulse * this.m_JwC;\n            vD.subMul(this.m_mD * impulse, this.m_JvBD);\n            wD -= this.m_iD * impulse * this.m_JwD;\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n            this.m_bodyC.c_velocity.v.setVec2(vC);\n            this.m_bodyC.c_velocity.w = wC;\n            this.m_bodyD.c_velocity.v.setVec2(vD);\n            this.m_bodyD.c_velocity.w = wD;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        GearJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var cC = this.m_bodyC.c_position.c;\n            var aC = this.m_bodyC.c_position.a;\n            var cD = this.m_bodyD.c_position.c;\n            var aD = this.m_bodyD.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var qC = Rot.neo(aC);\n            var qD = Rot.neo(aD);\n            var linearError = 0.0;\n            var coordinateA;\n            var coordinateB;\n            var JvAC;\n            var JvBD;\n            var JwA;\n            var JwB;\n            var JwC;\n            var JwD;\n            var mass = 0.0;\n            if (this.m_type1 == RevoluteJoint.TYPE) {\n                JvAC = Vec2.zero();\n                JwA = 1.0;\n                JwC = 1.0;\n                mass += this.m_iA + this.m_iC;\n                coordinateA = aA - aC - this.m_referenceAngleA;\n            }\n            else {\n                var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n                var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n                var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n                JvAC = u;\n                JwC = Vec2.crossVec2Vec2(rC, u);\n                JwA = Vec2.crossVec2Vec2(rA, u);\n                mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n                var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2\n                var pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2\n                coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n            }\n            if (this.m_type2 == RevoluteJoint.TYPE) {\n                JvBD = Vec2.zero();\n                JwB = this.m_ratio;\n                JwD = this.m_ratio;\n                mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n                coordinateB = aB - aD - this.m_referenceAngleB;\n            }\n            else {\n                var u = Rot.mulVec2(qD, this.m_localAxisD);\n                var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n                var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n                JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n                JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n                JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n                mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD\n                    * JwD * JwD + this.m_iB * JwB * JwB;\n                var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2\n                var pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2\n                coordinateB = Vec2.dot(pB, this.m_localAxisD)\n                    - Vec2.dot(pD, this.m_localAxisD);\n            }\n            var C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float\n            var impulse = 0.0; // float\n            if (mass > 0.0) {\n                impulse = -C / mass;\n            }\n            cA.addMul(this.m_mA * impulse, JvAC);\n            aA += this.m_iA * impulse * JwA;\n            cB.addMul(this.m_mB * impulse, JvBD);\n            aB += this.m_iB * impulse * JwB;\n            cC.subMul(this.m_mC * impulse, JvAC);\n            aC -= this.m_iC * impulse * JwC;\n            cD.subMul(this.m_mD * impulse, JvBD);\n            aD -= this.m_iD * impulse * JwD;\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            this.m_bodyC.c_position.c.setVec2(cC);\n            this.m_bodyC.c_position.a = aC;\n            this.m_bodyD.c_position.c.setVec2(cD);\n            this.m_bodyD.c_position.a = aD;\n            // TODO_ERIN not implemented\n            return linearError < Settings.linearSlop;\n        };\n        GearJoint.TYPE = 'gear-joint';\n        return GearJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$5 = {\n        maxForce: 1.0,\n        maxTorque: 1.0,\n        correctionFactor: 0.3\n    };\n    /**\n     * A motor joint is used to control the relative motion between two bodies. A\n     * typical usage is to control the movement of a dynamic body with respect to\n     * the ground.\n     */\n    var MotorJoint = /** @class */ (function (_super) {\n        __extends(MotorJoint, _super);\n        function MotorJoint(def, bodyA, bodyB) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof MotorJoint)) {\n                return new MotorJoint(def, bodyA, bodyB);\n            }\n            def = options(def, DEFAULTS$5);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = MotorJoint.TYPE;\n            _this.m_linearOffset = math.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());\n            _this.m_angularOffset = math.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_linearImpulse = Vec2.zero();\n            _this.m_angularImpulse = 0.0;\n            _this.m_maxForce = def.maxForce;\n            _this.m_maxTorque = def.maxTorque;\n            _this.m_correctionFactor = def.correctionFactor;\n            return _this;\n            // Point-to-point constraint\n            // Cdot = v2 - v1\n            // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Angle constraint\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        MotorJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                maxForce: this.m_maxForce,\n                maxTorque: this.m_maxTorque,\n                correctionFactor: this.m_correctionFactor,\n                linearOffset: this.m_linearOffset,\n                angularOffset: this.m_angularOffset,\n            };\n        };\n        /** @internal */\n        MotorJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new MotorJoint(data);\n            return joint;\n        };\n        /** @internal */\n        MotorJoint.prototype._setAnchors = function (def) {\n        };\n        /**\n         * Set the maximum friction force in N.\n         */\n        MotorJoint.prototype.setMaxForce = function (force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum friction force in N.\n         */\n        MotorJoint.prototype.getMaxForce = function () {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the maximum friction torque in N*m.\n         */\n        MotorJoint.prototype.setMaxTorque = function (torque) {\n            this.m_maxTorque = torque;\n        };\n        /**\n         * Get the maximum friction torque in N*m.\n         */\n        MotorJoint.prototype.getMaxTorque = function () {\n            return this.m_maxTorque;\n        };\n        /**\n         * Set the position correction factor in the range [0,1].\n         */\n        MotorJoint.prototype.setCorrectionFactor = function (factor) {\n            this.m_correctionFactor = factor;\n        };\n        /**\n         * Get the position correction factor in the range [0,1].\n         */\n        MotorJoint.prototype.getCorrectionFactor = function () {\n            return this.m_correctionFactor;\n        };\n        /**\n         * Set/get the target linear offset, in frame A, in meters.\n         */\n        MotorJoint.prototype.setLinearOffset = function (linearOffset) {\n            if (linearOffset.x != this.m_linearOffset.x\n                || linearOffset.y != this.m_linearOffset.y) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_linearOffset = linearOffset;\n            }\n        };\n        MotorJoint.prototype.getLinearOffset = function () {\n            return this.m_linearOffset;\n        };\n        /**\n         * Set/get the target angular offset, in radians.\n         */\n        MotorJoint.prototype.setAngularOffset = function (angularOffset) {\n            if (angularOffset != this.m_angularOffset) {\n                this.m_bodyA.setAwake(true);\n                this.m_bodyB.setAwake(true);\n                this.m_angularOffset = angularOffset;\n            }\n        };\n        MotorJoint.prototype.getAngularOffset = function () {\n            return this.m_angularOffset;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        MotorJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getPosition();\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        MotorJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getPosition();\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        MotorJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        MotorJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_angularImpulse;\n        };\n        MotorJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective mass matrix.\n            this.m_rA = Rot.mulVec2(qA, Vec2.neg(this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat22();\n            K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n            K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n            this.m_linearMass = K.getInverse();\n            this.m_angularMass = iA + iB;\n            if (this.m_angularMass > 0.0) {\n                this.m_angularMass = 1.0 / this.m_angularMass;\n            }\n            this.m_linearError = Vec2.zero();\n            this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n            this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n            this.m_linearError.sub(Rot.mulVec2(qA, this.m_linearOffset));\n            this.m_angularError = aB - aA - this.m_angularOffset;\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_linearImpulse.mul(step.dtRatio);\n                this.m_angularImpulse *= step.dtRatio;\n                var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n            }\n            else {\n                this.m_linearImpulse.setZero();\n                this.m_angularImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        MotorJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var h = step.dt;\n            var inv_h = step.inv_dt;\n            // Solve angular friction\n            {\n                var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n                var impulse = -this.m_angularMass * Cdot;\n                var oldImpulse = this.m_angularImpulse;\n                var maxImpulse = h * this.m_maxTorque;\n                this.m_angularImpulse = math.clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_angularImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve linear friction\n            {\n                var Cdot = Vec2.zero();\n                Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n                Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n                var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n                var oldImpulse = Vec2.clone(this.m_linearImpulse);\n                this.m_linearImpulse.add(impulse);\n                var maxImpulse = h * this.m_maxForce;\n                this.m_linearImpulse.clamp(maxImpulse);\n                impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n                vA.subMul(mA, impulse);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n                vB.addMul(mB, impulse);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        MotorJoint.prototype.solvePositionConstraints = function (step) {\n            return true;\n        };\n        MotorJoint.TYPE = 'motor-joint';\n        return MotorJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$4 = {\n        maxForce: 0.0,\n        frequencyHz: 5.0,\n        dampingRatio: 0.7\n    };\n    /**\n     * A mouse joint is used to make a point on a body track a specified world\n     * point. This a soft constraint with a maximum force. This allows the\n     * constraint to stretch and without applying huge forces.\n     *\n     * NOTE: this joint is not documented in the manual because it was developed to\n     * be used in the testbed. If you want to learn how to use the mouse joint, look\n     * at the testbed.\n     */\n    var MouseJoint = /** @class */ (function (_super) {\n        __extends(MouseJoint, _super);\n        function MouseJoint(def, bodyA, bodyB, target) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof MouseJoint)) {\n                return new MouseJoint(def, bodyA, bodyB, target);\n            }\n            def = options(def, DEFAULTS$4);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = MouseJoint.TYPE;\n            _this.m_targetA = target ? Vec2.clone(target) : def.target || Vec2.zero();\n            _this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), _this.m_targetA);\n            _this.m_maxForce = def.maxForce;\n            _this.m_impulse = Vec2.zero();\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_beta = 0.0;\n            _this.m_gamma = 0.0;\n            // Solver temp\n            _this.m_rB = Vec2.zero();\n            _this.m_localCenterB = Vec2.zero();\n            _this.m_invMassB = 0.0;\n            _this.m_invIB = 0.0;\n            _this.m_mass = new Mat22();\n            _this.m_C = Vec2.zero();\n            return _this;\n            // p = attached point, m = mouse point\n            // C = p - m\n            // Cdot = v\n            // = v + cross(w, r)\n            // J = [I r_skew]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n        }\n        /** @internal */\n        MouseJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                target: this.m_targetA,\n                maxForce: this.m_maxForce,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                _localAnchorB: this.m_localAnchorB,\n            };\n        };\n        /** @internal */\n        MouseJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            data.target = Vec2.clone(data.target);\n            var joint = new MouseJoint(data);\n            if (data._localAnchorB) {\n                joint.m_localAnchorB = data._localAnchorB;\n            }\n            return joint;\n        };\n        /**\n         * Use this to update the target point.\n         */\n        MouseJoint.prototype.setTarget = function (target) {\n            if (this.m_bodyB.isAwake() == false) {\n                this.m_bodyB.setAwake(true);\n            }\n            this.m_targetA = Vec2.clone(target);\n        };\n        MouseJoint.prototype.getTarget = function () {\n            return this.m_targetA;\n        };\n        /**\n         * Set the maximum force in Newtons.\n         */\n        MouseJoint.prototype.setMaxForce = function (force) {\n            this.m_maxForce = force;\n        };\n        /**\n         * Get the maximum force in Newtons.\n         */\n        MouseJoint.prototype.getMaxForce = function () {\n            return this.m_maxForce;\n        };\n        /**\n         * Set the frequency in Hertz.\n         */\n        MouseJoint.prototype.setFrequency = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        /**\n         * Get the frequency in Hertz.\n         */\n        MouseJoint.prototype.getFrequency = function () {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set the damping ratio (dimensionless).\n         */\n        MouseJoint.prototype.setDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        /**\n         * Get the damping ratio (dimensionless).\n         */\n        MouseJoint.prototype.getDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        MouseJoint.prototype.getAnchorA = function () {\n            return Vec2.clone(this.m_targetA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        MouseJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        MouseJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        MouseJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * 0.0;\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         */\n        MouseJoint.prototype.shiftOrigin = function (newOrigin) {\n            this.m_targetA.sub(newOrigin);\n        };\n        MouseJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var position = this.m_bodyB.c_position;\n            var velocity = this.m_bodyB.c_velocity;\n            var cB = position.c;\n            var aB = position.a;\n            var vB = velocity.v;\n            var wB = velocity.w;\n            var qB = Rot.neo(aB);\n            var mass = this.m_bodyB.getMass();\n            // Frequency\n            var omega = 2.0 * math.PI * this.m_frequencyHz;\n            // Damping coefficient\n            var d = 2.0 * mass * this.m_dampingRatio * omega;\n            // Spring stiffness\n            var k = mass * (omega * omega);\n            // magic formulas\n            // gamma has units of inverse mass.\n            // beta has units of inverse time.\n            var h = step.dt;\n            this.m_gamma = h * (d + h * k);\n            if (this.m_gamma != 0.0) {\n                this.m_gamma = 1.0 / this.m_gamma;\n            }\n            this.m_beta = h * k * this.m_gamma;\n            // Compute the effective mass matrix.\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n            // invI2 * skew(r2)]\n            // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n            // -r1.x*r1.y]\n            // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n            var K = new Mat22();\n            K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y\n                + this.m_gamma;\n            K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n            K.ey.x = K.ex.y;\n            K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x\n                + this.m_gamma;\n            this.m_mass = K.getInverse();\n            this.m_C.setVec2(cB);\n            this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n            this.m_C.mul(this.m_beta);\n            // Cheat with some damping\n            wB *= 0.98;\n            if (step.warmStarting) {\n                this.m_impulse.mul(step.dtRatio);\n                vB.addMul(this.m_invMassB, this.m_impulse);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n            }\n            else {\n                this.m_impulse.setZero();\n            }\n            velocity.v.setVec2(vB);\n            velocity.w = wB;\n        };\n        MouseJoint.prototype.solveVelocityConstraints = function (step) {\n            var velocity = this.m_bodyB.c_velocity;\n            var vB = Vec2.clone(velocity.v);\n            var wB = velocity.w;\n            // Cdot = v + cross(w, r)\n            var Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n            Cdot.add(vB);\n            Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n            Cdot.neg();\n            var impulse = Mat22.mulVec2(this.m_mass, Cdot);\n            var oldImpulse = Vec2.clone(this.m_impulse);\n            this.m_impulse.add(impulse);\n            var maxImpulse = step.dt * this.m_maxForce;\n            this.m_impulse.clamp(maxImpulse);\n            impulse = Vec2.sub(this.m_impulse, oldImpulse);\n            vB.addMul(this.m_invMassB, impulse);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n            velocity.v.setVec2(vB);\n            velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        MouseJoint.prototype.solvePositionConstraints = function (step) {\n            return true;\n        };\n        MouseJoint.TYPE = 'mouse-joint';\n        return MouseJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$3 = {\n        collideConnected: true\n    };\n    /**\n     * The pulley joint is connected to two bodies and two fixed ground points. The\n     * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n     *\n     * Yes, the force transmitted is scaled by the ratio.\n     *\n     * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n     * better when combined with prismatic joints. You should also cover the the\n     * anchor points with static shapes to prevent one side from going to zero\n     * length.\n     */\n    var PulleyJoint = /** @class */ (function (_super) {\n        __extends(PulleyJoint, _super);\n        function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof PulleyJoint)) {\n                return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n            }\n            def = options(def, DEFAULTS$3);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = PulleyJoint.TYPE;\n            _this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0);\n            _this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);\n            _this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n            _this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n            _this.m_lengthA = math.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n            _this.m_lengthB = math.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n            _this.m_ratio = math.isFinite(ratio) ? ratio : def.ratio;\n            _this.m_constant = _this.m_lengthA + _this.m_ratio * _this.m_lengthB;\n            _this.m_impulse = 0.0;\n            return _this;\n            // Pulley:\n            // length1 = norm(p1 - s1)\n            // length2 = norm(p2 - s2)\n            // C0 = (length1 + ratio * length2)_initial\n            // C = C0 - (length1 + ratio * length2)\n            // u1 = (p1 - s1) / norm(p1 - s1)\n            // u2 = (p2 - s2) / norm(p2 - s2)\n            // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n            // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n            // K = J * invM * JT\n            // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n            // cross(r2, u2)^2)\n        }\n        PulleyJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                groundAnchorA: this.m_groundAnchorA,\n                groundAnchorB: this.m_groundAnchorB,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                lengthA: this.m_lengthA,\n                lengthB: this.m_lengthB,\n                ratio: this.m_ratio,\n            };\n        };\n        /** @internal */\n        PulleyJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new PulleyJoint(data);\n            return joint;\n        };\n        /**\n         * Get the first ground anchor.\n         */\n        PulleyJoint.prototype.getGroundAnchorA = function () {\n            return this.m_groundAnchorA;\n        };\n        /**\n         * Get the second ground anchor.\n         */\n        PulleyJoint.prototype.getGroundAnchorB = function () {\n            return this.m_groundAnchorB;\n        };\n        /**\n         * Get the current length of the segment attached to bodyA.\n         */\n        PulleyJoint.prototype.getLengthA = function () {\n            return this.m_lengthA;\n        };\n        /**\n         * Get the current length of the segment attached to bodyB.\n         */\n        PulleyJoint.prototype.getLengthB = function () {\n            return this.m_lengthB;\n        };\n        /**\n         * Get the pulley ratio.\n         */\n        PulleyJoint.prototype.getRatio = function () {\n            return this.m_ratio;\n        };\n        /**\n         * Get the current length of the segment attached to bodyA.\n         */\n        PulleyJoint.prototype.getCurrentLengthA = function () {\n            var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n            var s = this.m_groundAnchorA;\n            return Vec2.distance(p, s);\n        };\n        /**\n         * Get the current length of the segment attached to bodyB.\n         */\n        PulleyJoint.prototype.getCurrentLengthB = function () {\n            var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n            var s = this.m_groundAnchorB;\n            return Vec2.distance(p, s);\n        };\n        /**\n         * Shift the origin for any points stored in world coordinates.\n         *\n         * @param newOrigin\n         */\n        PulleyJoint.prototype.shiftOrigin = function (newOrigin) {\n            this.m_groundAnchorA.sub(newOrigin);\n            this.m_groundAnchorB.sub(newOrigin);\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        PulleyJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        PulleyJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        PulleyJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        PulleyJoint.prototype.getReactionTorque = function (inv_dt) {\n            return 0.0;\n        };\n        PulleyJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // Get the pulley axes.\n            this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n            this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n            var lengthA = this.m_uA.length();\n            var lengthB = this.m_uB.length();\n            if (lengthA > 10.0 * Settings.linearSlop) {\n                this.m_uA.mul(1.0 / lengthA);\n            }\n            else {\n                this.m_uA.setZero();\n            }\n            if (lengthB > 10.0 * Settings.linearSlop) {\n                this.m_uB.mul(1.0 / lengthB);\n            }\n            else {\n                this.m_uB.setZero();\n            }\n            // Compute effective mass.\n            var ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA); // float\n            var ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB); // float\n            var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n            var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n            this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n            if (this.m_mass > 0.0) {\n                this.m_mass = 1.0 / this.m_mass;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support variable time steps.\n                this.m_impulse *= step.dtRatio;\n                // Warm starting.\n                var PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n                var PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n                vA.addMul(this.m_invMassA, PA);\n                wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n                vB.addMul(this.m_invMassB, PB);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        PulleyJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n            var vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n            var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio\n                * Vec2.dot(this.m_uB, vpB); // float\n            var impulse = -this.m_mass * Cdot; // float\n            this.m_impulse += impulse;\n            var PA = Vec2.mulNumVec2(-impulse, this.m_uA); // Vec2\n            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB); // Vec2\n            vA.addMul(this.m_invMassA, PA);\n            wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n            vB.addMul(this.m_invMassB, PB);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        PulleyJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // Get the pulley axes.\n            var uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n            var uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n            var lengthA = uA.length();\n            var lengthB = uB.length();\n            if (lengthA > 10.0 * Settings.linearSlop) {\n                uA.mul(1.0 / lengthA);\n            }\n            else {\n                uA.setZero();\n            }\n            if (lengthB > 10.0 * Settings.linearSlop) {\n                uB.mul(1.0 / lengthB);\n            }\n            else {\n                uB.setZero();\n            }\n            // Compute effective mass.\n            var ruA = Vec2.crossVec2Vec2(rA, uA);\n            var ruB = Vec2.crossVec2Vec2(rB, uB);\n            var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n            var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n            var mass = mA + this.m_ratio * this.m_ratio * mB; // float\n            if (mass > 0.0) {\n                mass = 1.0 / mass;\n            }\n            var C = this.m_constant - lengthA - this.m_ratio * lengthB; // float\n            var linearError = math.abs(C); // float\n            var impulse = -mass * C; // float\n            var PA = Vec2.mulNumVec2(-impulse, uA); // Vec2\n            var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB); // Vec2\n            cA.addMul(this.m_invMassA, PA);\n            aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n            cB.addMul(this.m_invMassB, PB);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return linearError < Settings.linearSlop;\n        };\n        PulleyJoint.TYPE = 'pulley-joint';\n        return PulleyJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var inactiveLimit = 0;\n    var atUpperLimit = 2;\n    var DEFAULTS$2 = {\n        maxLength: 0.0,\n    };\n    /**\n     * A rope joint enforces a maximum distance between two points on two bodies. It\n     * has no other effect.\n     *\n     * Warning: if you attempt to change the maximum length during the simulation\n     * you will get some non-physical behavior.\n     *\n     * A model that would allow you to dynamically modify the length would have some\n     * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n     * want to dynamically control length.\n     */\n    var RopeJoint = /** @class */ (function (_super) {\n        __extends(RopeJoint, _super);\n        function RopeJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof RopeJoint)) {\n                return new RopeJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$2);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = RopeJoint.TYPE;\n            _this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n            _this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n            _this.m_maxLength = def.maxLength;\n            _this.m_mass = 0.0;\n            _this.m_impulse = 0.0;\n            _this.m_length = 0.0;\n            _this.m_state = inactiveLimit;\n            return _this;\n            // Limit:\n            // C = norm(pB - pA) - L\n            // u = (pB - pA) / norm(pB - pA)\n            // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n            // J = [-u -cross(rA, u) u cross(rB, u)]\n            // K = J * invM * JT\n            // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n        }\n        /** @internal */\n        RopeJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                maxLength: this.m_maxLength,\n            };\n        };\n        /** @internal */\n        RopeJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new RopeJoint(data);\n            return joint;\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        RopeJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        RopeJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Set the maximum length of the rope.\n         */\n        RopeJoint.prototype.setMaxLength = function (length) {\n            this.m_maxLength = length;\n        };\n        /**\n         * Get the maximum length of the rope.\n         */\n        RopeJoint.prototype.getMaxLength = function () {\n            return this.m_maxLength;\n        };\n        RopeJoint.prototype.getLimitState = function () {\n            // TODO LimitState\n            return this.m_state;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        RopeJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        RopeJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        RopeJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        RopeJoint.prototype.getReactionTorque = function (inv_dt) {\n            return 0.0;\n        };\n        RopeJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            this.m_u = Vec2.zero();\n            this.m_u.addCombine(1, cB, 1, this.m_rB);\n            this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2\n            this.m_length = this.m_u.length();\n            var C = this.m_length - this.m_maxLength; // float\n            if (C > 0.0) {\n                this.m_state = atUpperLimit;\n            }\n            else {\n                this.m_state = inactiveLimit;\n            }\n            if (this.m_length > Settings.linearSlop) {\n                this.m_u.mul(1.0 / this.m_length);\n            }\n            else {\n                this.m_u.setZero();\n                this.m_mass = 0.0;\n                this.m_impulse = 0.0;\n                return;\n            }\n            // Compute effective mass.\n            var crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u); // float\n            var crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u); // float\n            var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB\n                + this.m_invIB * crB * crB; // float\n            this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n            if (step.warmStarting) {\n                // Scale the impulse to support a variable time step.\n                this.m_impulse *= step.dtRatio;\n                var P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            }\n            else {\n                this.m_impulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        RopeJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Cdot = dot(u, v + cross(w, r))\n            var vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA); // Vec2\n            var vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB); // Vec2\n            var C = this.m_length - this.m_maxLength; // float\n            var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float\n            // Predictive constraint.\n            if (C < 0.0) {\n                Cdot += step.inv_dt * C;\n            }\n            var impulse = -this.m_mass * Cdot; // float\n            var oldImpulse = this.m_impulse; // float\n            this.m_impulse = math.min(0.0, this.m_impulse + impulse);\n            impulse = this.m_impulse - oldImpulse;\n            var P = Vec2.mulNumVec2(impulse, this.m_u); // Vec2\n            vA.subMul(this.m_invMassA, P);\n            wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n            vB.addMul(this.m_invMassB, P);\n            wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        RopeJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c; // Vec2\n            var aA = this.m_bodyA.c_position.a; // float\n            var cB = this.m_bodyB.c_position.c; // Vec2\n            var aB = this.m_bodyB.c_position.a; // float\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n            var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n            var u = Vec2.zero();\n            u.addCombine(1, cB, 1, rB);\n            u.subCombine(1, cA, 1, rA); // Vec2\n            var length = u.normalize(); // float\n            var C = length - this.m_maxLength; // float\n            C = math.clamp(C, 0.0, Settings.maxLinearCorrection);\n            var impulse = -this.m_mass * C; // float\n            var P = Vec2.mulNumVec2(impulse, u); // Vec2\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return length - this.m_maxLength < Settings.linearSlop;\n        };\n        RopeJoint.TYPE = 'rope-joint';\n        return RopeJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS$1 = {\n        frequencyHz: 0.0,\n        dampingRatio: 0.0,\n    };\n    /**\n     * A weld joint essentially glues two bodies together. A weld joint may distort\n     * somewhat because the island constraint solver is approximate.\n     */\n    var WeldJoint = /** @class */ (function (_super) {\n        __extends(WeldJoint, _super);\n        function WeldJoint(def, bodyA, bodyB, anchor) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof WeldJoint)) {\n                return new WeldJoint(def, bodyA, bodyB, anchor);\n            }\n            def = options(def, DEFAULTS$1);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = WeldJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            _this.m_referenceAngle = math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_impulse = new Vec3();\n            _this.m_bias = 0.0;\n            _this.m_gamma = 0.0;\n            // Solver temp\n            _this.m_rA; // Vec2\n            _this.m_rB; // Vec2\n            _this.m_localCenterA; // Vec2\n            _this.m_localCenterB; // Vec2\n            _this.m_invMassA; // float\n            _this.m_invMassB; // float\n            _this.m_invIA; // float\n            _this.m_invIB; // float\n            _this.m_mass = new Mat33();\n            return _this;\n            // Point-to-point constraint\n            // C = p2 - p1\n            // Cdot = v2 - v1\n            // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n            // J = [-I -r1_skew I r2_skew ]\n            // Identity used:\n            // w k % (rx i + ry j) = w * (-ry i + rx j)\n            // Angle constraint\n            // C = angle2 - angle1 - referenceAngle\n            // Cdot = w2 - w1\n            // J = [0 0 -1 0 0 1]\n            // K = invI1 + invI2\n        }\n        /** @internal */\n        WeldJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                referenceAngle: this.m_referenceAngle,\n            };\n        };\n        /** @internal */\n        WeldJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new WeldJoint(data);\n            return joint;\n        };\n        /** @internal */\n        WeldJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        WeldJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        WeldJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * Get the reference angle.\n         */\n        WeldJoint.prototype.getReferenceAngle = function () {\n            return this.m_referenceAngle;\n        };\n        /**\n         * Set frequency in Hz.\n         */\n        WeldJoint.prototype.setFrequency = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        /**\n         * Get frequency in Hz.\n         */\n        WeldJoint.prototype.getFrequency = function () {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set damping ratio.\n         */\n        WeldJoint.prototype.setDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        /**\n         * Get damping ratio.\n         */\n        WeldJoint.prototype.getDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        WeldJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        WeldJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        WeldJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        WeldJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_impulse.z;\n        };\n        WeldJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            // J = [-I -r1_skew I r2_skew]\n            // [ 0 -1 0 1]\n            // r_skew = [-ry; rx]\n            // Matlab\n            // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n            // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n            // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var K = new Mat33();\n            K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y\n                * iB;\n            K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n            K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n            K.ex.y = K.ey.x;\n            K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x\n                * iB;\n            K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n            K.ex.z = K.ez.x;\n            K.ey.z = K.ez.y;\n            K.ez.z = iA + iB;\n            if (this.m_frequencyHz > 0.0) {\n                K.getInverse22(this.m_mass);\n                var invM = iA + iB; // float\n                var m = invM > 0.0 ? 1.0 / invM : 0.0; // float\n                var C = aB - aA - this.m_referenceAngle; // float\n                // Frequency\n                var omega = 2.0 * math.PI * this.m_frequencyHz; // float\n                // Damping coefficient\n                var d = 2.0 * m * this.m_dampingRatio * omega; // float\n                // Spring stiffness\n                var k = m * omega * omega; // float\n                // magic formulas\n                var h = step.dt; // float\n                this.m_gamma = h * (d + h * k);\n                this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n                this.m_bias = C * h * k * this.m_gamma;\n                invM += this.m_gamma;\n                this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n            }\n            else if (K.ez.z == 0.0) {\n                K.getInverse22(this.m_mass);\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            else {\n                K.getSymInverse33(this.m_mass);\n                this.m_gamma = 0.0;\n                this.m_bias = 0.0;\n            }\n            if (step.warmStarting) {\n                // Scale impulses to support a variable time step.\n                this.m_impulse.mul(step.dtRatio);\n                var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n            }\n            else {\n                this.m_impulse.setZero();\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        WeldJoint.prototype.solveVelocityConstraints = function (step) {\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            if (this.m_frequencyHz > 0.0) {\n                var Cdot2 = wB - wA; // float\n                var impulse2 = -this.m_mass.ez.z\n                    * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float\n                this.m_impulse.z += impulse2;\n                wA -= iA * impulse2;\n                wB += iB * impulse2;\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n                var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2\n                this.m_impulse.x += impulse1.x;\n                this.m_impulse.y += impulse1.y;\n                var P = Vec2.clone(impulse1); // Vec2\n                vA.subMul(mA, P);\n                wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n                vB.addMul(mB, P);\n                wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n            }\n            else {\n                var Cdot1 = Vec2.zero();\n                Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n                Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n                var Cdot2 = wB - wA; // float\n                var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3\n                var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3\n                this.m_impulse.add(impulse);\n                var P = Vec2.neo(impulse.x, impulse.y);\n                vA.subMul(mA, P);\n                wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n                vB.addMul(mB, P);\n                wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n            }\n            this.m_bodyA.c_velocity.v = vA;\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v = vB;\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        WeldJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB;\n            var iA = this.m_invIA;\n            var iB = this.m_invIB;\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var positionError;\n            var angularError;\n            var K = new Mat33();\n            K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n            K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n            K.ez.x = -rA.y * iA - rB.y * iB;\n            K.ex.y = K.ey.x;\n            K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n            K.ez.y = rA.x * iA + rB.x * iB;\n            K.ex.z = K.ez.x;\n            K.ey.z = K.ez.y;\n            K.ez.z = iA + iB;\n            if (this.m_frequencyHz > 0.0) {\n                var C1 = Vec2.zero();\n                C1.addCombine(1, cB, 1, rB);\n                C1.subCombine(1, cA, 1, rA); // Vec2\n                positionError = C1.length();\n                angularError = 0.0;\n                var P = Vec2.neg(K.solve22(C1)); // Vec2\n                cA.subMul(mA, P);\n                aA -= iA * Vec2.crossVec2Vec2(rA, P);\n                cB.addMul(mB, P);\n                aB += iB * Vec2.crossVec2Vec2(rB, P);\n            }\n            else {\n                var C1 = Vec2.zero();\n                C1.addCombine(1, cB, 1, rB);\n                C1.subCombine(1, cA, 1, rA);\n                var C2 = aB - aA - this.m_referenceAngle; // float\n                positionError = C1.length();\n                angularError = math.abs(C2);\n                var C = new Vec3(C1.x, C1.y, C2);\n                var impulse = new Vec3();\n                if (K.ez.z > 0.0) {\n                    impulse = Vec3.neg(K.solve33(C));\n                }\n                else {\n                    var impulse2 = Vec2.neg(K.solve22(C1));\n                    impulse.set(impulse2.x, impulse2.y, 0.0);\n                }\n                var P = Vec2.neo(impulse.x, impulse.y);\n                cA.subMul(mA, P);\n                aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n                cB.addMul(mB, P);\n                aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n            }\n            this.m_bodyA.c_position.c = cA;\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c = cB;\n            this.m_bodyB.c_position.a = aB;\n            return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n        };\n        WeldJoint.TYPE = 'weld-joint';\n        return WeldJoint;\n    }(Joint));\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    var DEFAULTS = {\n        enableMotor: false,\n        maxMotorTorque: 0.0,\n        motorSpeed: 0.0,\n        frequencyHz: 2.0,\n        dampingRatio: 0.7,\n    };\n    /**\n     * A wheel joint. This joint provides two degrees of freedom: translation along\n     * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n     * point to line constraint with a rotational motor and a linear spring/damper.\n     * This joint is designed for vehicle suspensions.\n     */\n    var WheelJoint = /** @class */ (function (_super) {\n        __extends(WheelJoint, _super);\n        // @ts-ignore\n        function WheelJoint(def, bodyA, bodyB, anchor, axis) {\n            var _this = this;\n            // @ts-ignore\n            if (!(_this instanceof WheelJoint)) {\n                return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n            }\n            def = options(def, DEFAULTS);\n            _this = _super.call(this, def, bodyA, bodyB) || this;\n            /** @internal */ _this.m_ax = Vec2.zero();\n            /** @internal */ _this.m_ay = Vec2.zero();\n            bodyA = _this.m_bodyA;\n            bodyB = _this.m_bodyB;\n            _this.m_type = WheelJoint.TYPE;\n            _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n            _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n            // @ts-ignore localAxis\n            _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));\n            _this.m_localYAxisA = Vec2.crossNumVec2(1.0, _this.m_localXAxisA);\n            _this.m_mass = 0.0;\n            _this.m_impulse = 0.0;\n            _this.m_motorMass = 0.0;\n            _this.m_motorImpulse = 0.0;\n            _this.m_springMass = 0.0;\n            _this.m_springImpulse = 0.0;\n            _this.m_maxMotorTorque = def.maxMotorTorque;\n            _this.m_motorSpeed = def.motorSpeed;\n            _this.m_enableMotor = def.enableMotor;\n            _this.m_frequencyHz = def.frequencyHz;\n            _this.m_dampingRatio = def.dampingRatio;\n            _this.m_bias = 0.0;\n            _this.m_gamma = 0.0;\n            return _this;\n            // Linear constraint (point-to-line)\n            // d = pB - pA = xB + rB - xA - rA\n            // C = dot(ay, d)\n            // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n            // rA))\n            // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n            // ay), vB)\n            // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n            // Spring linear constraint\n            // C = dot(ax, d)\n            // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n            // dot(cross(rB, ax), vB)\n            // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n            // Motor rotational constraint\n            // Cdot = wB - wA\n            // J = [0 0 -1 0 0 1]\n        }\n        /** @internal */\n        WheelJoint.prototype._serialize = function () {\n            return {\n                type: this.m_type,\n                bodyA: this.m_bodyA,\n                bodyB: this.m_bodyB,\n                collideConnected: this.m_collideConnected,\n                enableMotor: this.m_enableMotor,\n                maxMotorTorque: this.m_maxMotorTorque,\n                motorSpeed: this.m_motorSpeed,\n                frequencyHz: this.m_frequencyHz,\n                dampingRatio: this.m_dampingRatio,\n                localAnchorA: this.m_localAnchorA,\n                localAnchorB: this.m_localAnchorB,\n                localAxisA: this.m_localXAxisA,\n            };\n        };\n        /** @internal */\n        WheelJoint._deserialize = function (data, world, restore) {\n            data = __assign({}, data);\n            data.bodyA = restore(Body, data.bodyA, world);\n            data.bodyB = restore(Body, data.bodyB, world);\n            var joint = new WheelJoint(data);\n            return joint;\n        };\n        /** @internal */\n        WheelJoint.prototype._setAnchors = function (def) {\n            if (def.anchorA) {\n                this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n            }\n            else if (def.localAnchorA) {\n                this.m_localAnchorA.setVec2(def.localAnchorA);\n            }\n            if (def.anchorB) {\n                this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n            }\n            else if (def.localAnchorB) {\n                this.m_localAnchorB.setVec2(def.localAnchorB);\n            }\n            if (def.localAxisA) {\n                this.m_localXAxisA.setVec2(def.localAxisA);\n                this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n            }\n        };\n        /**\n         * The local anchor point relative to bodyA's origin.\n         */\n        WheelJoint.prototype.getLocalAnchorA = function () {\n            return this.m_localAnchorA;\n        };\n        /**\n         * The local anchor point relative to bodyB's origin.\n         */\n        WheelJoint.prototype.getLocalAnchorB = function () {\n            return this.m_localAnchorB;\n        };\n        /**\n         * The local joint axis relative to bodyA.\n         */\n        WheelJoint.prototype.getLocalAxisA = function () {\n            return this.m_localXAxisA;\n        };\n        /**\n         * Get the current joint translation, usually in meters.\n         */\n        WheelJoint.prototype.getJointTranslation = function () {\n            var bA = this.m_bodyA;\n            var bB = this.m_bodyB;\n            var pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2\n            var pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2\n            var d = Vec2.sub(pB, pA); // Vec2\n            var axis = bA.getWorldVector(this.m_localXAxisA); // Vec2\n            var translation = Vec2.dot(d, axis); // float\n            return translation;\n        };\n        /**\n         * Get the current joint translation speed, usually in meters per second.\n         */\n        WheelJoint.prototype.getJointSpeed = function () {\n            var wA = this.m_bodyA.m_angularVelocity;\n            var wB = this.m_bodyB.m_angularVelocity;\n            return wB - wA;\n        };\n        /**\n         * Is the joint motor enabled?\n         */\n        WheelJoint.prototype.isMotorEnabled = function () {\n            return this.m_enableMotor;\n        };\n        /**\n         * Enable/disable the joint motor.\n         */\n        WheelJoint.prototype.enableMotor = function (flag) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_enableMotor = flag;\n        };\n        /**\n         * Set the motor speed, usually in radians per second.\n         */\n        WheelJoint.prototype.setMotorSpeed = function (speed) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_motorSpeed = speed;\n        };\n        /**\n         * Get the motor speed, usually in radians per second.\n         */\n        WheelJoint.prototype.getMotorSpeed = function () {\n            return this.m_motorSpeed;\n        };\n        /**\n         * Set/Get the maximum motor force, usually in N-m.\n         */\n        WheelJoint.prototype.setMaxMotorTorque = function (torque) {\n            this.m_bodyA.setAwake(true);\n            this.m_bodyB.setAwake(true);\n            this.m_maxMotorTorque = torque;\n        };\n        WheelJoint.prototype.getMaxMotorTorque = function () {\n            return this.m_maxMotorTorque;\n        };\n        /**\n         * Get the current motor torque given the inverse time step, usually in N-m.\n         */\n        WheelJoint.prototype.getMotorTorque = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        /**\n         * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n         * the spring.\n         */\n        WheelJoint.prototype.setSpringFrequencyHz = function (hz) {\n            this.m_frequencyHz = hz;\n        };\n        WheelJoint.prototype.getSpringFrequencyHz = function () {\n            return this.m_frequencyHz;\n        };\n        /**\n         * Set/Get the spring damping ratio\n         */\n        WheelJoint.prototype.setSpringDampingRatio = function (ratio) {\n            this.m_dampingRatio = ratio;\n        };\n        WheelJoint.prototype.getSpringDampingRatio = function () {\n            return this.m_dampingRatio;\n        };\n        /**\n         * Get the anchor point on bodyA in world coordinates.\n         */\n        WheelJoint.prototype.getAnchorA = function () {\n            return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n        };\n        /**\n         * Get the anchor point on bodyB in world coordinates.\n         */\n        WheelJoint.prototype.getAnchorB = function () {\n            return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n        };\n        /**\n         * Get the reaction force on bodyB at the joint anchor in Newtons.\n         */\n        WheelJoint.prototype.getReactionForce = function (inv_dt) {\n            return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n        };\n        /**\n         * Get the reaction torque on bodyB in N*m.\n         */\n        WheelJoint.prototype.getReactionTorque = function (inv_dt) {\n            return inv_dt * this.m_motorImpulse;\n        };\n        WheelJoint.prototype.initVelocityConstraints = function (step) {\n            this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n            this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n            this.m_invMassA = this.m_bodyA.m_invMass;\n            this.m_invMassB = this.m_bodyB.m_invMass;\n            this.m_invIA = this.m_bodyA.m_invI;\n            this.m_invIB = this.m_bodyB.m_invI;\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            // Compute the effective masses.\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA); // Vec2\n            // Point to line constraint\n            {\n                this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n                this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n                this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n                this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy\n                    * this.m_sBy;\n                if (this.m_mass > 0.0) {\n                    this.m_mass = 1.0 / this.m_mass;\n                }\n            }\n            // Spring constraint\n            this.m_springMass = 0.0;\n            this.m_bias = 0.0;\n            this.m_gamma = 0.0;\n            if (this.m_frequencyHz > 0.0) {\n                this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n                this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n                this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n                var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx\n                    * this.m_sBx; // float\n                if (invMass > 0.0) {\n                    this.m_springMass = 1.0 / invMass;\n                    var C = Vec2.dot(d, this.m_ax); // float\n                    // Frequency\n                    var omega = 2.0 * math.PI * this.m_frequencyHz; // float\n                    // Damping coefficient\n                    var damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float\n                    // Spring stiffness\n                    var k = this.m_springMass * omega * omega; // float\n                    // magic formulas\n                    var h = step.dt; // float\n                    this.m_gamma = h * (damp + h * k);\n                    if (this.m_gamma > 0.0) {\n                        this.m_gamma = 1.0 / this.m_gamma;\n                    }\n                    this.m_bias = C * h * k * this.m_gamma;\n                    this.m_springMass = invMass + this.m_gamma;\n                    if (this.m_springMass > 0.0) {\n                        this.m_springMass = 1.0 / this.m_springMass;\n                    }\n                }\n            }\n            else {\n                this.m_springImpulse = 0.0;\n            }\n            // Rotational motor\n            if (this.m_enableMotor) {\n                this.m_motorMass = iA + iB;\n                if (this.m_motorMass > 0.0) {\n                    this.m_motorMass = 1.0 / this.m_motorMass;\n                }\n            }\n            else {\n                this.m_motorMass = 0.0;\n                this.m_motorImpulse = 0.0;\n            }\n            if (step.warmStarting) {\n                // Account for variable time step.\n                this.m_impulse *= step.dtRatio;\n                this.m_springImpulse *= step.dtRatio;\n                this.m_motorImpulse *= step.dtRatio;\n                var P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n                var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n                var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n                vA.subMul(this.m_invMassA, P);\n                wA -= this.m_invIA * LA;\n                vB.addMul(this.m_invMassB, P);\n                wB += this.m_invIB * LB;\n            }\n            else {\n                this.m_impulse = 0.0;\n                this.m_springImpulse = 0.0;\n                this.m_motorImpulse = 0.0;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        WheelJoint.prototype.solveVelocityConstraints = function (step) {\n            var mA = this.m_invMassA;\n            var mB = this.m_invMassB; // float\n            var iA = this.m_invIA;\n            var iB = this.m_invIB; // float\n            var vA = this.m_bodyA.c_velocity.v;\n            var wA = this.m_bodyA.c_velocity.w;\n            var vB = this.m_bodyB.c_velocity.v;\n            var wB = this.m_bodyB.c_velocity.w;\n            // Solve spring constraint\n            {\n                var Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx\n                    * wB - this.m_sAx * wA; // float\n                var impulse = -this.m_springMass\n                    * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float\n                this.m_springImpulse += impulse;\n                var P = Vec2.mulNumVec2(impulse, this.m_ax); // Vec2\n                var LA = impulse * this.m_sAx; // float\n                var LB = impulse * this.m_sBx; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            // Solve rotational motor constraint\n            {\n                var Cdot = wB - wA - this.m_motorSpeed; // float\n                var impulse = -this.m_motorMass * Cdot; // float\n                var oldImpulse = this.m_motorImpulse; // float\n                var maxImpulse = step.dt * this.m_maxMotorTorque; // float\n                this.m_motorImpulse = math.clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n                impulse = this.m_motorImpulse - oldImpulse;\n                wA -= iA * impulse;\n                wB += iB * impulse;\n            }\n            // Solve point to line constraint\n            {\n                var Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy\n                    * wB - this.m_sAy * wA; // float\n                var impulse = -this.m_mass * Cdot; // float\n                this.m_impulse += impulse;\n                var P = Vec2.mulNumVec2(impulse, this.m_ay); // Vec2\n                var LA = impulse * this.m_sAy; // float\n                var LB = impulse * this.m_sBy; // float\n                vA.subMul(mA, P);\n                wA -= iA * LA;\n                vB.addMul(mB, P);\n                wB += iB * LB;\n            }\n            this.m_bodyA.c_velocity.v.setVec2(vA);\n            this.m_bodyA.c_velocity.w = wA;\n            this.m_bodyB.c_velocity.v.setVec2(vB);\n            this.m_bodyB.c_velocity.w = wB;\n        };\n        /**\n         * This returns true if the position errors are within tolerance.\n         */\n        WheelJoint.prototype.solvePositionConstraints = function (step) {\n            var cA = this.m_bodyA.c_position.c;\n            var aA = this.m_bodyA.c_position.a;\n            var cB = this.m_bodyB.c_position.c;\n            var aB = this.m_bodyB.c_position.a;\n            var qA = Rot.neo(aA);\n            var qB = Rot.neo(aB);\n            var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n            var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n            var d = Vec2.zero();\n            d.addCombine(1, cB, 1, rB);\n            d.subCombine(1, cA, 1, rA);\n            var ay = Rot.mulVec2(qA, this.m_localYAxisA);\n            var sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay); // float\n            var sBy = Vec2.crossVec2Vec2(rB, ay); // float\n            var C = Vec2.dot(d, ay); // float\n            var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy\n                * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float\n            var impulse; // float\n            if (k != 0.0) {\n                impulse = -C / k;\n            }\n            else {\n                impulse = 0.0;\n            }\n            var P = Vec2.mulNumVec2(impulse, ay); // Vec2\n            var LA = impulse * sAy; // float\n            var LB = impulse * sBy; // float\n            cA.subMul(this.m_invMassA, P);\n            aA -= this.m_invIA * LA;\n            cB.addMul(this.m_invMassB, P);\n            aB += this.m_invIB * LB;\n            this.m_bodyA.c_position.c.setVec2(cA);\n            this.m_bodyA.c_position.a = aA;\n            this.m_bodyB.c_position.c.setVec2(cB);\n            this.m_bodyB.c_position.a = aB;\n            return math.abs(C) <= Settings.linearSlop;\n        };\n        WheelJoint.TYPE = 'wheel-joint';\n        return WheelJoint;\n    }(Joint));\n\n    var SID = 0;\n    function Serializer(opts) {\n        var _a;\n        opts = opts || {};\n        var rootClass = opts.rootClass || World;\n        var preSerialize = opts.preSerialize || function (obj) { return obj; };\n        var postSerialize = opts.postSerialize || function (data, obj) { return data; };\n        var preDeserialize = opts.preDeserialize || function (data) { return data; };\n        var postDeserialize = opts.postDeserialize || function (obj, data) { return obj; };\n        // This is used to create ref objects during serialize\n        var refTypes = {\n            World: World,\n            Body: Body,\n            Joint: Joint,\n            Fixture: Fixture,\n            Shape: Shape,\n        };\n        // This is used by restore to deserialize objects and refs\n        var restoreTypes = __assign({ Vec2: Vec2,\n            Vec3: Vec3 }, refTypes);\n        var CLASS_BY_TYPE_PROP = (_a = {},\n            _a[Body.STATIC] = Body,\n            _a[Body.DYNAMIC] = Body,\n            _a[Body.KINEMATIC] = Body,\n            _a[ChainShape.TYPE] = ChainShape,\n            _a[BoxShape.TYPE] = BoxShape,\n            _a[EdgeShape.TYPE] = EdgeShape,\n            _a[PolygonShape.TYPE] = PolygonShape,\n            _a[CircleShape.TYPE] = CircleShape,\n            _a[DistanceJoint.TYPE] = DistanceJoint,\n            _a[FrictionJoint.TYPE] = FrictionJoint,\n            _a[GearJoint.TYPE] = GearJoint,\n            _a[MotorJoint.TYPE] = MotorJoint,\n            _a[MouseJoint.TYPE] = MouseJoint,\n            _a[PrismaticJoint.TYPE] = PrismaticJoint,\n            _a[PulleyJoint.TYPE] = PulleyJoint,\n            _a[RevoluteJoint.TYPE] = RevoluteJoint,\n            _a[RopeJoint.TYPE] = RopeJoint,\n            _a[WeldJoint.TYPE] = WeldJoint,\n            _a[WheelJoint.TYPE] = WheelJoint,\n            _a);\n        this.toJson = function (root) {\n            var json = [];\n            var queue = [root];\n            var refMap = {};\n            function storeRef(value, typeName) {\n                value.__sid = value.__sid || ++SID;\n                if (!refMap[value.__sid]) {\n                    queue.push(value);\n                    var index = json.length + queue.length;\n                    var ref = {\n                        refIndex: index,\n                        refType: typeName\n                    };\n                    refMap[value.__sid] = ref;\n                }\n                return refMap[value.__sid];\n            }\n            function serialize(obj) {\n                obj = preSerialize(obj);\n                var data = obj._serialize();\n                data = postSerialize(data, obj);\n                return data;\n            }\n            function toJson(value, top) {\n                if (typeof value !== 'object' || value === null) {\n                    return value;\n                }\n                if (typeof value._serialize === 'function') {\n                    if (value !== top) {\n                        // tslint:disable-next-line:no-for-in\n                        for (var typeName in refTypes) {\n                            if (value instanceof refTypes[typeName]) {\n                                return storeRef(value, typeName);\n                            }\n                        }\n                    }\n                    value = serialize(value);\n                }\n                if (Array.isArray(value)) {\n                    var newValue = [];\n                    for (var key = 0; key < value.length; key++) {\n                        newValue[key] = toJson(value[key]);\n                    }\n                    value = newValue;\n                }\n                else {\n                    var newValue = {};\n                    // tslint:disable-next-line:no-for-in\n                    for (var key in value) {\n                        if (value.hasOwnProperty(key)) {\n                            newValue[key] = toJson(value[key]);\n                        }\n                    }\n                    value = newValue;\n                }\n                return value;\n            }\n            while (queue.length) {\n                var obj = queue.shift();\n                var str = toJson(obj, obj);\n                json.push(str);\n            }\n            return json;\n        };\n        this.fromJson = function (json) {\n            var refMap = {};\n            function findDeserilizer(data, cls) {\n                if (!cls || !cls._deserialize) {\n                    cls = CLASS_BY_TYPE_PROP[data.type];\n                }\n                return cls && cls._deserialize;\n            }\n            /**\n             * Deserialize a data object.\n             */\n            function deserialize(cls, data, ctx) {\n                var deserializer = findDeserilizer(data, cls);\n                if (!deserializer) {\n                    return;\n                }\n                data = preDeserialize(data);\n                var obj = deserializer(data, ctx, restoreRef);\n                obj = postDeserialize(obj, data);\n                return obj;\n            }\n            /**\n             * Restore a ref object or deserialize a data object.\n             *\n             * This is passed as callback to class deserializers.\n             */\n            function restoreRef(cls, ref, ctx) {\n                if (!ref.refIndex) {\n                    return cls && cls._deserialize && deserialize(cls, ref, ctx);\n                }\n                cls = restoreTypes[ref.refType] || cls;\n                var index = ref.refIndex;\n                if (!refMap[index]) {\n                    var data = json[index];\n                    var obj = deserialize(cls, data, ctx);\n                    refMap[index] = obj;\n                }\n                return refMap[index];\n            }\n            var root = rootClass._deserialize(json[0], null, restoreRef);\n            return root;\n        };\n    }\n    var serializer = new Serializer();\n    Serializer.toJson = serializer.toJson;\n    Serializer.fromJson = serializer.fromJson;\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n    function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    function CollideCircles(manifold, circleA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        var pA = Transform.mulVec2(xfA, circleA.m_p);\n        var pB = Transform.mulVec2(xfB, circleB.m_p);\n        var distSqr = Vec2.distanceSquared(pB, pA);\n        var rA = circleA.m_radius;\n        var rB = circleB.m_radius;\n        var radius = rA + rB;\n        if (distSqr > radius * radius) {\n            return;\n        }\n        manifold.type = ManifoldType.e_circles;\n        manifold.localPoint.setVec2(circleA.m_p);\n        manifold.localNormal.setZero();\n        manifold.pointCount = 1;\n        manifold.points[0].localPoint.setVec2(circleB.m_p);\n        // manifold.points[0].id.key = 0;\n        manifold.points[0].id.cf.indexA = 0;\n        manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n        manifold.points[0].id.cf.indexB = 0;\n        manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\n    Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n    function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        var shapeA = fixtureA.getShape();\n        var shapeB = fixtureB.getShape();\n        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n    }\n    function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        var chain = fixtureA.getShape();\n        var edge = new EdgeShape();\n        chain.getChildEdge(edge, indexA);\n        var shapeA = edge;\n        var shapeB = fixtureB.getShape();\n        CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n    }\n    // Compute contact points for edge versus circle.\n    // This accounts for edge connectivity.\n    function CollideEdgeCircle(manifold, edgeA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        // Compute circle in frame of edge\n        var Q = Transform.mulTVec2(xfA, Transform.mulVec2(xfB, circleB.m_p));\n        var A = edgeA.m_vertex1;\n        var B = edgeA.m_vertex2;\n        var e = Vec2.sub(B, A);\n        // Barycentric coordinates\n        var u = Vec2.dot(e, Vec2.sub(B, Q));\n        var v = Vec2.dot(e, Vec2.sub(Q, A));\n        var radius = edgeA.m_radius + circleB.m_radius;\n        // Region A\n        if (v <= 0.0) {\n            var P_1 = Vec2.clone(A);\n            var d_1 = Vec2.sub(Q, P_1);\n            var dd_1 = Vec2.dot(d_1, d_1);\n            if (dd_1 > radius * radius) {\n                return;\n            }\n            // Is there an edge connected to A?\n            if (edgeA.m_hasVertex0) {\n                var A1 = edgeA.m_vertex0;\n                var B1 = A;\n                var e1 = Vec2.sub(B1, A1);\n                var u1 = Vec2.dot(e1, Vec2.sub(B1, Q));\n                // Is the circle in Region AB of the previous edge?\n                if (u1 > 0.0) {\n                    return;\n                }\n            }\n            manifold.type = ManifoldType.e_circles;\n            manifold.localNormal.setZero();\n            manifold.localPoint.setVec2(P_1);\n            manifold.pointCount = 1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Region B\n        if (u <= 0.0) {\n            var P_2 = Vec2.clone(B);\n            var d_2 = Vec2.sub(Q, P_2);\n            var dd_2 = Vec2.dot(d_2, d_2);\n            if (dd_2 > radius * radius) {\n                return;\n            }\n            // Is there an edge connected to B?\n            if (edgeA.m_hasVertex3) {\n                var B2 = edgeA.m_vertex3;\n                var A2 = B;\n                var e2 = Vec2.sub(B2, A2);\n                var v2 = Vec2.dot(e2, Vec2.sub(Q, A2));\n                // Is the circle in Region AB of the next edge?\n                if (v2 > 0.0) {\n                    return;\n                }\n            }\n            manifold.type = ManifoldType.e_circles;\n            manifold.localNormal.setZero();\n            manifold.localPoint.setVec2(P_2);\n            manifold.pointCount = 1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 1;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Region AB\n        var den = Vec2.dot(e, e);\n        var P = Vec2.combine(u / den, A, v / den, B);\n        var d = Vec2.sub(Q, P);\n        var dd = Vec2.dot(d, d);\n        if (dd > radius * radius) {\n            return;\n        }\n        var n = Vec2.neo(-e.y, e.x);\n        if (Vec2.dot(n, Vec2.sub(Q, A)) < 0.0) {\n            n.setNum(-n.x, -n.y);\n        }\n        n.normalize();\n        manifold.type = ManifoldType.e_faceA;\n        manifold.localNormal = n;\n        manifold.localPoint.setVec2(A);\n        manifold.pointCount = 1;\n        manifold.points[0].localPoint.setVec2(circleB.m_p);\n        // manifold.points[0].id.key = 0;\n        manifold.points[0].id.cf.indexA = 0;\n        manifold.points[0].id.cf.typeA = ContactFeatureType.e_face;\n        manifold.points[0].id.cf.indexB = 0;\n        manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n    function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    /**\n     * Find the max separation between poly1 and poly2 using edge normals from\n     * poly1.\n     */\n    function findMaxSeparation(poly1, xf1, poly2, xf2, output) {\n        var count1 = poly1.m_count;\n        var count2 = poly2.m_count;\n        var n1s = poly1.m_normals;\n        var v1s = poly1.m_vertices;\n        var v2s = poly2.m_vertices;\n        var xf = Transform.mulTXf(xf2, xf1);\n        var bestIndex = 0;\n        var maxSeparation = -Infinity;\n        for (var i = 0; i < count1; ++i) {\n            // Get poly1 normal in frame2.\n            var n = Rot.mulVec2(xf.q, n1s[i]);\n            var v1 = Transform.mulVec2(xf, v1s[i]);\n            // Find deepest point for normal i.\n            var si = Infinity;\n            for (var j = 0; j < count2; ++j) {\n                var sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);\n                if (sij < si) {\n                    si = sij;\n                }\n            }\n            if (si > maxSeparation) {\n                maxSeparation = si;\n                bestIndex = i;\n            }\n        }\n        // used to keep last FindMaxSeparation call values\n        output.maxSeparation = maxSeparation;\n        output.bestIndex = bestIndex;\n    }\n    function findIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {\n        var normals1 = poly1.m_normals;\n        var count2 = poly2.m_count;\n        var vertices2 = poly2.m_vertices;\n        var normals2 = poly2.m_normals;\n        // Get the normal of the reference edge in poly2's frame.\n        var normal1 = Rot.mulTVec2(xf2.q, Rot.mulVec2(xf1.q, normals1[edge1]));\n        // Find the incident edge on poly2.\n        var index = 0;\n        var minDot = Infinity;\n        for (var i = 0; i < count2; ++i) {\n            var dot = Vec2.dot(normal1, normals2[i]);\n            if (dot < minDot) {\n                minDot = dot;\n                index = i;\n            }\n        }\n        // Build the clip vertices for the incident edge.\n        var i1 = index;\n        var i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n        c[0].v = Transform.mulVec2(xf2, vertices2[i1]);\n        c[0].id.cf.indexA = edge1;\n        c[0].id.cf.indexB = i1;\n        c[0].id.cf.typeA = ContactFeatureType.e_face;\n        c[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        c[1].v = Transform.mulVec2(xf2, vertices2[i2]);\n        c[1].id.cf.indexA = edge1;\n        c[1].id.cf.indexB = i2;\n        c[1].id.cf.typeA = ContactFeatureType.e_face;\n        c[1].id.cf.typeB = ContactFeatureType.e_vertex;\n    }\n    var maxSeparation = {\n        maxSeparation: 0,\n        bestIndex: 0,\n    };\n    /**\n     *\n     * Find edge normal of max separation on A - return if separating axis is found<br>\n     * Find edge normal of max separation on B - return if separation axis is found<br>\n     * Choose reference edge as min(minA, minB)<br>\n     * Find incident edge<br>\n     * Clip\n     *\n     * The normal points from 1 to 2\n     */\n    function CollidePolygons(manifold, polyA, xfA, polyB, xfB) {\n        manifold.pointCount = 0;\n        var totalRadius = polyA.m_radius + polyB.m_radius;\n        findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n        var edgeA = maxSeparation.bestIndex;\n        var separationA = maxSeparation.maxSeparation;\n        if (separationA > totalRadius)\n            return;\n        findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n        var edgeB = maxSeparation.bestIndex;\n        var separationB = maxSeparation.maxSeparation;\n        if (separationB > totalRadius)\n            return;\n        var poly1; // reference polygon\n        var poly2; // incident polygon\n        var xf1;\n        var xf2;\n        var edge1; // reference edge\n        var flip;\n        var k_tol = 0.1 * Settings.linearSlop;\n        if (separationB > separationA + k_tol) {\n            poly1 = polyB;\n            poly2 = polyA;\n            xf1 = xfB;\n            xf2 = xfA;\n            edge1 = edgeB;\n            manifold.type = ManifoldType.e_faceB;\n            flip = 1;\n        }\n        else {\n            poly1 = polyA;\n            poly2 = polyB;\n            xf1 = xfA;\n            xf2 = xfB;\n            edge1 = edgeA;\n            manifold.type = ManifoldType.e_faceA;\n            flip = 0;\n        }\n        var incidentEdge = [new ClipVertex(), new ClipVertex()];\n        findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n        var count1 = poly1.m_count;\n        var vertices1 = poly1.m_vertices;\n        var iv1 = edge1;\n        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n        var v11 = vertices1[iv1];\n        var v12 = vertices1[iv2];\n        var localTangent = Vec2.sub(v12, v11);\n        localTangent.normalize();\n        var localNormal = Vec2.crossVec2Num(localTangent, 1.0);\n        var planePoint = Vec2.combine(0.5, v11, 0.5, v12);\n        var tangent = Rot.mulVec2(xf1.q, localTangent);\n        var normal = Vec2.crossVec2Num(tangent, 1.0);\n        v11 = Transform.mulVec2(xf1, v11);\n        v12 = Transform.mulVec2(xf1, v12);\n        // Face offset.\n        var frontOffset = Vec2.dot(normal, v11);\n        // Side offsets, extended by polytope skin thickness.\n        var sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;\n        var sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;\n        // Clip incident edge against extruded edge1 side edges.\n        var clipPoints1 = [new ClipVertex(), new ClipVertex()];\n        var clipPoints2 = [new ClipVertex(), new ClipVertex()];\n        var np;\n        // Clip to box side 1\n        np = clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg(tangent), sideOffset1, iv1);\n        if (np < 2) {\n            return;\n        }\n        // Clip to negative box side 1\n        np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\n        if (np < 2) {\n            return;\n        }\n        // Now clipPoints2 contains the clipped points.\n        manifold.localNormal = localNormal;\n        manifold.localPoint = planePoint;\n        var pointCount = 0;\n        for (var i = 0; i < clipPoints2.length /* maxManifoldPoints */; ++i) {\n            var separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;\n            if (separation <= totalRadius) {\n                var cp = manifold.points[pointCount];\n                cp.localPoint.setVec2(Transform.mulTVec2(xf2, clipPoints2[i].v));\n                cp.id = clipPoints2[i].id;\n                if (flip) {\n                    // Swap features\n                    var cf = cp.id.cf;\n                    var indexA = cf.indexA;\n                    var indexB = cf.indexB;\n                    var typeA = cf.typeA;\n                    var typeB = cf.typeB;\n                    cf.indexA = indexB;\n                    cf.indexB = indexA;\n                    cf.typeA = typeB;\n                    cf.typeB = typeA;\n                }\n                ++pointCount;\n            }\n        }\n        manifold.pointCount = pointCount;\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n    function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {\n        CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);\n    }\n    function CollidePolygonCircle(manifold, polygonA, xfA, circleB, xfB) {\n        manifold.pointCount = 0;\n        // Compute circle position in the frame of the polygon.\n        var c = Transform.mulVec2(xfB, circleB.m_p);\n        var cLocal = Transform.mulTVec2(xfA, c);\n        // Find the min separating edge.\n        var normalIndex = 0;\n        var separation = -Infinity;\n        var radius = polygonA.m_radius + circleB.m_radius;\n        var vertexCount = polygonA.m_count;\n        var vertices = polygonA.m_vertices;\n        var normals = polygonA.m_normals;\n        for (var i = 0; i < vertexCount; ++i) {\n            var s = Vec2.dot(normals[i], Vec2.sub(cLocal, vertices[i]));\n            if (s > radius) {\n                // Early out.\n                return;\n            }\n            if (s > separation) {\n                separation = s;\n                normalIndex = i;\n            }\n        }\n        // Vertices that subtend the incident face.\n        var vertIndex1 = normalIndex;\n        var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n        var v1 = vertices[vertIndex1];\n        var v2 = vertices[vertIndex2];\n        // If the center is inside the polygon ...\n        if (separation < math.EPSILON) {\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setVec2(normals[normalIndex]);\n            manifold.localPoint.setCombine(0.5, v1, 0.5, v2);\n            manifold.points[0].localPoint = circleB.m_p;\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            return;\n        }\n        // Compute barycentric coordinates\n        var u1 = Vec2.dot(Vec2.sub(cLocal, v1), Vec2.sub(v2, v1));\n        var u2 = Vec2.dot(Vec2.sub(cLocal, v2), Vec2.sub(v1, v2));\n        if (u1 <= 0.0) {\n            if (Vec2.distanceSquared(cLocal, v1) > radius * radius) {\n                return;\n            }\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setCombine(1, cLocal, -1, v1);\n            manifold.localNormal.normalize();\n            manifold.localPoint = v1;\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        }\n        else if (u2 <= 0.0) {\n            if (Vec2.distanceSquared(cLocal, v2) > radius * radius) {\n                return;\n            }\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setCombine(1, cLocal, -1, v2);\n            manifold.localNormal.normalize();\n            manifold.localPoint.setVec2(v2);\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        }\n        else {\n            var faceCenter = Vec2.mid(v1, v2);\n            var separation_1 = Vec2.dot(cLocal, normals[vertIndex1]) - Vec2.dot(faceCenter, normals[vertIndex1]);\n            if (separation_1 > radius) {\n                return;\n            }\n            manifold.pointCount = 1;\n            manifold.type = ManifoldType.e_faceA;\n            manifold.localNormal.setVec2(normals[vertIndex1]);\n            manifold.localPoint.setVec2(faceCenter);\n            manifold.points[0].localPoint.setVec2(circleB.m_p);\n            // manifold.points[0].id.key = 0;\n            manifold.points[0].id.cf.indexA = 0;\n            manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            manifold.points[0].id.cf.indexB = 0;\n            manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n        }\n    }\n\n    /*\n     * Planck.js\n     * The MIT License\n     * Copyright (c) 2021 Erin Catto, Ali Shakiba\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\n    Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n    function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {\n        CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);\n    }\n    function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {\n        var chain = fA.getShape();\n        var edge = new EdgeShape();\n        chain.getChildEdge(edge, indexA);\n        CollideEdgePolygon(manifold, edge, xfA, fB.getShape(), xfB);\n    }\n    var EPAxisType;\n    (function (EPAxisType) {\n        EPAxisType[EPAxisType[\"e_unknown\"] = -1] = \"e_unknown\";\n        EPAxisType[EPAxisType[\"e_edgeA\"] = 1] = \"e_edgeA\";\n        EPAxisType[EPAxisType[\"e_edgeB\"] = 2] = \"e_edgeB\";\n    })(EPAxisType || (EPAxisType = {}));\n    // unused?\n    var VertexType;\n    (function (VertexType) {\n        VertexType[VertexType[\"e_isolated\"] = 0] = \"e_isolated\";\n        VertexType[VertexType[\"e_concave\"] = 1] = \"e_concave\";\n        VertexType[VertexType[\"e_convex\"] = 2] = \"e_convex\";\n    })(VertexType || (VertexType = {}));\n    /**\n     * This structure is used to keep track of the best separating axis.\n     */\n    var EPAxis = /** @class */ (function () {\n        function EPAxis() {\n        }\n        return EPAxis;\n    }());\n    /**\n     * This holds polygon B expressed in frame A.\n     */\n    var TempPolygon = /** @class */ (function () {\n        function TempPolygon() {\n            this.vertices = []; // [Settings.maxPolygonVertices]\n            this.normals = []; // [Settings.maxPolygonVertices];\n            this.count = 0;\n        }\n        return TempPolygon;\n    }());\n    /**\n     * Reference face used for clipping\n     */\n    var ReferenceFace = /** @class */ (function () {\n        function ReferenceFace() {\n            this.normal = Vec2.zero();\n            this.sideNormal1 = Vec2.zero();\n            this.sideNormal2 = Vec2.zero();\n        }\n        return ReferenceFace;\n    }());\n    // reused\n    var edgeAxis = new EPAxis();\n    var polygonAxis = new EPAxis();\n    var polygonBA = new TempPolygon();\n    var rf = new ReferenceFace();\n    /**\n     * This function collides and edge and a polygon, taking into account edge\n     * adjacency.\n     */\n    function CollideEdgePolygon(manifold, edgeA, xfA, polygonB, xfB) {\n        // Algorithm:\n        // 1. Classify v1 and v2\n        // 2. Classify polygon centroid as front or back\n        // 3. Flip normal if necessary\n        // 4. Initialize normal range to [-pi, pi] about face normal\n        // 5. Adjust normal range according to adjacent edges\n        // 6. Visit each separating axes, only accept axes within the range\n        // 7. Return if _any_ axis indicates separation\n        // 8. Clip\n        // let m_type1: VertexType;\n        // let m_type2: VertexType;\n        var xf = Transform.mulTXf(xfA, xfB);\n        var centroidB = Transform.mulVec2(xf, polygonB.m_centroid);\n        var v0 = edgeA.m_vertex0;\n        var v1 = edgeA.m_vertex1;\n        var v2 = edgeA.m_vertex2;\n        var v3 = edgeA.m_vertex3;\n        var hasVertex0 = edgeA.m_hasVertex0;\n        var hasVertex3 = edgeA.m_hasVertex3;\n        var edge1 = Vec2.sub(v2, v1);\n        edge1.normalize();\n        var normal1 = Vec2.neo(edge1.y, -edge1.x);\n        var offset1 = Vec2.dot(normal1, Vec2.sub(centroidB, v1));\n        var offset0 = 0.0;\n        var offset2 = 0.0;\n        var convex1 = false;\n        var convex2 = false;\n        var normal0;\n        var normal2;\n        // Is there a preceding edge?\n        if (hasVertex0) {\n            var edge0 = Vec2.sub(v1, v0);\n            edge0.normalize();\n            normal0 = Vec2.neo(edge0.y, -edge0.x);\n            convex1 = Vec2.crossVec2Vec2(edge0, edge1) >= 0.0;\n            offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n        }\n        // Is there a following edge?\n        if (hasVertex3) {\n            var edge2 = Vec2.sub(v3, v2);\n            edge2.normalize();\n            normal2 = Vec2.neo(edge2.y, -edge2.x);\n            convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n            offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n        }\n        var front;\n        var normal = Vec2.zero();\n        var lowerLimit = Vec2.zero();\n        var upperLimit = Vec2.zero();\n        // Determine front or back collision. Determine collision normal limits.\n        if (hasVertex0 && hasVertex3) {\n            if (convex1 && convex2) {\n                front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setVec2(normal2);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n            }\n            else if (convex1) {\n                front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setVec2(normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setMul(-1, normal1);\n                }\n            }\n            else if (convex2) {\n                front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setVec2(normal2);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n            else {\n                front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setVec2(normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n        }\n        else if (hasVertex0) {\n            if (convex1) {\n                front = offset0 >= 0.0 || offset1 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal0);\n                    upperLimit.setMul(-1, normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n            }\n            else {\n                front = offset0 >= 0.0 && offset1 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setVec2(normal1);\n                    upperLimit.setMul(-1, normal0);\n                }\n            }\n        }\n        else if (hasVertex3) {\n            if (convex2) {\n                front = offset1 >= 0.0 || offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal2);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal1);\n                }\n            }\n            else {\n                front = offset1 >= 0.0 && offset2 >= 0.0;\n                if (front) {\n                    normal.setVec2(normal1);\n                    lowerLimit.setMul(-1, normal1);\n                    upperLimit.setVec2(normal1);\n                }\n                else {\n                    normal.setMul(-1, normal1);\n                    lowerLimit.setMul(-1, normal2);\n                    upperLimit.setVec2(normal1);\n                }\n            }\n        }\n        else {\n            front = offset1 >= 0.0;\n            if (front) {\n                normal.setVec2(normal1);\n                lowerLimit.setMul(-1, normal1);\n                upperLimit.setMul(-1, normal1);\n            }\n            else {\n                normal.setMul(-1, normal1);\n                lowerLimit.setVec2(normal1);\n                upperLimit.setVec2(normal1);\n            }\n        }\n        // Get polygonB in frameA\n        polygonBA.count = polygonB.m_count;\n        for (var i = 0; i < polygonB.m_count; ++i) {\n            polygonBA.vertices[i] = Transform.mulVec2(xf, polygonB.m_vertices[i]);\n            polygonBA.normals[i] = Rot.mulVec2(xf.q, polygonB.m_normals[i]);\n        }\n        var radius = 2.0 * Settings.polygonRadius;\n        manifold.pointCount = 0;\n        { // ComputeEdgeSeparation\n            edgeAxis.type = EPAxisType.e_edgeA;\n            edgeAxis.index = front ? 0 : 1;\n            edgeAxis.separation = Infinity;\n            for (var i = 0; i < polygonBA.count; ++i) {\n                var s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1));\n                if (s < edgeAxis.separation) {\n                    edgeAxis.separation = s;\n                }\n            }\n        }\n        // If no valid normal can be found than this edge should not collide.\n        // @ts-ignore\n        if (edgeAxis.type == EPAxisType.e_unknown) {\n            return;\n        }\n        if (edgeAxis.separation > radius) {\n            return;\n        }\n        { // ComputePolygonSeparation\n            polygonAxis.type = EPAxisType.e_unknown;\n            polygonAxis.index = -1;\n            polygonAxis.separation = -Infinity;\n            var perp = Vec2.neo(-normal.y, normal.x);\n            for (var i = 0; i < polygonBA.count; ++i) {\n                var n = Vec2.neg(polygonBA.normals[i]);\n                var s1 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v1));\n                var s2 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v2));\n                var s = math.min(s1, s2);\n                if (s > radius) {\n                    // No collision\n                    polygonAxis.type = EPAxisType.e_edgeB;\n                    polygonAxis.index = i;\n                    polygonAxis.separation = s;\n                    break;\n                }\n                // Adjacency\n                if (Vec2.dot(n, perp) >= 0.0) {\n                    if (Vec2.dot(Vec2.sub(n, upperLimit), normal) < -Settings.angularSlop) {\n                        continue;\n                    }\n                }\n                else {\n                    if (Vec2.dot(Vec2.sub(n, lowerLimit), normal) < -Settings.angularSlop) {\n                        continue;\n                    }\n                }\n                if (s > polygonAxis.separation) {\n                    polygonAxis.type = EPAxisType.e_edgeB;\n                    polygonAxis.index = i;\n                    polygonAxis.separation = s;\n                }\n            }\n        }\n        if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n            return;\n        }\n        // Use hysteresis for jitter reduction.\n        var k_relativeTol = 0.98;\n        var k_absoluteTol = 0.001;\n        var primaryAxis;\n        if (polygonAxis.type == EPAxisType.e_unknown) {\n            primaryAxis = edgeAxis;\n        }\n        else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n            primaryAxis = polygonAxis;\n        }\n        else {\n            primaryAxis = edgeAxis;\n        }\n        var ie = [new ClipVertex(), new ClipVertex()];\n        if (primaryAxis.type == EPAxisType.e_edgeA) {\n            manifold.type = ManifoldType.e_faceA;\n            // Search for the polygon normal that is most anti-parallel to the edge\n            // normal.\n            var bestIndex = 0;\n            var bestValue = Vec2.dot(normal, polygonBA.normals[0]);\n            for (var i = 1; i < polygonBA.count; ++i) {\n                var value = Vec2.dot(normal, polygonBA.normals[i]);\n                if (value < bestValue) {\n                    bestValue = value;\n                    bestIndex = i;\n                }\n            }\n            var i1 = bestIndex;\n            var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n            ie[0].v = polygonBA.vertices[i1];\n            ie[0].id.cf.indexA = 0;\n            ie[0].id.cf.indexB = i1;\n            ie[0].id.cf.typeA = ContactFeatureType.e_face;\n            ie[0].id.cf.typeB = ContactFeatureType.e_vertex;\n            ie[1].v = polygonBA.vertices[i2];\n            ie[1].id.cf.indexA = 0;\n            ie[1].id.cf.indexB = i2;\n            ie[1].id.cf.typeA = ContactFeatureType.e_face;\n            ie[1].id.cf.typeB = ContactFeatureType.e_vertex;\n            if (front) {\n                rf.i1 = 0;\n                rf.i2 = 1;\n                rf.v1 = v1;\n                rf.v2 = v2;\n                rf.normal.setVec2(normal1);\n            }\n            else {\n                rf.i1 = 1;\n                rf.i2 = 0;\n                rf.v1 = v2;\n                rf.v2 = v1;\n                rf.normal.setMul(-1, normal1);\n            }\n        }\n        else {\n            manifold.type = ManifoldType.e_faceB;\n            ie[0].v = v1;\n            ie[0].id.cf.indexA = 0;\n            ie[0].id.cf.indexB = primaryAxis.index;\n            ie[0].id.cf.typeA = ContactFeatureType.e_vertex;\n            ie[0].id.cf.typeB = ContactFeatureType.e_face;\n            ie[1].v = v2;\n            ie[1].id.cf.indexA = 0;\n            ie[1].id.cf.indexB = primaryAxis.index;\n            ie[1].id.cf.typeA = ContactFeatureType.e_vertex;\n            ie[1].id.cf.typeB = ContactFeatureType.e_face;\n            rf.i1 = primaryAxis.index;\n            rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n            rf.v1 = polygonBA.vertices[rf.i1];\n            rf.v2 = polygonBA.vertices[rf.i2];\n            rf.normal.setVec2(polygonBA.normals[rf.i1]);\n        }\n        rf.sideNormal1.setNum(rf.normal.y, -rf.normal.x);\n        rf.sideNormal2.setMul(-1, rf.sideNormal1);\n        rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);\n        rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);\n        // Clip incident edge against extruded edge1 side edges.\n        var clipPoints1 = [new ClipVertex(), new ClipVertex()];\n        var clipPoints2 = [new ClipVertex(), new ClipVertex()];\n        var np;\n        // Clip to box side 1\n        np = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n        if (np < Settings.maxManifoldPoints) {\n            return;\n        }\n        // Clip to negative box side 1\n        np = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n        if (np < Settings.maxManifoldPoints) {\n            return;\n        }\n        // Now clipPoints2 contains the clipped points.\n        if (primaryAxis.type == EPAxisType.e_edgeA) {\n            manifold.localNormal = Vec2.clone(rf.normal);\n            manifold.localPoint = Vec2.clone(rf.v1);\n        }\n        else {\n            manifold.localNormal = Vec2.clone(polygonB.m_normals[rf.i1]);\n            manifold.localPoint = Vec2.clone(polygonB.m_vertices[rf.i1]);\n        }\n        var pointCount = 0;\n        for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n            var separation = Vec2.dot(rf.normal, Vec2.sub(clipPoints2[i].v, rf.v1));\n            if (separation <= radius) {\n                var cp = manifold.points[pointCount]; // ManifoldPoint\n                if (primaryAxis.type == EPAxisType.e_edgeA) {\n                    cp.localPoint = Transform.mulTVec2(xf, clipPoints2[i].v);\n                    cp.id = clipPoints2[i].id;\n                }\n                else {\n                    cp.localPoint = clipPoints2[i].v;\n                    cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\n                    cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\n                    cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\n                    cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\n                }\n                ++pointCount;\n            }\n        }\n        manifold.pointCount = pointCount;\n    }\n\n    /** @deprecated Merged with main namespace */\n    var internal = {};\n    // @ts-ignore\n    internal.CollidePolygons = CollidePolygons;\n    // @ts-ignore\n    internal.Settings = Settings;\n    // @ts-ignore\n    internal.Sweep = Sweep;\n    // @ts-ignore\n    internal.Manifold = Manifold;\n    // @ts-ignore\n    internal.Distance = Distance;\n    // @ts-ignore\n    internal.TimeOfImpact = TimeOfImpact;\n    // @ts-ignore\n    internal.DynamicTree = DynamicTree;\n    // @ts-ignore\n    internal.stats = stats;\n    // @ts-ignore\n    Solver.TimeStep = TimeStep;\n    // @ts-ignore\n    Distance.testOverlap = testOverlap;\n    // @ts-ignore\n    Distance.Input = DistanceInput;\n    // @ts-ignore\n    Distance.Output = DistanceOutput;\n    // @ts-ignore\n    Distance.Proxy = DistanceProxy;\n    // @ts-ignore\n    Distance.Cache = SimplexCache;\n    // @ts-ignore\n    TimeOfImpact.Input = TOIInput;\n    // @ts-ignore\n    TimeOfImpact.Output = TOIOutput;\n\n    exports.AABB = AABB;\n    exports.Body = Body;\n    exports.Box = BoxShape;\n    exports.Chain = ChainShape;\n    exports.Circle = CircleShape;\n    exports.CollideCircles = CollideCircles;\n    exports.CollideEdgeCircle = CollideEdgeCircle;\n    exports.CollideEdgePolygon = CollideEdgePolygon;\n    exports.CollidePolygonCircle = CollidePolygonCircle;\n    exports.CollidePolygons = CollidePolygons;\n    exports.Contact = Contact;\n    exports.Distance = Distance;\n    exports.DistanceJoint = DistanceJoint;\n    exports.DynamicTree = DynamicTree;\n    exports.Edge = EdgeShape;\n    exports.Fixture = Fixture;\n    exports.FrictionJoint = FrictionJoint;\n    exports.GearJoint = GearJoint;\n    exports.Joint = Joint;\n    exports.Manifold = Manifold;\n    exports.Mat22 = Mat22;\n    exports.Mat33 = Mat33;\n    exports.Math = math;\n    exports.MotorJoint = MotorJoint;\n    exports.MouseJoint = MouseJoint;\n    exports.Polygon = PolygonShape;\n    exports.PrismaticJoint = PrismaticJoint;\n    exports.PulleyJoint = PulleyJoint;\n    exports.RevoluteJoint = RevoluteJoint;\n    exports.RopeJoint = RopeJoint;\n    exports.Rot = Rot;\n    exports.Serializer = Serializer;\n    exports.Settings = Settings;\n    exports.Shape = Shape;\n    exports.Sweep = Sweep;\n    exports.TimeOfImpact = TimeOfImpact;\n    exports.Transform = Transform;\n    exports.Vec2 = Vec2;\n    exports.Vec3 = Vec3;\n    exports.WeldJoint = WeldJoint;\n    exports.WheelJoint = WheelJoint;\n    exports.World = World;\n    exports.internal = internal;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=planck.js.map\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","export default function<T>(input: T, defaults: object): T {\n  if (input === null || typeof input === 'undefined') {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    input = {} as T;\n  }\n\n  const output = {...input};\n\n  // tslint:disable-next-line:no-for-in\n  for (const key in defaults) {\n    if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {\n      output[key] = defaults[key];\n    }\n  }\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    const symbols = Object.getOwnPropertySymbols(defaults);\n    for (let i = 0; i < symbols.length; i++) {\n      const symbol = symbols[i];\n      if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {\n        output[symbol] = defaults[symbol];\n      }\n    }\n  }\n\n  return output;\n}\n","const _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nexport const debug = function(...rest: any[]): void {\n  if (!_DEBUG) return;\n  console.log.apply(console, arguments);\n};\n\nexport const assert = function(statement: boolean, err?: string, log?: any): void {\n  if (!_ASSERT) return;\n  if (statement) return;\n  log && console.log(log);\n  throw new Error(err);\n};\n\nexport default {\n  assert,\n  debug,\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst math: Math & {\n  readonly EPSILON: number;\n  /**\n   * This function is used to ensure that a floating point number is not a NaN or\n   * infinity.\n   */\n  isFinite(x: any): boolean;\n  assert(x: any): void;\n  /**\n   * This is a approximate yet fast inverse square-root (todo).\n   */\n  invSqrt(x: number): number;\n  /**\n   * Next Largest Power of 2 Given a binary integer value x, the next largest\n   * power of 2 can be computed by a SWAR algorithm that recursively \"folds\" the\n   * upper bits into the lower bits. This process yields a bit vector with the\n   * same most significant 1 as x, but all 1's below it. Adding 1 to that value\n   * yields the next largest power of 2. For a 32-bit value:\n   */\n  nextPowerOfTwo(x: number): number;\n  isPowerOfTwo(x: number): boolean;\n  mod(num: number, min?: number, max?: number): number;\n  /**\n   * Returns a min if num is less than min, and max if more than max, otherwise returns num.\n   */\n  clamp(num: number, min: number, max: number): number;\n  /**\n   * Returns a random number between min and max when two arguments are provided.\n   * If one arg is provided between 0 to max.\n   * If one arg is passed between 0 to 1.\n   */\n  random(min?: number, max?: number): number;\n} = Object.create(Math);\n\nexport default math;\n\n// @ts-ignore\n// noinspection JSConstantReassignment\nmath.EPSILON = 1e-9; // TODO\n\nmath.isFinite = function(x: unknown): boolean {\n  return (typeof x === 'number') && isFinite(x) && !isNaN(x);\n};\n\nmath.assert = function(x: any): void {\n  if (!_ASSERT) return;\n  if (!math.isFinite(x)) {\n    _DEBUG && common.debug(x);\n    throw new Error('Invalid Number!');\n  }\n};\n\nmath.invSqrt = function(x: number): number {\n  // TODO:\n  return 1 / Math.sqrt(x);\n};\n\nmath.nextPowerOfTwo = function(x: number): number {\n  // TODO\n  x |= (x >> 1);\n  x |= (x >> 2);\n  x |= (x >> 4);\n  x |= (x >> 8);\n  x |= (x >> 16);\n  return x + 1;\n};\n\nmath.isPowerOfTwo = function(x: number): boolean {\n  return x > 0 && (x & (x - 1)) === 0;\n};\n\nmath.mod = function(num: number, min?: number, max?: number): number {\n  if (typeof min === 'undefined') {\n    max = 1;\n    min = 0;\n  } else if (typeof max === 'undefined') {\n    max = min;\n    min = 0;\n  }\n  if (max > min) {\n    num = (num - min) % (max - min);\n    return num + (num < 0 ? max : min);\n  } else {\n    num = (num - max) % (min - max);\n    return num + (num <= 0 ? min : max);\n  }\n};\n\nmath.clamp = function(num: number, min: number, max: number): number {\n  if (num < min) {\n    return min;\n  } else if (num > max) {\n    return max;\n  } else {\n    return num;\n  }\n};\n\nmath.random = function(min?: number, max?: number): number {\n  if (typeof min === 'undefined') {\n    max = 1;\n    min = 0;\n  } else if (typeof max === 'undefined') {\n    max = min;\n    min = 0;\n  }\n  return min === max ? min : Math.random() * (max - min) + min;\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Math from './Math';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport default class Vec2 {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number);\n  constructor(obj: { x: number, y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?) {\n    if (!(this instanceof Vec2)) {\n      return new Vec2(x, y);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n    _ASSERT && Vec2.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    return obj;\n  }\n\n  static zero(): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = x;\n    obj.y = y;\n    return obj;\n  }\n\n  static clone(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(v.x, v.y);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Vec2.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Vec2!');\n    }\n  }\n\n  clone(): Vec2 {\n    return Vec2.clone(this);\n  }\n\n  /**\n   * Set this vector to all zeros.\n   *\n   * @returns this\n   */\n  setZero(): Vec2 {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number): Vec2;\n  set(value: Vec2): Vec2;\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  // tslint:disable-next-line:typedef\n  set(x, y?) {\n    if (typeof x === 'object') {\n      _ASSERT && Vec2.assert(x);\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      _ASSERT && Math.assert(x);\n      _ASSERT && Math.assert(y);\n      this.x = x;\n      this.y = y;\n    }\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n   setNum(x: number, y: number) {\n    _ASSERT && Math.assert(x);\n    _ASSERT && Math.assert(y);\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  setVec2(value: Vec2) {\n    _ASSERT && Vec2.assert(value);\n    this.x = value.x;\n    this.y = value.y;\n\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use setCombine or setMul\n   */\n  wSet(a: number, v: Vec2, b?: number, w?: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.setCombine(a, v, b, w);\n    } else {\n      return this.setMul(a, v);\n    }\n  }\n\n  /**\n   * Set linear combination of v and w: `a * v + b * w`\n   */\n  setCombine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  setMul(a: number, v: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * Add a vector to this vector.\n   *\n   * @returns this\n   */\n  add(w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x += w.x;\n    this.y += w.y;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Use addCombine or addMul\n   */\n  wAdd(a: number, v: Vec2, b?: number, w?: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.addCombine(a, v, b, w);\n    } else {\n      return this.addMul(a, v);\n    }\n  }\n\n  /**\n   * Add linear combination of v and w: `a * v + b * w`\n   */\n  addCombine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  addMul(a: number, v: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  /**\n   * @deprecated Use subCombine or subMul\n   */\n  wSub(a: number, v: Vec2, b?: number, w?: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.subCombine(a, v, b, w);\n    } else {\n      return this.subMul(a, v);\n    }}\n\n  /**\n   * Subtract linear combination of v and w: `a * v + b * w`\n   */\n  subCombine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(b);\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  subMul(a: number, v: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  /**\n   * Subtract a vector from this vector\n   *\n   * @returns this\n   */\n  sub(w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x -= w.x;\n    this.y -= w.y;\n    return this;\n  }\n\n  /**\n   * Multiply this vector by a scalar.\n   *\n   * @returns this\n   */\n  mul(m: number): Vec2 {\n    _ASSERT && Math.assert(m);\n    this.x *= m;\n    this.y *= m;\n    return this;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  length(): number {\n    return Vec2.lengthOf(this);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  lengthSquared(): number {\n    return Vec2.lengthSquared(this);\n  }\n\n  /**\n   * Convert this vector into a unit vector.\n   *\n   * @returns old length\n   */\n  normalize(): number {\n    const length = this.length();\n    if (length < Math.EPSILON) {\n      return 0.0;\n    }\n    const invLength = 1.0 / length;\n    this.x *= invLength;\n    this.y *= invLength;\n    return length;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  static lengthOf(v: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    return Math.sqrt(v.x * v.x + v.y * v.y);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  static lengthSquared(v: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    return v.x * v.x + v.y * v.y;\n  }\n\n  static distance(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  static distanceSquared(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return dx * dx + dy * dy;\n  }\n\n  static areEqual(v: Vec2, w: Vec2): boolean {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;\n  }\n\n  /**\n   * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n   */\n  static skew(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.y, v.x);\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.x + v.y * w.y;\n  }\n\n  static cross(v: Vec2, w: Vec2): number;\n  static cross(v: Vec2, w: number): Vec2;\n  static cross(v: number, w: Vec2): Vec2;\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   *\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  // tslint:disable-next-line:typedef\n  static cross(v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y, -w * v.x);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y, v * w.x);\n\n    } else {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return v.x * w.y - v.y * w.x;\n    }\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static crossVec2Vec2(v: Vec2, w: Vec2): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.y - v.y * w.x;\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossVec2Num(v: Vec2, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y, -w * v.x);\n  }\n\n  /**\n   * Perform the cross product on a vector and a scalar. In 2D this produces a\n   * vector.\n   */\n  static crossNumVec2(v: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y, v * w.x);\n  }\n\n  static addCross(a: Vec2, v: Vec2, w: number): Vec2;\n  static addCross(a: Vec2, v: number, w: Vec2): Vec2;\n  /**\n   * Returns `a + (v x w)`\n   */\n  // tslint:disable-next-line:typedef\n  static addCross(a, v, w) {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Math.assert(w);\n      return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && Math.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossVec2Num(a: Vec2, v: Vec2, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Math.assert(w);\n    return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossNumVec2(a: Vec2, v: number, w: Vec2): Vec2 {\n    _ASSERT && Math.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n  }\n\n  static add(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x + w.x, v.y + w.y);\n  }\n\n  /** @internal @deprecated */\n  static wAdd(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return Vec2.combine(a, v, b, w);\n    } else {\n      return Vec2.mulNumVec2(a, v);\n    }\n  }\n\n  static combine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    return Vec2.zero().setCombine(a, v, b, w);\n  }\n\n  static sub(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x - w.x, v.y - w.y);\n  }\n\n  static mul(a: Vec2, b: number): Vec2;\n  static mul(a: number, b: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (typeof a === 'object') {\n      _ASSERT && Vec2.assert(a);\n      _ASSERT && Math.assert(b);\n      return Vec2.neo(a.x * b, a.y * b);\n\n    } else if (typeof b === 'object') {\n      _ASSERT && Math.assert(a);\n      _ASSERT && Vec2.assert(b);\n      return Vec2.neo(a * b.x, a * b.y);\n    }\n  }\n\n  static mulVec2Num(a: Vec2, b: number): Vec2 {\n    _ASSERT && Vec2.assert(a);\n    _ASSERT && Math.assert(b);\n    return Vec2.neo(a.x * b, a.y * b);\n  }\n\n  static mulNumVec2(a: number, b: Vec2): Vec2 {\n    _ASSERT && Math.assert(a);\n    _ASSERT && Vec2.assert(b);\n    return Vec2.neo(a * b.x, a * b.y);\n  }\n\n  neg(): Vec2 {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  static neg(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.x, -v.y);\n  }\n\n  static abs(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Math.abs(v.x), Math.abs(v.y));\n  }\n\n  static mid(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n  }\n\n  static upper(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.max(v.x, w.x), Math.max(v.y, w.y));\n  }\n\n  static lower(v: Vec2, w: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(Math.min(v.x, w.x), Math.min(v.y, w.y));\n  }\n\n  clamp(max: number): Vec2 {\n    const lengthSqr = this.x * this.x + this.y * this.y;\n    if (lengthSqr > max * max) {\n      const invLength = Math.invSqrt(lengthSqr);\n      this.x *= invLength * max;\n      this.y *= invLength * max;\n    }\n    return this;\n  }\n\n  static clamp(v: Vec2, max: number): Vec2 {\n    v = Vec2.neo(v.x, v.y);\n    v.clamp(max);\n    return v;\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static scaleFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x * x, v.y * y);\n    };\n  }\n\n  /**  @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static translateFn(x: number, y: number) {\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x + x, v.y + y);\n    };\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Math from '../common/Math';\nimport Vec2 from '../common/Vec2';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n */\nexport interface RayCastInput {\n  p1: Vec2;\n  p2: Vec2;\n  maxFraction: number;\n}\n\nexport type RayCastCallback = (subInput: RayCastInput, id: number) => number;\n\n/**\n * Ray-cast output data. The ray hits at `p1 + fraction * (p2 - p1)`,\n * where `p1` and `p2` come from RayCastInput.\n */\nexport interface RayCastOutput {\n  normal: Vec2;\n  fraction: number;\n}\n\nexport default class AABB {\n  lowerBound: Vec2;\n  upperBound: Vec2;\n\n  constructor(lower?: Vec2, upper?: Vec2) {\n    if (!(this instanceof AABB)) {\n      return new AABB(lower, upper);\n    }\n\n    this.lowerBound = Vec2.zero();\n    this.upperBound = Vec2.zero();\n\n    if (typeof lower === 'object') {\n      this.lowerBound.setVec2(lower);\n    }\n    if (typeof upper === 'object') {\n      this.upperBound.setVec2(upper);\n    } else if (typeof lower === 'object') {\n      this.upperBound.setVec2(lower);\n    }\n  }\n\n  /**\n   * Verify that the bounds are sorted.\n   */\n  isValid(): boolean {\n    return AABB.isValid(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!AABB.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid AABB!');\n    }\n  }\n\n  /**\n   * Get the center of the AABB.\n   */\n  getCenter(): Vec2 {\n    return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n  }\n\n  /**\n   * Get the extents of the AABB (half-widths).\n   */\n  getExtents(): Vec2 {\n    return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n  }\n\n  /**\n   * Get the perimeter length.\n   */\n  getPerimeter(): number {\n    return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n  }\n\n  /**\n   * Combine one or two AABB into this one.\n   */\n  combine(a: AABB, b?: AABB): void {\n    b = b || this;\n\n    const lowerA = a.lowerBound;\n    const upperA = a.upperBound;\n    const lowerB = b.lowerBound;\n    const upperB = b.upperBound;\n\n    const lowerX = Math.min(lowerA.x, lowerB.x);\n    const lowerY = Math.min(lowerA.y, lowerB.y);\n    const upperX = Math.max(upperB.x, upperA.x);\n    const upperY = Math.max(upperB.y, upperA.y);\n\n    this.lowerBound.setNum(lowerX, lowerY);\n    this.upperBound.setNum(upperX, upperY);\n  }\n\n  combinePoints(a: Vec2, b: Vec2): void {\n    this.lowerBound.setNum(Math.min(a.x, b.x), Math.min(a.y, b.y));\n    this.upperBound.setNum(Math.max(a.x, b.x), Math.max(a.y, b.y));\n  }\n\n  set(aabb: AABB): void {\n    this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n    this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n  }\n\n  contains(aabb: AABB): boolean {\n    let result = true;\n    result = result && this.lowerBound.x <= aabb.lowerBound.x;\n    result = result && this.lowerBound.y <= aabb.lowerBound.y;\n    result = result && aabb.upperBound.x <= this.upperBound.x;\n    result = result && aabb.upperBound.y <= this.upperBound.y;\n    return result;\n  }\n\n  extend(value: number): AABB {\n    AABB.extend(this, value);\n    return this;\n  }\n\n  static extend(aabb: AABB, value: number): void {\n    aabb.lowerBound.x -= value;\n    aabb.lowerBound.y -= value;\n    aabb.upperBound.x += value;\n    aabb.upperBound.y += value;\n  }\n\n  static testOverlap(a: AABB, b: AABB): boolean {\n    const d1x = b.lowerBound.x - a.upperBound.x;\n    const d2x = a.lowerBound.x - b.upperBound.x;\n\n    const d1y = b.lowerBound.y - a.upperBound.y;\n    const d2y = a.lowerBound.y - b.upperBound.y;\n\n    if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n      return false;\n    }\n    return true;\n  }\n\n  static areEqual(a: AABB, b: AABB): boolean {\n    return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n  }\n\n  static diff(a: AABB, b: AABB): number {\n    const wD = Math.max(0, Math.min(a.upperBound.x, b.upperBound.x) - Math.max(b.lowerBound.x, a.lowerBound.x));\n    const hD = Math.max(0, Math.min(a.upperBound.y, b.upperBound.y) - Math.max(b.lowerBound.y, a.lowerBound.y));\n\n    const wA = a.upperBound.x - a.lowerBound.x;\n    const hA = a.upperBound.y - a.lowerBound.y;\n\n    const wB = b.upperBound.x - b.lowerBound.x;\n    const hB = b.upperBound.y - b.lowerBound.y;\n\n    return wA * hA + wB * hB - wD * hD;\n  }\n\n  rayCast(output: RayCastOutput, input: RayCastInput): boolean {\n    // From Real-time Collision Detection, p179.\n\n    let tmin = -Infinity;\n    let tmax = Infinity;\n\n    const p = input.p1;\n    const d = Vec2.sub(input.p2, input.p1);\n    const absD = Vec2.abs(d);\n\n    const normal = Vec2.zero();\n\n    for (let f: 'x' | 'y' = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {\n      if (absD.x < Math.EPSILON) {\n        // Parallel.\n        if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n          return false;\n        }\n      } else {\n        const inv_d = 1.0 / d[f];\n        let t1 = (this.lowerBound[f] - p[f]) * inv_d;\n        let t2 = (this.upperBound[f] - p[f]) * inv_d;\n\n        // Sign of the normal vector.\n        let s = -1.0;\n\n        if (t1 > t2) {\n          const temp = t1;\n          t1 = t2;\n          t2 = temp;\n          s = 1.0;\n        }\n\n        // Push the min up\n        if (t1 > tmin) {\n          normal.setZero();\n          normal[f] = s;\n          tmin = t1;\n        }\n\n        // Pull the max down\n        tmax = Math.min(tmax, t2);\n\n        if (tmin > tmax) {\n          return false;\n        }\n      }\n    }\n\n    // Does the ray start inside the box?\n    // Does the ray intersect beyond the max fraction?\n    if (tmin < 0.0 || input.maxFraction < tmin) {\n      return false;\n    }\n\n    // Intersection.\n    output.fraction = tmin;\n    output.normal = normal;\n    return true;\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n// TODO merge with World options?\n\n/**\n * Tuning constants based on meters-kilograms-seconds (MKS) units.\n */\n// tslint:disable-next-line:no-unnecessary-class\nexport default class Settings {\n  // Collision\n  /**\n   * The maximum number of contact points between two convex shapes. Do not change\n   * this value.\n   */\n  static maxManifoldPoints: number = 2;\n\n  /**\n   * The maximum number of vertices on a convex polygon. You cannot increase this\n   * too much because BlockAllocator has a maximum object size.\n   */\n  static maxPolygonVertices: number = 12;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n   * by a small amount without triggering a tree adjustment. This is in meters.\n   */\n  static aabbExtension: number = 0.1;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n   * future position based on the current displacement. This is a dimensionless\n   * multiplier.\n   */\n  static aabbMultiplier: number = 2.0;\n\n  /**\n   * A small length used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static linearSlop: number = 0.005;\n  static get linearSlopSquared(): number { return Settings.linearSlop * Settings.linearSlop; }\n\n  /**\n   * A small angle used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static angularSlop: number = (2.0 / 180.0 * Math.PI);\n\n  /**\n   * The radius of the polygon/edge shape skin. This should not be modified.\n   * Making this smaller means polygons will have an insufficient buffer for\n   * continuous collision. Making it larger may create artifacts for vertex\n   * collision.\n   */\n  static get polygonRadius(): number { return 2.0 * Settings.linearSlop; }\n\n  /**\n   * Maximum number of sub-steps per contact in continuous physics simulation.\n   */\n  static maxSubSteps: number = 8;\n\n// Dynamics\n\n  /**\n   * Maximum number of contacts to be handled to solve a TOI impact.\n   */\n  static maxTOIContacts: number = 32;\n\n  /**\n   * Maximum iterations to solve a TOI.\n   */\n  static maxTOIIterations: number = 20;\n\n  /**\n   * Maximum iterations to find Distance.\n   */\n  static maxDistnceIterations: number = 20;\n\n  /**\n   * A velocity threshold for elastic collisions. Any collision with a relative\n   * linear velocity below this threshold will be treated as inelastic.\n   */\n  static velocityThreshold: number = 1.0;\n\n  /**\n   * The maximum linear position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxLinearCorrection: number = 0.2;\n\n  /**\n   * The maximum angular position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxAngularCorrection: number = (8.0 / 180.0 * Math.PI);\n\n  /**\n   * The maximum linear velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxTranslation: number = 2.0;\n  static get maxTranslationSquared(): number { return Settings.maxTranslation * Settings.maxTranslation; }\n\n  /**\n   * The maximum angular velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxRotation: number = (0.5 * Math.PI);\n  static get maxRotationSquared(): number { return Settings.maxRotation * Settings.maxRotation; }\n\n  /**\n   * This scale factor controls how fast overlap is resolved. Ideally this would\n   * be 1 so that overlap is removed in one time step. However using values close\n   * to 1 often lead to overshoot.\n   */\n  static baumgarte: number = 0.2;\n  static toiBaugarte: number = 0.75;\n\n  // Sleep\n\n  /**\n   * The time that a body must be still before it will go to sleep.\n   */\n  static timeToSleep: number = 0.5;\n\n  /**\n   * A body cannot sleep if its linear velocity is above this tolerance.\n   */\n  static linearSleepTolerance: number = 0.01;\n  static get linearSleepToleranceSqr(): number { return Math.pow(Settings.linearSleepTolerance, 2); }\n\n  /**\n   * A body cannot sleep if its angular velocity is above this tolerance.\n   */\n  static angularSleepTolerance: number = (2.0 / 180.0 * Math.PI);\n  static get angularSleepToleranceSqr(): number { return Math.pow(Settings.angularSleepTolerance, 2); }\n\n}\n","/*\n * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgment in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\nexport default class Pool<T> {\n  _list: T[] = [];\n  _max: number = Infinity;\n\n  _createFn: () => T;\n  _outFn: (item: T) => void;\n  _inFn: (item: T) => void;\n  _discardFn: (item: T) => T;\n\n  _createCount: number = 0;\n  _outCount: number = 0;\n  _inCount: number = 0;\n  _discardCount: number = 0;\n\n  constructor(opts: {\n    max?: number,\n    create?: () => T,\n    allocate?: (item: T) => void,\n    release?: (item: T) => void,\n    discard?: (item: T) => T,\n  }) {\n    this._list = [];\n    this._max = opts.max || this._max;\n\n    this._createFn = opts.create;\n    this._outFn = opts.allocate;\n    this._inFn = opts.release;\n    this._discardFn = opts.discard;\n  }\n\n  max(n?: number): number | Pool<T> {\n    if (typeof n === 'number') {\n      this._max = n;\n      return this;\n    }\n    return this._max;\n  }\n\n  size(): number {\n    return this._list.length;\n  }\n\n  allocate(): T {\n    let item: T;\n    if (this._list.length > 0) {\n      item = this._list.shift();\n    } else {\n      this._createCount++;\n      if (typeof this._createFn === 'function') {\n        item = this._createFn();\n      } else {\n        // tslint:disable-next-line:no-object-literal-type-assertion\n        item = {} as T;\n      }\n    }\n    this._outCount++;\n    if (typeof this._outFn === 'function') {\n      this._outFn(item);\n    }\n    return item;\n  }\n\n  release(item: T): void {\n    if (this._list.length < this._max) {\n      this._inCount++;\n      if (typeof this._inFn === 'function') {\n        this._inFn(item);\n      }\n      this._list.push(item);\n    } else {\n      this._discardCount++;\n      if (typeof this._discardFn === 'function') {\n        item = this._discardFn(item);\n      }\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return \" +\" + this._createCount + \" >\" + this._outCount + \" <\" + this._inCount + \" -\"\n      + this._discardCount + \" =\" + this._list.length + \"/\" + this._max;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Settings from '../Settings';\nimport common from '../util/common';\nimport Pool from '../util/Pool';\nimport Vec2 from '../common/Vec2';\nimport Math from '../common/Math';\nimport AABB, { RayCastCallback, RayCastInput } from './AABB';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport type DynamicTreeQueryCallback = (nodeId: number) => boolean;\n\n/**\n * A node in the dynamic tree. The client does not interact with this directly.\n */\nexport class TreeNode<T> {\n  id: number;\n  /** Enlarged AABB */\n  aabb: AABB = new AABB();\n  userData: T = null;\n  parent: TreeNode<T> = null;\n  child1: TreeNode<T> = null;\n  child2: TreeNode<T> = null;\n  /** 0: leaf, -1: free node */\n  height: number = -1;\n\n  constructor(id?: number) {\n    this.id = id;\n  }\n\n  /** @internal */\n  toString(): string {\n    return this.id + \": \" + this.userData;\n  }\n\n  isLeaf(): boolean {\n    return this.child1 == null;\n  }\n}\n\n/**\n * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n * dynamic tree arranges data in a binary tree to accelerate queries such as\n * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n * than the client object. This allows the client object to move by small\n * amounts without triggering a tree update.\n *\n * Nodes are pooled and relocatable, so we use node indices rather than\n * pointers.\n */\nexport default class DynamicTree<T> {\n  m_root: TreeNode<T>;\n  m_lastProxyId: number;\n  m_nodes: {\n    [id: number]: TreeNode<T>\n  };\n  m_pool: Pool<TreeNode<T>>;\n\n  constructor() {\n    this.m_root = null;\n    this.m_nodes = {};\n    this.m_lastProxyId = 0;\n\n    this.m_pool = new Pool<TreeNode<T>>({\n      create(): TreeNode<T> {\n        return new TreeNode();\n      }\n    });\n  }\n\n  /**\n   * Get proxy user data.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getUserData(id: number): T {\n    const node = this.m_nodes[id];\n    _ASSERT && common.assert(!!node);\n    return node.userData;\n  }\n\n  /**\n   * Get the fat AABB for a node id.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getFatAABB(id: number): AABB {\n    const node = this.m_nodes[id];\n    _ASSERT && common.assert(!!node);\n    return node.aabb;\n  }\n\n  allocateNode(): TreeNode<T> {\n    const node = this.m_pool.allocate();\n    node.id = ++this.m_lastProxyId;\n    node.userData = null;\n    node.parent = null;\n    node.child1 = null;\n    node.child2 = null;\n    node.height = -1;\n    this.m_nodes[node.id] = node;\n    return node;\n  }\n\n  freeNode(node: TreeNode<T>): void {\n    this.m_pool.release(node);\n    node.height = -1;\n    // tslint:disable-next-line:no-dynamic-delete\n    delete this.m_nodes[node.id];\n  }\n\n  /**\n   * Create a proxy in the tree as a leaf node. We return the index of the node\n   * instead of a pointer so that we can grow the node pool.\n   *\n   * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n   */\n  createProxy(aabb: AABB, userData: T): number {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n\n    const node = this.allocateNode();\n\n    node.aabb.set(aabb);\n\n    // Fatten the aabb.\n    AABB.extend(node.aabb, Settings.aabbExtension);\n\n    node.userData = userData;\n    node.height = 0;\n\n    this.insertLeaf(node);\n\n    return node.id;\n  }\n\n  /**\n   * Destroy a proxy. This asserts if the id is invalid.\n   */\n  destroyProxy(id: number): void {\n    const node = this.m_nodes[id];\n\n    _ASSERT && common.assert(!!node);\n    _ASSERT && common.assert(node.isLeaf());\n\n    this.removeLeaf(node);\n    this.freeNode(node);\n  }\n\n  /**\n   * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n   * fattened AABB, then the proxy is removed from the tree and re-inserted.\n   * Otherwise the function returns immediately.\n   *\n   * @param d Displacement\n   *\n   * @return true if the proxy was re-inserted.\n   */\n  moveProxy(id: number, aabb: AABB, d: Vec2): boolean {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n    _ASSERT && common.assert(!d || Vec2.isValid(d));\n\n    const node = this.m_nodes[id];\n\n    _ASSERT && common.assert(!!node);\n    _ASSERT && common.assert(node.isLeaf());\n\n    if (node.aabb.contains(aabb)) {\n      return false;\n    }\n\n    this.removeLeaf(node);\n\n    node.aabb.set(aabb);\n\n    // Extend AABB.\n    aabb = node.aabb;\n    AABB.extend(aabb, Settings.aabbExtension);\n\n    // Predict AABB displacement.\n    // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n\n    if (d.x < 0.0) {\n      aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n    }\n\n    if (d.y < 0.0) {\n      aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n    }\n\n    this.insertLeaf(node);\n\n    return true;\n  }\n\n  insertLeaf(leaf: TreeNode<T>): void {\n    _ASSERT && common.assert(AABB.isValid(leaf.aabb));\n\n    if (this.m_root == null) {\n      this.m_root = leaf;\n      this.m_root.parent = null;\n      return;\n    }\n\n    // Find the best sibling for this node\n    const leafAABB = leaf.aabb;\n    let index = this.m_root;\n    while (!index.isLeaf()) {\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      const area = index.aabb.getPerimeter();\n\n      const combinedAABB = new AABB();\n      combinedAABB.combine(index.aabb, leafAABB);\n      const combinedArea = combinedAABB.getPerimeter();\n\n      // Cost of creating a new parent for this node and the new leaf\n      const cost = 2.0 * combinedArea;\n\n      // Minimum cost of pushing the leaf further down the tree\n      const inheritanceCost = 2.0 * (combinedArea - area);\n\n      // Cost of descending into child1\n      let cost1;\n      if (child1.isLeaf()) {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child1.aabb);\n        cost1 = aabb.getPerimeter() + inheritanceCost;\n      } else {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child1.aabb);\n        const oldArea = child1.aabb.getPerimeter();\n        const newArea = aabb.getPerimeter();\n        cost1 = (newArea - oldArea) + inheritanceCost;\n      }\n\n      // Cost of descending into child2\n      let cost2;\n      if (child2.isLeaf()) {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child2.aabb);\n        cost2 = aabb.getPerimeter() + inheritanceCost;\n      } else {\n        const aabb = new AABB();\n        aabb.combine(leafAABB, child2.aabb);\n        const oldArea = child2.aabb.getPerimeter();\n        const newArea = aabb.getPerimeter();\n        cost2 = newArea - oldArea + inheritanceCost;\n      }\n\n      // Descend according to the minimum cost.\n      if (cost < cost1 && cost < cost2) {\n        break;\n      }\n\n      // Descend\n      if (cost1 < cost2) {\n        index = child1;\n      } else {\n        index = child2;\n      }\n    }\n\n    const sibling = index;\n\n    // Create a new parent.\n    const oldParent = sibling.parent;\n    const newParent = this.allocateNode();\n    newParent.parent = oldParent;\n    newParent.userData = null;\n    newParent.aabb.combine(leafAABB, sibling.aabb);\n    newParent.height = sibling.height + 1;\n\n    if (oldParent != null) {\n      // The sibling was not the root.\n      if (oldParent.child1 === sibling) {\n        oldParent.child1 = newParent;\n      } else {\n        oldParent.child2 = newParent;\n      }\n\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n    } else {\n      // The sibling was the root.\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n      this.m_root = newParent;\n    }\n\n    // Walk back up the tree fixing heights and AABBs\n    index = leaf.parent;\n    while (index != null) {\n      index = this.balance(index);\n\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      _ASSERT && common.assert(child1 != null);\n      _ASSERT && common.assert(child2 != null);\n\n      index.height = 1 + Math.max(child1.height, child2.height);\n      index.aabb.combine(child1.aabb, child2.aabb);\n\n      index = index.parent;\n    }\n\n    // validate();\n  }\n\n  removeLeaf(leaf: TreeNode<T>): void {\n    if (leaf === this.m_root) {\n      this.m_root = null;\n      return;\n    }\n\n    const parent = leaf.parent;\n    const grandParent = parent.parent;\n    let sibling;\n    if (parent.child1 === leaf) {\n      sibling = parent.child2;\n    } else {\n      sibling = parent.child1;\n    }\n\n    if (grandParent != null) {\n      // Destroy parent and connect sibling to grandParent.\n      if (grandParent.child1 === parent) {\n        grandParent.child1 = sibling;\n      } else {\n        grandParent.child2 = sibling;\n      }\n      sibling.parent = grandParent;\n      this.freeNode(parent);\n\n      // Adjust ancestor bounds.\n      let index = grandParent;\n      while (index != null) {\n        index = this.balance(index);\n\n        const child1 = index.child1;\n        const child2 = index.child2;\n\n        index.aabb.combine(child1.aabb, child2.aabb);\n        index.height = 1 + Math.max(child1.height, child2.height);\n\n        index = index.parent;\n      }\n    } else {\n      this.m_root = sibling;\n      sibling.parent = null;\n      this.freeNode(parent);\n    }\n\n    // validate();\n  }\n\n  /**\n   * Perform a left or right rotation if node A is imbalanced. Returns the new\n   * root index.\n   */\n  balance(iA: TreeNode<T>): TreeNode<T> {\n    _ASSERT && common.assert(iA != null);\n\n    const A = iA;\n    if (A.isLeaf() || A.height < 2) {\n      return iA;\n    }\n\n    const B = A.child1;\n    const C = A.child2;\n\n    const balance = C.height - B.height;\n\n    // Rotate C up\n    if (balance > 1) {\n      const F = C.child1;\n      const G = C.child2;\n\n      // Swap A and C\n      C.child1 = A;\n      C.parent = A.parent;\n      A.parent = C;\n\n      // A's old parent should point to C\n      if (C.parent != null) {\n        if (C.parent.child1 === iA) {\n          C.parent.child1 = C;\n        } else {\n          C.parent.child2 = C;\n        }\n      } else {\n        this.m_root = C;\n      }\n\n      // Rotate\n      if (F.height > G.height) {\n        C.child2 = F;\n        A.child2 = G;\n        G.parent = A;\n        A.aabb.combine(B.aabb, G.aabb);\n        C.aabb.combine(A.aabb, F.aabb);\n\n        A.height = 1 + Math.max(B.height, G.height);\n        C.height = 1 + Math.max(A.height, F.height);\n      } else {\n        C.child2 = G;\n        A.child2 = F;\n        F.parent = A;\n        A.aabb.combine(B.aabb, F.aabb);\n        C.aabb.combine(A.aabb, G.aabb);\n\n        A.height = 1 + Math.max(B.height, F.height);\n        C.height = 1 + Math.max(A.height, G.height);\n      }\n\n      return C;\n    }\n\n    // Rotate B up\n    if (balance < -1) {\n      const D = B.child1;\n      const E = B.child2;\n\n      // Swap A and B\n      B.child1 = A;\n      B.parent = A.parent;\n      A.parent = B;\n\n      // A's old parent should point to B\n      if (B.parent != null) {\n        if (B.parent.child1 === A) {\n          B.parent.child1 = B;\n        } else {\n          B.parent.child2 = B;\n        }\n      } else {\n        this.m_root = B;\n      }\n\n      // Rotate\n      if (D.height > E.height) {\n        B.child2 = D;\n        A.child1 = E;\n        E.parent = A;\n        A.aabb.combine(C.aabb, E.aabb);\n        B.aabb.combine(A.aabb, D.aabb);\n\n        A.height = 1 + Math.max(C.height, E.height);\n        B.height = 1 + Math.max(A.height, D.height);\n      } else {\n        B.child2 = E;\n        A.child1 = D;\n        D.parent = A;\n        A.aabb.combine(C.aabb, D.aabb);\n        B.aabb.combine(A.aabb, E.aabb);\n\n        A.height = 1 + Math.max(C.height, D.height);\n        B.height = 1 + Math.max(A.height, E.height);\n      }\n\n      return B;\n    }\n\n    return A;\n  }\n\n  /**\n   * Compute the height of the binary tree in O(N) time. Should not be called\n   * often.\n   */\n  getHeight(): number {\n    if (this.m_root == null) {\n      return 0;\n    }\n\n    return this.m_root.height;\n  }\n\n  /**\n   * Get the ratio of the sum of the node areas to the root area.\n   */\n  getAreaRatio(): number {\n    if (this.m_root == null) {\n      return 0.0;\n    }\n\n    const root = this.m_root;\n    const rootArea = root.aabb.getPerimeter();\n\n    let totalArea = 0.0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // Free node in pool\n        continue;\n      }\n\n      totalArea += node.aabb.getPerimeter();\n    }\n\n    this.iteratorPool.release(it);\n\n    return totalArea / rootArea;\n  }\n\n  /**\n   * Compute the height of a sub-tree.\n   */\n  computeHeight(id?: number): number {\n    let node;\n    if (typeof id !== 'undefined') {\n      node = this.m_nodes[id];\n    } else {\n      node = this.m_root;\n    }\n\n    // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);\n\n    if (node.isLeaf()) {\n      return 0;\n    }\n\n    const height1 = this.computeHeight(node.child1.id);\n    const height2 = this.computeHeight(node.child2.id);\n    return 1 + Math.max(height1, height2);\n  }\n\n  validateStructure(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    if (node === this.m_root) {\n      _ASSERT && common.assert(node.parent == null);\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && common.assert(child1 == null);\n      _ASSERT && common.assert(child2 == null);\n      _ASSERT && common.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    _ASSERT && common.assert(child1.parent === node);\n    _ASSERT && common.assert(child2.parent === node);\n\n    this.validateStructure(child1);\n    this.validateStructure(child2);\n  }\n\n  validateMetrics(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && common.assert(child1 == null);\n      _ASSERT && common.assert(child2 == null);\n      _ASSERT && common.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    const height1 = child1.height;\n    const height2 = child2.height;\n    const height = 1 + Math.max(height1, height2);\n    _ASSERT && common.assert(node.height === height);\n\n    const aabb = new AABB();\n    aabb.combine(child1.aabb, child2.aabb);\n\n    _ASSERT && common.assert(AABB.areEqual(aabb, node.aabb));\n\n    this.validateMetrics(child1);\n    this.validateMetrics(child2);\n  }\n\n  /**\n   * Validate this tree. For testing.\n   */\n  validate(): void {\n    this.validateStructure(this.m_root);\n    this.validateMetrics(this.m_root);\n\n    _ASSERT && common.assert(this.getHeight() === this.computeHeight());\n  }\n\n  /**\n   * Get the maximum balance of an node in the tree. The balance is the difference\n   * in height of the two children of a node.\n   */\n  getMaxBalance(): number {\n    let maxBalance = 0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height <= 1) {\n        continue;\n      }\n\n      _ASSERT && common.assert(!node.isLeaf());\n\n      const balance = Math.abs(node.child2.height - node.child1.height);\n      maxBalance = Math.max(maxBalance, balance);\n    }\n    this.iteratorPool.release(it);\n\n    return maxBalance;\n  }\n\n  /**\n   * Build an optimal tree. Very expensive. For testing.\n   */\n  rebuildBottomUp(): void {\n    const nodes = [];\n    let count = 0;\n\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // free node in pool\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        node.parent = null;\n        nodes[count] = node;\n        ++count;\n      } else {\n        this.freeNode(node);\n      }\n    }\n    this.iteratorPool.release(it);\n\n    while (count > 1) {\n      let minCost = Infinity;\n      let iMin = -1;\n      let jMin = -1;\n      for (let i = 0; i < count; ++i) {\n        const aabbi = nodes[i].aabb;\n        for (let j = i + 1; j < count; ++j) {\n          const aabbj = nodes[j].aabb;\n          const b = new AABB();\n          b.combine(aabbi, aabbj);\n          const cost = b.getPerimeter();\n          if (cost < minCost) {\n            iMin = i;\n            jMin = j;\n            minCost = cost;\n          }\n        }\n      }\n\n      const child1 = nodes[iMin];\n      const child2 = nodes[jMin];\n\n      const parent = this.allocateNode();\n      parent.child1 = child1;\n      parent.child2 = child2;\n      parent.height = 1 + Math.max(child1.height, child2.height);\n      parent.aabb.combine(child1.aabb, child2.aabb);\n      parent.parent = null;\n\n      child1.parent = parent;\n      child2.parent = parent;\n\n      nodes[jMin] = nodes[count - 1];\n      nodes[iMin] = parent;\n      --count;\n    }\n\n    this.m_root = nodes[0];\n\n    this.validate();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      const aabb = node.aabb;\n      aabb.lowerBound.x -= newOrigin.x;\n      aabb.lowerBound.y -= newOrigin.y;\n      aabb.upperBound.x -= newOrigin.x;\n      aabb.upperBound.y -= newOrigin.y;\n    }\n    this.iteratorPool.release(it);\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query(aabb: AABB, queryCallback: DynamicTreeQueryCallback): void {\n    _ASSERT && common.assert(typeof queryCallback === 'function');\n    const stack = this.stackPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, aabb)) {\n        if (node.isLeaf()) {\n          const proceed = queryCallback(node.id);\n          if (proceed === false) {\n            return;\n          }\n        } else {\n          stack.push(node.child1);\n          stack.push(node.child2);\n        }\n      }\n    }\n\n    this.stackPool.release(stack);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    // TODO: GC\n    _ASSERT && common.assert(typeof rayCastCallback === 'function');\n    const p1 = input.p1;\n    const p2 = input.p2;\n    const r = Vec2.sub(p2, p1);\n    _ASSERT && common.assert(r.lengthSquared() > 0.0);\n    r.normalize();\n\n    // v is perpendicular to the segment.\n    const v = Vec2.crossNumVec2(1.0, r);\n    const abs_v = Vec2.abs(v);\n\n    // Separating axis for segment (Gino, p80).\n    // |dot(v, p1 - c)| > dot(|v|, h)\n\n    let maxFraction = input.maxFraction;\n\n    // Build a bounding box for the segment.\n    const segmentAABB = new AABB();\n    let t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n    segmentAABB.combinePoints(p1, t);\n\n    const stack = this.stackPool.allocate();\n    const subInput = this.inputPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n        continue;\n      }\n\n      // Separating axis for segment (Gino, p80).\n      // |dot(v, p1 - c)| > dot(|v|, h)\n      const c = node.aabb.getCenter();\n      const h = node.aabb.getExtents();\n      const separation = Math.abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n      if (separation > 0.0) {\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        subInput.p1 = Vec2.clone(input.p1);\n        subInput.p2 = Vec2.clone(input.p2);\n        subInput.maxFraction = maxFraction;\n\n        const value = rayCastCallback(subInput, node.id);\n\n        if (value === 0.0) {\n          // The client has terminated the ray cast.\n          return;\n        }\n\n        if (value > 0.0) {\n          // update segment bounding box.\n          maxFraction = value;\n          t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n          segmentAABB.combinePoints(p1, t);\n        }\n      } else {\n        stack.push(node.child1);\n        stack.push(node.child2);\n      }\n    }\n    this.stackPool.release(stack);\n    this.inputPool.release(subInput);\n  }\n\n  private inputPool: Pool<RayCastInput> = new Pool<RayCastInput>({\n    create(): RayCastInput {\n      // tslint:disable-next-line:no-object-literal-type-assertion\n      return {} as RayCastInput;\n    },\n    release(stack: RayCastInput): void {\n    }\n  });\n\n  private stackPool: Pool<Array<TreeNode<T>>> = new Pool<Array<TreeNode<T>>>({\n    create(): Array<TreeNode<T>> {\n      return [];\n    },\n    release(stack: Array<TreeNode<T>>): void {\n      stack.length = 0;\n    }\n  });\n\n  private iteratorPool: Pool<Iterator<T>> = new Pool<Iterator<T>>({\n    create(): Iterator<T> {\n      return new Iterator();\n    },\n    release(iterator: Iterator<T>): void {\n      iterator.close();\n    }\n  });\n\n}\n\nclass Iterator<T> {\n  parents: Array<TreeNode<T>> = [];\n  states: number[] = [];\n  preorder(root: TreeNode<T>): Iterator<T> {\n    this.parents.length = 0;\n    this.parents.push(root);\n    this.states.length = 0;\n    this.states.push(0);\n    return this;\n  }\n  next(): TreeNode<T> {\n    while (this.parents.length > 0) {\n      const i = this.parents.length - 1;\n      const node = this.parents[i];\n      if (this.states[i] === 0) {\n        this.states[i] = 1;\n        return node;\n      }\n      if (this.states[i] === 1) {\n        this.states[i] = 2;\n        if (node.child1) {\n          this.parents.push(node.child1);\n          this.states.push(1);\n          return node.child1;\n        }\n      }\n      if (this.states[i] === 2) {\n        this.states[i] = 3;\n        if (node.child2) {\n          this.parents.push(node.child2);\n          this.states.push(1);\n          return node.child2;\n        }\n      }\n      this.parents.pop();\n      this.states.pop();\n    }\n  }\n  close(): void {\n    this.parents.length = 0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Vec2 from '../common/Vec2';\nimport Math from '../common/Math';\nimport AABB, { RayCastCallback, RayCastInput } from './AABB';\nimport DynamicTree, { DynamicTreeQueryCallback } from './DynamicTree';\nimport { FixtureProxy } from \"../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n * objects and query them on update.\n */\nexport default class BroadPhase {\n  m_tree: DynamicTree<FixtureProxy> = new DynamicTree<FixtureProxy>();\n  m_proxyCount: number = 0;\n  m_moveBuffer: number[] = [];\n\n  m_callback: (userDataA: any, userDataB: any) => void;\n  m_queryProxyId: number;\n\n  /**\n   * Get user data from a proxy. Returns null if the id is invalid.\n   */\n  getUserData(proxyId: number): FixtureProxy {\n    return this.m_tree.getUserData(proxyId);\n  }\n\n  /**\n   * Test overlap of fat AABBs.\n   */\n  testOverlap(proxyIdA: number, proxyIdB: number): boolean {\n    const aabbA = this.m_tree.getFatAABB(proxyIdA);\n    const aabbB = this.m_tree.getFatAABB(proxyIdB);\n    return AABB.testOverlap(aabbA, aabbB);\n  }\n\n  /**\n   * Get the fat AABB for a proxy.\n   */\n  getFatAABB(proxyId: number): AABB {\n    return this.m_tree.getFatAABB(proxyId);\n  }\n\n  /**\n   * Get the number of proxies.\n   */\n  getProxyCount(): number {\n    return this.m_proxyCount;\n  }\n\n  /**\n   * Get the height of the embedded tree.\n   */\n  getTreeHeight(): number {\n    return this.m_tree.getHeight();\n  }\n\n  /**\n   * Get the balance (integer) of the embedded tree.\n   */\n  getTreeBalance(): number {\n    return this.m_tree.getMaxBalance();\n  }\n\n  /**\n   * Get the quality metric of the embedded tree.\n   */\n  getTreeQuality(): number {\n    return this.m_tree.getAreaRatio();\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query = (aabb: AABB, queryCallback: DynamicTreeQueryCallback): void => {\n    this.m_tree.query(aabb, queryCallback);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    this.m_tree.rayCast(input, rayCastCallback);\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_tree.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n   * is called.\n   */\n  createProxy(aabb: AABB, userData: FixtureProxy): number {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n    const proxyId = this.m_tree.createProxy(aabb, userData);\n    this.m_proxyCount++;\n    this.bufferMove(proxyId);\n    return proxyId;\n  }\n\n  /**\n   * Destroy a proxy. It is up to the client to remove any pairs.\n   */\n  destroyProxy(proxyId: number): void {\n    this.unbufferMove(proxyId);\n    this.m_proxyCount--;\n    this.m_tree.destroyProxy(proxyId);\n  }\n\n  /**\n   * Call moveProxy as many times as you like, then when you are done call\n   * UpdatePairs to finalized the proxy pairs (for your time step).\n   */\n  moveProxy(proxyId: number, aabb: AABB, displacement: Vec2): void {\n    _ASSERT && common.assert(AABB.isValid(aabb));\n    const changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n    if (changed) {\n      this.bufferMove(proxyId);\n    }\n  }\n\n  /**\n   * Call to trigger a re-processing of it's pairs on the next call to\n   * UpdatePairs.\n   */\n  touchProxy(proxyId: number): void {\n    this.bufferMove(proxyId);\n  }\n\n  bufferMove(proxyId: number): void {\n    this.m_moveBuffer.push(proxyId);\n  }\n\n  unbufferMove(proxyId: number): void {\n    for (let i = 0; i < this.m_moveBuffer.length; ++i) {\n      if (this.m_moveBuffer[i] === proxyId) {\n        this.m_moveBuffer[i] = null;\n      }\n    }\n  }\n\n  /**\n   * Update the pairs. This results in pair callbacks. This can only add pairs.\n   */\n  updatePairs(addPairCallback: (userDataA: FixtureProxy, userDataB: FixtureProxy) => void): void {\n    _ASSERT && common.assert(typeof addPairCallback === 'function');\n    this.m_callback = addPairCallback;\n\n    // Perform tree queries for all moving proxies.\n    while (this.m_moveBuffer.length > 0) {\n      this.m_queryProxyId = this.m_moveBuffer.pop();\n      if (this.m_queryProxyId === null) {\n        continue;\n      }\n\n      // We have to query the tree with the fat AABB so that\n      // we don't fail to create a pair that may touch later.\n      const fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n\n      // Query tree, create pairs and add them pair buffer.\n      this.m_tree.query(fatAABB, this.queryCallback);\n    }\n\n    // Try to keep the tree balanced.\n    // this.m_tree.rebalance(4);\n  }\n\n  queryCallback = (proxyId: number): boolean => {\n    // A proxy cannot form a pair with itself.\n    if (proxyId === this.m_queryProxyId) {\n      return true;\n    }\n\n    const proxyIdA = Math.min(proxyId, this.m_queryProxyId);\n    const proxyIdB = Math.max(proxyId, this.m_queryProxyId);\n\n    // TODO: Skip any duplicate pairs.\n\n    const userDataA = this.m_tree.getUserData(proxyIdA);\n    const userDataB = this.m_tree.getUserData(proxyIdB);\n\n    // Send the pairs back to the client.\n    this.m_callback(userDataA, userDataB);\n\n    return true;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Vec2 from './Vec2';\nimport Math from './Math';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport default class Rot {\n  s: number;\n  c: number;\n\n  /** Initialize from an angle in radians. */\n  constructor(angle?: number | Rot) {\n    if (!(this instanceof Rot)) {\n      return new Rot(angle);\n    }\n    if (typeof angle === 'number') {\n      this.setAngle(angle);\n    } else if (typeof angle === 'object') {\n      this.setRot(angle);\n    } else {\n      this.setIdentity();\n    }\n  }\n\n  /** @internal */\n  static neo(angle: number): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.setAngle(angle);\n    return obj;\n  }\n\n  static clone(rot: Rot): Rot {\n    _ASSERT && Rot.assert(rot);\n    const obj = Object.create(Rot.prototype);\n    obj.s = rot.s;\n    obj.c = rot.c;\n    return obj;\n  }\n\n  static identity(): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.s = 0.0;\n    obj.c = 1.0;\n    return obj;\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.s) && Math.isFinite(obj.c);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Rot.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Rot!');\n    }\n  }\n\n  /** Set to the identity rotation. */\n  setIdentity(): void {\n    this.s = 0.0;\n    this.c = 1.0;\n  }\n\n  set(angle: number | Rot): void {\n    if (typeof angle === 'object') {\n      _ASSERT && Rot.assert(angle);\n      this.s = angle.s;\n      this.c = angle.c;\n\n    } else {\n      _ASSERT && Math.assert(angle);\n      // TODO_ERIN optimize\n      this.s = Math.sin(angle);\n      this.c = Math.cos(angle);\n    }\n  }\n\n  setRot(angle: Rot): void {\n    _ASSERT && Rot.assert(angle);\n    this.s = angle.s;\n    this.c = angle.c;\n  }\n\n  /** Set using an angle in radians. */\n  setAngle(angle: number): void {\n    _ASSERT && Math.assert(angle);\n    // TODO_ERIN optimize\n    this.s = Math.sin(angle);\n    this.c = Math.cos(angle);\n  }\n\n  /** Get the angle in radians. */\n  getAngle(): number {\n    return Math.atan2(this.s, this.c);\n  }\n\n  /** Get the x-axis. */\n  getXAxis(): Vec2 {\n    return Vec2.neo(this.c, this.s);\n  }\n\n  /** Get the u-axis. */\n  getYAxis(): Vec2 {\n    return Vec2.neo(-this.s, this.c);\n  }\n\n  /** Multiply two rotations: q * r */\n  static mul(rot: Rot, m: Rot): Rot;\n  /** Rotate a vector */\n  static mul(rot: Rot, m: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(rot, m) {\n    _ASSERT && Rot.assert(rot);\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n      // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n      // s = qs * rc + qc * rs\n      // c = qc * rc - qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.s * m.c + rot.c * m.s;\n      qr.c = rot.c * m.c - rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Multiply two rotations: q * r */\n  static mulRot(rot: Rot, m: Rot): Rot {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Rot.assert(m);\n    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n    // s = qs * rc + qc * rs\n    // c = qc * rc - qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.s * m.c + rot.c * m.s;\n    qr.c = rot.c * m.c - rot.s * m.s;\n    return qr;\n  }\n\n  /** Rotate a vector */\n  static mulVec2(rot: Rot, m: Vec2): Vec2 {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n  }\n\n  static mulSub(rot: Rot, v: Vec2, w: Vec2): Vec2 {\n    const x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n    const y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n    return Vec2.neo(x, y);\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulT(rot: Rot, m: Rot): Rot;\n  /** Inverse rotate a vector */\n  static mulT(rot: Rot, m: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(rot, m) {\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n      // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n      // s = qc * rs - qs * rc\n      // c = qc * rc + qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.c * m.s - rot.s * m.c;\n      qr.c = rot.c * m.c + rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulTRot(rot: Rot, m: Rot): Rot {\n    _ASSERT && Rot.assert(m);\n    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n    // s = qc * rs - qs * rc\n    // c = qc * rc + qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.c * m.s - rot.s * m.c;\n    qr.c = rot.c * m.c + rot.s * m.s;\n    return qr;\n  }\n\n  /** Inverse rotate a vector */\n  static mulTVec2(rot: Rot, m: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Vec2 from './Vec2';\nimport Rot from './Rot';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A transform contains translation and rotation. It is used to represent the\n * position and orientation of rigid frames. Initialize using a position vector\n * and a rotation.\n */\nexport default class Transform {\n  /** position */\n  p: Vec2;\n\n  /** rotation */\n  q: Rot;\n\n  constructor(position?: Vec2, rotation?: number) {\n    if (!(this instanceof Transform)) {\n      return new Transform(position, rotation);\n    }\n    this.p = Vec2.zero();\n    this.q = Rot.identity();\n    if (typeof position !== 'undefined') {\n      this.p.setVec2(position);\n    }\n    if (typeof rotation !== 'undefined') {\n      this.q.setAngle(rotation);\n    }\n  }\n\n  static clone(xf: Transform): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(xf.p);\n    obj.q = Rot.clone(xf.q);\n    return obj;\n  }\n\n  /** @internal */\n  static neo(position: Vec2, rotation: Rot): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(position);\n    obj.q = Rot.clone(rotation);\n    return obj;\n  }\n\n  static identity(): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.zero();\n    obj.q = Rot.identity();\n    return obj;\n  }\n\n  /**\n   * Set this to the identity transform.\n   */\n  setIdentity(): void {\n    this.p.setZero();\n    this.q.setIdentity();\n  }\n\n  set(position: Vec2, rotation: number): void;\n  set(xf: Transform): void;\n  /**\n   * Set this based on the position and angle.\n   */\n  // tslint:disable-next-line:typedef\n  set(a, b?) {\n    if (typeof b === 'undefined') {\n      this.p.set(a.p);\n      this.q.set(a.q);\n    } else {\n      this.p.set(a);\n      this.q.set(b);\n    }\n  }\n\n  /**\n   * Set this based on the position and angle.\n   */\n  setNum(position: Vec2, rotation: number) {\n    this.p.setVec2(position);\n    this.q.setAngle(rotation);\n  }\n\n  setTransform(xf: Transform): void {\n    this.p.setVec2(xf.p);\n    this.q.setRot(xf.q);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Transform.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Transform!');\n    }\n  }\n\n  static mul(a: Transform, b: Vec2): Vec2;\n  static mul(a: Transform, b: Transform): Transform;\n  // static mul(a: Transform, b: Vec2[]): Vec2[];\n  // static mul(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    if (Array.isArray(b)) {\n      _ASSERT && Transform.assert(a);\n      const arr = [];\n      for (let i = 0; i < b.length; i++) {\n        arr[i] = Transform.mul(a, b[i]);\n      }\n      return arr;\n\n    } else if ('x' in b && 'y' in b) {\n      return Transform.mulVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulXf(a, b);\n    }\n  }\n\n  static mulAll(a: Transform, b: Vec2[]): Vec2[];\n  static mulAll(a: Transform, b: Transform[]): Transform[];\n  // tslint:disable-next-line:typedef\n  static mulAll(a: Transform, b) {\n    _ASSERT && Transform.assert(a);\n    const arr = [];\n    for (let i = 0; i < b.length; i++) {\n      arr[i] = Transform.mul(a, b[i]);\n    }\n    return arr;\n  }\n\n  /** @internal @deprecated */\n  // tslint:disable-next-line:typedef\n  static mulFn(a: Transform) {\n    _ASSERT && Transform.assert(a);\n    return function(b: Vec2): Vec2 {\n      return Transform.mul(a, b);\n    };\n  }\n\n  static mulVec2(a: Transform, b: Vec2): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;\n    const y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulXf(a: Transform, b: Transform): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n    const xf = Transform.identity();\n    xf.q = Rot.mulRot(a.q, b.q);\n    xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n    return xf;\n  }\n\n  static mulT(a: Transform, b: Vec2): Vec2;\n  static mulT(a: Transform, b: Transform): Transform;\n  // tslint:disable-next-line:typedef\n  static mulT(a, b) {\n    if ('x' in b && 'y' in b) {\n      return Transform.mulTVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulTXf(a, b);\n    }\n  }\n\n  static mulTVec2(a: Transform, b: Vec2): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const px = b.x - a.p.x;\n    const py = b.y - a.p.y;\n    const x = (a.q.c * px + a.q.s * py);\n    const y = (-a.q.s * px + a.q.c * py);\n    return Vec2.neo(x, y);\n  }\n\n  static mulTXf(a: Transform, b: Transform): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q' * (B.q * v1 + B.p - A.p)\n    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n    const xf = Transform.identity();\n    xf.q.setRot(Rot.mulTRot(a.q, b.q));\n    xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n    return xf;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Math from './Math';\nimport Vec2 from './Vec2';\nimport Rot from './Rot';\nimport Transform from './Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * This describes the motion of a body/shape for TOI computation. Shapes are\n * defined with respect to the body origin, which may not coincide with the\n * center of mass. However, to support dynamics we must interpolate the center\n * of mass position.\n */\nexport default class Sweep {\n  /** Local center of mass position */\n  localCenter: Vec2;\n\n  /** World center position */\n  c: Vec2;\n\n  /** World angle */\n  a: number;\n\n  /** Fraction of the current time step in the range [0,1], c0 and a0 are c and a at alpha0. */\n  alpha0: number;\n\n  c0: Vec2;\n  a0: number;\n\n  constructor(c?: Vec2, a?: number) {\n    _ASSERT && common.assert(typeof c === 'undefined');\n    _ASSERT && common.assert(typeof a === 'undefined');\n    this.localCenter = Vec2.zero();\n    this.c = Vec2.zero();\n    this.a = 0;\n    this.alpha0 = 0;\n    this.c0 = Vec2.zero();\n    this.a0 = 0;\n  }\n\n  setTransform(xf: Transform): void {\n    const c = Transform.mulVec2(xf, this.localCenter);\n    this.c.setVec2(c);\n    this.c0.setVec2(c);\n\n    this.a = xf.q.getAngle();\n    this.a0 = xf.q.getAngle();\n  }\n\n  setLocalCenter(localCenter: Vec2, xf: Transform): void {\n    this.localCenter.setVec2(localCenter);\n\n    const c = Transform.mulVec2(xf, this.localCenter);\n    this.c.setVec2(c);\n    this.c0.setVec2(c);\n  }\n\n  /**\n   * Get the interpolated transform at a specific time.\n   *\n   * @param xf\n   * @param beta A factor in [0,1], where 0 indicates alpha0\n   */\n  getTransform(xf: Transform, beta: number = 0): void {\n    xf.q.setAngle((1.0 - beta) * this.a0 + beta * this.a);\n    xf.p.setCombine((1.0 - beta), this.c0, beta, this.c);\n\n    // shift to origin\n    xf.p.sub(Rot.mulVec2(xf.q, this.localCenter));\n  }\n\n  /**\n   * Advance the sweep forward, yielding a new initial state.\n   *\n   * @param alpha The new initial time\n   */\n  advance(alpha: number): void {\n    _ASSERT && common.assert(this.alpha0 < 1.0);\n    const beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n    this.c0.setCombine(beta, this.c, 1 - beta, this.c0);\n    this.a0 = beta * this.a + (1 - beta) * this.a0;\n    this.alpha0 = alpha;\n  }\n\n  forward(): void {\n    this.a0 = this.a;\n    this.c0.setVec2(this.c);\n  }\n\n  /**\n   * normalize the angles in radians to be between -pi and pi.\n   */\n  normalize(): void {\n    const a0 = Math.mod(this.a0, -Math.PI, +Math.PI);\n    this.a -= this.a0 - a0;\n    this.a0 = a0;\n  }\n\n  clone(): Sweep {\n    const clone = new Sweep();\n    clone.localCenter.setVec2(this.localCenter);\n    clone.alpha0 = this.alpha0;\n    clone.a0 = this.a0;\n    clone.a = this.a;\n    clone.c0.setVec2(this.c0);\n    clone.c.setVec2(this.c);\n    return clone;\n  }\n\n  set(that: Sweep): void {\n    this.localCenter.setVec2(that.localCenter);\n    this.alpha0 = that.alpha0;\n    this.a0 = that.a0;\n    this.a = that.a;\n    this.c0.setVec2(that.c0);\n    this.c.setVec2(that.c);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Vec2 from '../common/Vec2';\n\nexport default class Velocity {\n  /** linear */\n  v: Vec2;\n\n  /** angular */\n  w: number;\n\n  constructor() {\n    this.v = Vec2.zero();\n    this.w = 0;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Vec2 from '../common/Vec2';\nimport Rot from '../common/Rot';\nimport Transform from '../common/Transform';\n\n\nexport default class Position {\n  /** location */\n  c: Vec2;\n\n  /** angle */\n  a: number;\n\n  constructor() {\n    this.c = Vec2.zero();\n    this.a = 0;\n  }\n\n  getTransform(xf: Transform, p: Vec2): Transform {\n    xf.q.setAngle(this.a);\n    xf.p.setVec2(Vec2.sub(this.c, Rot.mulVec2(xf.q, p)));\n    return xf;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../dynamics/Body';\nimport AABB, { RayCastOutput, RayCastInput } from './AABB';\nimport { DistanceProxy } from './Distance';\nimport type Transform from '../common/Transform';\nimport type Vec2 from '../common/Vec2';\n\n\n/**\n * A shape is used for collision detection. You can create a shape however you\n * like. Shapes used for simulation in World are created automatically when a\n * Fixture is created. Shapes may encapsulate one or more child shapes.\n */\nexport default abstract class Shape {\n  m_type: ShapeType;\n  m_radius: number;\n\n  /** @internal */\n  _reset(): void {\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * Get the type of this shape. You can use this to down cast to the concrete\n   * shape.\n   *\n   * @return the shape type.\n   */\n  getType(): ShapeType {\n    return this.m_type;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  abstract _clone(): Shape;\n\n  /**\n   * Get the number of child primitives.\n   */\n  abstract getChildCount(): number;\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  abstract testPoint(xf: Transform, p: Vec2): boolean;\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  abstract rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean;\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  abstract computeAABB(aabb: AABB, xf: Transform, childIndex: number): void;\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  abstract computeMass(massData: MassData, density?: number): void;\n\n  abstract computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void;\n\n}\n\nexport type ShapeType = \"circle\" | \"edge\" | \"polygon\" | \"chain\";\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport options from '../util/options';\nimport Math from '../common/Math';\nimport Vec2 from '../common/Vec2';\nimport AABB, { RayCastInput, RayCastOutput } from '../collision/AABB';\nimport Shape, { ShapeType } from '../collision/Shape';\nimport Body, { MassData } from \"./Body\";\nimport BroadPhase from \"../collision/BroadPhase\";\nimport Transform from \"../common/Transform\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A fixture definition is used to create a fixture. This class defines an\n * abstract fixture definition. You can reuse fixture definitions safely.\n */\nexport interface FixtureOpt {\n  userData?: unknown;\n  /**\n   * The friction coefficient, usually in the range [0,1]\n   */\n  friction?: number;\n  /**\n   * The restitution (elasticity) usually in the range [0,1]\n   */\n  restitution?: number;\n  /**\n   * The density, usually in kg/m^2\n   */\n  density?: number;\n  /**\n   * A sensor shape collects contact information but never generates a collision response.\n   */\n  isSensor?: boolean;\n  /**\n   * Zero, positive or negative collision group.\n   * Fixtures with same positive groupIndex always collide and fixtures with same negative groupIndex never collide.\n   */\n  filterGroupIndex?: number;\n  /**\n   * Collision category bit or bits that this fixture belongs to.\n   * If groupIndex is zero or not matching, then at least one bit in this fixture categoryBits should match other fixture maskBits and vice versa.\n   */\n  filterCategoryBits?: number;\n  /**\n   * Collision category bit or bits that this fixture accept for collision.\n   */\n  filterMaskBits?: number;\n}\n\nexport interface FixtureDef extends FixtureOpt {\n  shape: Shape;\n}\n\nconst FixtureDefDefault: FixtureOpt = {\n  userData : null,\n  friction : 0.2,\n  restitution : 0.0,\n  density : 0.0,\n  isSensor : false,\n\n  filterGroupIndex : 0,\n  filterCategoryBits : 0x0001,\n  filterMaskBits : 0xFFFF\n};\n\n/**\n * This proxy is used internally to connect shape children to the broad-phase.\n */\nexport class FixtureProxy {\n  aabb: AABB;\n  fixture: Fixture;\n  childIndex: number;\n  proxyId: number;\n  constructor(fixture: Fixture, childIndex: number) {\n    this.aabb = new AABB();\n    this.fixture = fixture;\n    this.childIndex = childIndex;\n    this.proxyId;\n  }\n}\n\n/**\n * A fixture is used to attach a shape to a body for collision detection. A\n * fixture inherits its transform from its parent. Fixtures hold additional\n * non-geometric data such as friction, collision filters, etc.\n *\n * To create a new Fixture use {@link Body.createFixture}.\n */\nexport default class Fixture {\n  /** @internal */ m_body: Body;\n  /** @internal */ m_friction: number;\n  /** @internal */ m_restitution: number;\n  /** @internal */ m_density: number;\n  /** @internal */ m_isSensor: boolean;\n  /** @internal */ m_filterGroupIndex: number;\n  /** @internal */ m_filterCategoryBits: number;\n  /** @internal */ m_filterMaskBits: number;\n  /** @internal */ m_shape: Shape;\n  /** @internal */ m_next: Fixture | null;\n  /** @internal */ m_proxies: FixtureProxy[];\n  /** @internal */ m_proxyCount: number;\n  /** @internal */ m_userData: unknown;\n\n  constructor(body: Body, def: FixtureDef);\n  constructor(body: Body, shape: Shape, def?: FixtureOpt);\n  constructor(body: Body, shape: Shape, density?: number);\n  // tslint:disable-next-line:typedef\n  /** @internal */ constructor(body: Body, shape?, def?) {\n    if (shape.shape) {\n      def = shape;\n      shape = shape.shape;\n\n    } else if (typeof def === 'number') {\n      def = {density : def};\n    }\n\n    def = options(def, FixtureDefDefault);\n\n    this.m_body = body;\n\n    this.m_friction = def.friction;\n    this.m_restitution = def.restitution;\n    this.m_density = def.density;\n    this.m_isSensor = def.isSensor;\n\n    this.m_filterGroupIndex = def.filterGroupIndex;\n    this.m_filterCategoryBits = def.filterCategoryBits;\n    this.m_filterMaskBits = def.filterMaskBits;\n\n    // TODO validate shape\n    this.m_shape = shape; // .clone();\n\n    this.m_next = null;\n\n    this.m_proxies = [];\n    this.m_proxyCount = 0;\n\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Re-setup fixture.\n   * @internal\n   */\n  _reset(): void {\n    const body = this.getBody();\n    const broadPhase = body.m_world.m_broadPhase;\n    this.destroyProxies(broadPhase);\n    if (this.m_shape._reset) {\n      this.m_shape._reset();\n    }\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n    this.createProxies(broadPhase, body.m_xf);\n    body.resetMassData();\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      friction: this.m_friction,\n      restitution: this.m_restitution,\n      density: this.m_density,\n      isSensor: this.m_isSensor,\n\n      filterGroupIndex: this.m_filterGroupIndex,\n      filterCategoryBits: this.m_filterCategoryBits,\n      filterMaskBits: this.m_filterMaskBits,\n\n      shape: this.m_shape,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, body: any, restore: any): Fixture {\n    const shape = restore(Shape, data.shape);\n    const fixture = shape && new Fixture(body, shape, data);\n    return fixture;\n  }\n\n  /**\n   * Get the type of the child shape. You can use this to down cast to the\n   * concrete shape.\n   */\n  getType(): ShapeType {\n    return this.m_shape.getType();\n  }\n\n  /**\n   * Get the child shape. You can modify the child shape, however you should not\n   * change the number of vertices because this will crash some collision caching\n   * mechanisms. Manipulating the shape may lead to non-physical behavior.\n   */\n  getShape(): Shape {\n    return this.m_shape;\n  }\n\n  /**\n   * A sensor shape collects contact information but never generates a collision\n   * response.\n   */\n  isSensor(): boolean {\n    return this.m_isSensor;\n  }\n\n  /**\n   * Set if this fixture is a sensor.\n   */\n  setSensor(sensor: boolean): void {\n    if (sensor != this.m_isSensor) {\n      this.m_body.setAwake(true);\n      this.m_isSensor = sensor;\n    }\n  }\n\n  // /**\n  //  * Get the contact filtering data.\n  //  */\n  // getFilterData() {\n  //   return this.m_filter;\n  // }\n\n  /**\n   * Get the user data that was assigned in the fixture definition. Use this to\n   * store your application specific data.\n   */\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  /**\n   * Set the user data. Use this to store your application specific data.\n   */\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get the parent body of this fixture. This is null if the fixture is not\n   * attached.\n   */\n  getBody(): Body {\n    return this.m_body;\n  }\n\n  /**\n   * Get the next fixture in the parent body's fixture list.\n   */\n  getNext(): Fixture | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get the density of this fixture.\n   */\n  getDensity(): number {\n    return this.m_density;\n  }\n\n  /**\n   * Set the density of this fixture. This will _not_ automatically adjust the\n   * mass of the body. You must call Body.resetMassData to update the body's mass.\n   */\n  setDensity(density: number): void {\n    _ASSERT && common.assert(Math.isFinite(density) && density >= 0.0);\n    this.m_density = density;\n  }\n\n  /**\n   * Get the coefficient of friction, usually in the range [0,1].\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Set the coefficient of friction. This will not change the friction of\n   * existing contacts.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the coefficient of restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Set the coefficient of restitution. This will not change the restitution of\n   * existing contacts.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Test a point in world coordinates for containment in this fixture.\n   */\n  testPoint(p: Vec2): boolean {\n    return this.m_shape.testPoint(this.m_body.getTransform(), p);\n  }\n\n  /**\n   * Cast a ray against this shape.\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, childIndex: number): boolean {\n    return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n  }\n\n  /**\n   * Get the mass data for this fixture. The mass data is based on the density and\n   * the shape. The rotational inertia is about the shape's origin. This operation\n   * may be expensive.\n   */\n  getMassData(massData: MassData): void {\n    this.m_shape.computeMass(massData, this.m_density);\n  }\n\n  /**\n   * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n   * more accurate AABB, compute it using the shape and the body transform.\n   */\n  getAABB(childIndex: number): AABB {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_proxyCount);\n    return this.m_proxies[childIndex].aabb;\n  }\n\n  /**\n   * These support body activation/deactivation.\n   */\n  createProxies(broadPhase: BroadPhase, xf: Transform): void {\n    _ASSERT && common.assert(this.m_proxyCount == 0);\n\n    // Create proxies in the broad-phase.\n    this.m_proxyCount = this.m_shape.getChildCount();\n\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      this.m_shape.computeAABB(proxy.aabb, xf, i);\n      proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n    }\n  }\n\n  destroyProxies(broadPhase: BroadPhase): void {\n    // Destroy proxies in the broad-phase.\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      broadPhase.destroyProxy(proxy.proxyId);\n      proxy.proxyId = null;\n    }\n\n    this.m_proxyCount = 0;\n  }\n\n  /**\n   * Updates this fixture proxy in broad-phase (with combined AABB of current and\n   * next transformation).\n   */\n  synchronize(broadPhase: BroadPhase, xf1: Transform, xf2: Transform): void {\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      // Compute an AABB that covers the swept shape (may miss some rotation\n      // effect).\n      const aabb1 = new AABB();\n      const aabb2 = new AABB();\n      this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);\n      this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);\n\n      proxy.aabb.combine(aabb1, aabb2);\n\n      const displacement = Vec2.sub(xf2.p, xf1.p);\n\n      broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n    }\n  }\n\n  /**\n   * Set the contact filtering data. This will not update contacts until the next\n   * time step when either parent body is active and awake. This automatically\n   * calls refilter.\n   */\n  setFilterData(filter: { groupIndex: number, categoryBits: number, maskBits: number }): void {\n    this.m_filterGroupIndex = filter.groupIndex;\n    this.m_filterCategoryBits = filter.categoryBits;\n    this.m_filterMaskBits = filter.maskBits;\n    this.refilter();\n  }\n\n  getFilterGroupIndex(): number {\n    return this.m_filterGroupIndex;\n  }\n\n  setFilterGroupIndex(groupIndex: number): void {\n    this.m_filterGroupIndex = groupIndex;\n  }\n\n  getFilterCategoryBits(): number {\n    return this.m_filterCategoryBits;\n  }\n\n  setFilterCategoryBits(categoryBits: number): void {\n    this.m_filterCategoryBits = categoryBits;\n  }\n\n  getFilterMaskBits(): number {\n    return this.m_filterMaskBits;\n  }\n\n  setFilterMaskBits(maskBits: number): void {\n    this.m_filterMaskBits = maskBits;\n  }\n\n  /**\n   * Call this if you want to establish collision that was previously disabled by\n   * ContactFilter.\n   */\n  refilter(): void {\n    if (this.m_body == null) {\n      return;\n    }\n\n    // Flag associated contacts for filtering.\n    let edge = this.m_body.getContactList();\n    while (edge) {\n      const contact = edge.contact;\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      if (fixtureA == this || fixtureB == this) {\n        contact.flagForFiltering();\n      }\n\n      edge = edge.next;\n    }\n\n    const world = this.m_body.getWorld();\n\n    if (world == null) {\n      return;\n    }\n\n    // Touch each proxy so that new pairs may be created\n    const broadPhase = world.m_broadPhase;\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      broadPhase.touchProxy(this.m_proxies[i].proxyId);\n    }\n  }\n\n  /**\n   * Implement this method to provide collision filtering, if you want finer\n   * control over contact creation.\n   *\n   * Return true if contact calculations should be performed between these two\n   * fixtures.\n   *\n   * Warning: for performance reasons this is only called when the AABBs begin to\n   * overlap.\n   */\n  shouldCollide(that: Fixture): boolean {\n\n    if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n      return that.m_filterGroupIndex > 0;\n    }\n\n    const collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n    const collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n    const collide = collideA && collideB;\n    return collide;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nimport common from '../util/common';\nimport options from '../util/options';\nimport Vec2 from '../common/Vec2';\nimport Rot from '../common/Rot';\nimport Math from '../common/Math';\nimport Sweep from '../common/Sweep';\nimport Transform from '../common/Transform';\nimport Velocity from './Velocity';\nimport Position from './Position';\nimport Fixture, { FixtureDef, FixtureOpt } from './Fixture';\nimport Shape from '../collision/Shape';\nimport { JointEdge } from \"./Joint\";\nimport World from \"./World\";\nimport { ContactEdge } from \"./Contact\";\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\nexport type BodyType = 'static' | 'kinematic' | 'dynamic';\n\nconst STATIC = 'static';\nconst KINEMATIC = 'kinematic';\nconst DYNAMIC = 'dynamic';\n\nexport interface BodyDef {\n  /**\n   * Body types are static, kinematic, or dynamic. Note: if a dynamic\n   * body would have zero mass, the mass is set to one.\n   */\n  type?: BodyType;\n  /**\n   * The world position of the body. Avoid creating bodies at the\n   * origin since this can lead to many overlapping shapes.\n   */\n  position?: Vec2;\n  /**\n   * The world angle of the body in radians.\n   */\n  angle?: number;\n  /**\n   * The linear velocity of the body's origin in world co-ordinates.\n   */\n  linearVelocity?: Vec2;\n  angularVelocity?: number;\n  /**\n   * Linear damping is use to reduce the linear velocity. The\n   * damping parameter can be larger than 1.0 but the damping effect becomes\n   * sensitive to the time step when the damping parameter is large.\n   */\n  linearDamping?: number;\n  /**\n   * Angular damping is use to reduce the angular velocity.\n   * The damping parameter can be larger than 1.0 but the damping effect\n   * becomes sensitive to the time step when the damping parameter is large.\n   */\n  angularDamping?: number;\n  /**\n   * Should this body be prevented from rotating? Useful for characters.\n   */\n  fixedRotation?: boolean;\n  /**\n   * Is this a fast moving body that should be prevented from\n   * tunneling through other moving bodies? Note that all bodies are\n   * prevented from tunneling through kinematic and static bodies. This\n   * setting is only considered on dynamic bodies. Warning: You should use\n   * this flag sparingly since it increases processing time.\n   */\n  bullet?: boolean;\n  gravityScale?: number;\n  /**\n   * Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.\n   */\n  allowSleep?: boolean;\n  /**\n   * Is this body initially awake or sleeping?\n   */\n  awake?: boolean;\n  /**\n   * Does this body start out active?\n   */\n  active?: boolean;\n  userData?: any;\n}\n\nconst BodyDefDefault: BodyDef = {\n  type : STATIC,\n  position : Vec2.zero(),\n  angle : 0.0,\n\n  linearVelocity : Vec2.zero(),\n  angularVelocity : 0.0,\n\n  linearDamping : 0.0,\n  angularDamping : 0.0,\n\n  fixedRotation : false,\n  bullet : false,\n  gravityScale : 1.0,\n\n  allowSleep : true,\n  awake : true,\n  active : true,\n\n  userData : null\n};\n\n/**\n * MassData This holds the mass data computed for a shape.\n */\nexport class MassData {\n  /** The mass of the shape, usually in kilograms. */\n  mass: number = 0;\n  /** The position of the shape's centroid relative to the shape's origin. */\n  center: Vec2 = Vec2.zero();\n  /** The rotational inertia of the shape about the local origin. */\n  I: number = 0;\n}\n\n/**\n * A rigid body composed of one or more fixtures.\n *\n * To create a new Body use {@link World.createBody}.\n */\nexport default class Body {\n  /**\n   * A static body does not move under simulation and behaves as if it has infinite mass.\n   * Internally, zero is stored for the mass and the inverse mass.\n   * Static bodies can be moved manually by the user.\n   * A static body has zero velocity.\n   * Static bodies do not collide with other static or kinematic bodies.\n   */\n  static readonly STATIC: BodyType = 'static';\n  /**\n   * A kinematic body moves under simulation according to its velocity.\n   * Kinematic bodies do not respond to forces.\n   * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n   * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n   * Kinematic bodies do not collide with other kinematic or static bodies.\n   */\n  static readonly KINEMATIC: BodyType = 'kinematic';\n\n  /**\n   * A dynamic body is fully simulated.\n   * They can be moved manually by the user, but normally they move according to forces.\n   * A dynamic body can collide with all body types.\n   * A dynamic body always has finite, non-zero mass.\n   * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n   */\n  static readonly DYNAMIC: BodyType = 'dynamic';\n\n  /** @internal */ m_world: World;\n  /** @internal */ m_awakeFlag: boolean;\n  /** @internal */ m_autoSleepFlag: boolean;\n  /** @internal */ m_bulletFlag: boolean;\n  /** @internal */ m_fixedRotationFlag: boolean;\n  /** @internal */ m_activeFlag: boolean;\n  /** @internal */ m_islandFlag: boolean;\n  /** @internal */ m_toiFlag: boolean;\n  /** @internal */ m_userData: unknown;\n  /** @internal */ m_type: BodyType;\n  /** @internal */ m_mass: number;\n  /** @internal */ m_invMass: number;\n  /** @internal Rotational inertia about the center of mass. */\n  m_I: number;\n  /** @internal */ m_invI: number;\n  /** @internal the body origin transform */\n  m_xf: Transform;\n  /** @internal the swept motion for CCD */\n  m_sweep: Sweep;\n  // position and velocity correction\n  /** @internal */ c_velocity: Velocity;\n  /** @internal */ c_position: Position;\n  /** @internal */ m_force: Vec2;\n  /** @internal */ m_torque: number;\n  /** @internal */ m_linearVelocity: Vec2;\n  /** @internal */ m_angularVelocity: number;\n  /** @internal */ m_linearDamping: number;\n  /** @internal */ m_angularDamping: number;\n  /** @internal */ m_gravityScale: number;\n  /** @internal */ m_sleepTime: number;\n  /** @internal */ m_jointList: JointEdge | null;\n  /** @internal */ m_contactList: ContactEdge | null;\n  /** @internal */ m_fixtureList: Fixture | null;\n  /** @internal */ m_prev: Body | null;\n  /** @internal */ m_next: Body | null;\n  /** @internal */ m_destroyed: boolean;\n\n  /** @internal */\n  constructor(world: World, def: BodyDef) {\n    def = options(def, BodyDefDefault);\n\n    _ASSERT && common.assert(Vec2.isValid(def.position));\n    _ASSERT && common.assert(Vec2.isValid(def.linearVelocity));\n    _ASSERT && common.assert(Math.isFinite(def.angle));\n    _ASSERT && common.assert(Math.isFinite(def.angularVelocity));\n    _ASSERT && common.assert(Math.isFinite(def.angularDamping) && def.angularDamping >= 0.0);\n    _ASSERT && common.assert(Math.isFinite(def.linearDamping) && def.linearDamping >= 0.0);\n\n    this.m_world = world;\n\n    this.m_awakeFlag = def.awake;\n    this.m_autoSleepFlag = def.allowSleep;\n    this.m_bulletFlag = def.bullet;\n    this.m_fixedRotationFlag = def.fixedRotation;\n    this.m_activeFlag = def.active;\n\n    this.m_islandFlag = false;\n    this.m_toiFlag = false;\n\n    this.m_userData = def.userData;\n    this.m_type = def.type;\n\n    if (this.m_type == DYNAMIC) {\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    } else {\n      this.m_mass = 0.0;\n      this.m_invMass = 0.0;\n    }\n\n    // Rotational inertia about the center of mass.\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    // the body origin transform\n    this.m_xf = Transform.identity();\n    this.m_xf.p = Vec2.clone(def.position);\n    this.m_xf.q.setAngle(def.angle);\n\n    // the swept motion for CCD\n    this.m_sweep = new Sweep();\n    this.m_sweep.setTransform(this.m_xf);\n\n    // position and velocity correction\n    this.c_velocity = new Velocity();\n    this.c_position = new Position();\n\n    this.m_force = Vec2.zero();\n    this.m_torque = 0.0;\n\n    this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n    this.m_angularVelocity = def.angularVelocity;\n\n    this.m_linearDamping = def.linearDamping;\n    this.m_angularDamping = def.angularDamping;\n    this.m_gravityScale = def.gravityScale;\n\n    this.m_sleepTime = 0.0;\n\n    this.m_jointList = null;\n    this.m_contactList = null;\n    this.m_fixtureList = null;\n\n    this.m_prev = null;\n    this.m_next = null;\n\n    this.m_destroyed = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const fixtures = [];\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      fixtures.push(f);\n    }\n    return {\n      type: this.m_type,\n      bullet: this.m_bulletFlag,\n      position: this.m_xf.p,\n      angle: this.m_xf.q.getAngle(),\n      linearVelocity: this.m_linearVelocity,\n      angularVelocity: this.m_angularVelocity,\n      fixtures,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): Body {\n    const body = new Body(world, data);\n\n    if (data.fixtures) {\n      for (let i = data.fixtures.length - 1; i >= 0; i--) {\n        const fixture = restore(Fixture, data.fixtures[i], body);\n        body._addFixture(fixture);\n      }\n    }\n    return body;\n  }\n\n  isWorldLocked(): boolean {\n    return this.m_world && this.m_world.isLocked() ? true : false;\n  }\n\n  getWorld(): World {\n    return this.m_world;\n  }\n\n  getNext(): Body | null {\n    return this.m_next;\n  }\n\n  setUserData(data: any): void {\n    this.m_userData = data;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  getFixtureList(): Fixture | null {\n    return this.m_fixtureList;\n  }\n\n  getJointList(): JointEdge | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Warning: this list changes during the time step and you may miss some\n   * collisions if you don't use ContactListener.\n   */\n  getContactList(): ContactEdge | null {\n    return this.m_contactList;\n  }\n\n  isStatic(): boolean {\n    return this.m_type == STATIC;\n  }\n\n  isDynamic(): boolean {\n    return this.m_type == DYNAMIC;\n  }\n\n  isKinematic(): boolean {\n    return this.m_type == KINEMATIC;\n  }\n\n  /**\n   * This will alter the mass and velocity.\n   */\n  setStatic(): Body {\n    this.setType(STATIC);\n    return this;\n  }\n\n  setDynamic(): Body {\n    this.setType(DYNAMIC);\n    return this;\n  }\n\n  setKinematic(): Body {\n    this.setType(KINEMATIC);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  getType(): BodyType {\n    return this.m_type;\n  }\n\n  /**\n   * @internal\n   */\n  setType(type: BodyType): void {\n    _ASSERT && common.assert(type === STATIC || type === KINEMATIC || type === DYNAMIC);\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type == type) {\n      return;\n    }\n\n    this.m_type = type;\n\n    this.resetMassData();\n\n    if (this.m_type == STATIC) {\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_sweep.forward();\n      this.synchronizeFixtures();\n    }\n\n    this.setAwake(true);\n\n    this.m_force.setZero();\n    this.m_torque = 0.0;\n\n    // Delete the attached contacts.\n    let ce = this.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n      this.m_world.destroyContact(ce0.contact);\n    }\n    this.m_contactList = null;\n\n    // Touch the proxies so that new contacts will be created (when appropriate)\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      const proxyCount = f.m_proxyCount;\n      for (let i = 0; i < proxyCount; ++i) {\n        broadPhase.touchProxy(f.m_proxies[i].proxyId);\n      }\n    }\n  }\n\n  isBullet(): boolean {\n    return this.m_bulletFlag;\n  }\n\n  /**\n   * Should this body be treated like a bullet for continuous collision detection?\n   */\n  setBullet(flag: boolean): void {\n    this.m_bulletFlag = !!flag;\n  }\n\n  isSleepingAllowed(): boolean {\n    return this.m_autoSleepFlag;\n  }\n\n  setSleepingAllowed(flag: boolean): void {\n    this.m_autoSleepFlag = !!flag;\n    if (this.m_autoSleepFlag == false) {\n      this.setAwake(true);\n    }\n  }\n\n  isAwake(): boolean {\n    return this.m_awakeFlag;\n  }\n\n  /**\n   * Set the sleep state of the body. A sleeping body has very low CPU cost.\n   *\n   * @param flag Set to true to wake the body, false to put it to sleep.\n   */\n  setAwake(flag: boolean): void {\n    if (flag) {\n      if (this.m_awakeFlag == false) {\n        this.m_awakeFlag = true;\n        this.m_sleepTime = 0.0;\n      }\n    } else {\n      this.m_awakeFlag = false;\n      this.m_sleepTime = 0.0;\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_force.setZero();\n      this.m_torque = 0.0;\n    }\n  }\n\n  isActive(): boolean {\n    return this.m_activeFlag;\n  }\n\n  /**\n   * Set the active state of the body. An inactive body is not simulated and\n   * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n   * will be added to the broad-phase. If you pass a flag of false, all fixtures\n   * will be removed from the broad-phase and all contacts will be destroyed.\n   * Fixtures and joints are otherwise unaffected.\n   *\n   * You may continue to create/destroy fixtures and joints on inactive bodies.\n   * Fixtures on an inactive body are implicitly inactive and will not participate\n   * in collisions, ray-casts, or queries. Joints connected to an inactive body\n   * are implicitly inactive. An inactive body is still owned by a World object\n   * and remains\n   */\n  setActive(flag: boolean): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (flag == this.m_activeFlag) {\n      return;\n    }\n\n    this.m_activeFlag = !!flag;\n\n    if (this.m_activeFlag) {\n      // Create all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.createProxies(broadPhase, this.m_xf);\n      }\n      // Contacts are created the next time step.\n\n    } else {\n      // Destroy all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.destroyProxies(broadPhase);\n      }\n\n      // Destroy the attached contacts.\n      let ce = this.m_contactList;\n      while (ce) {\n        const ce0 = ce;\n        ce = ce.next;\n        this.m_world.destroyContact(ce0.contact);\n      }\n      this.m_contactList = null;\n    }\n  }\n\n  isFixedRotation(): boolean {\n    return this.m_fixedRotationFlag;\n  }\n\n  /**\n   * Set this body to have fixed rotation. This causes the mass to be reset.\n   */\n  setFixedRotation(flag: boolean): void {\n    if (this.m_fixedRotationFlag == flag) {\n      return;\n    }\n\n    this.m_fixedRotationFlag = !!flag;\n\n    this.m_angularVelocity = 0.0;\n\n    this.resetMassData();\n  }\n\n  /**\n   * Get the world transform for the body's origin.\n   */\n  getTransform(): Transform {\n    return this.m_xf;\n  }\n\n  /**\n   * Set the position of the body's origin and rotation. Manipulating a body's\n   * transform may cause non-physical behavior. Note: contacts are updated on the\n   * next call to World.step.\n   *\n   * @param position The world position of the body's local origin.\n   * @param angle The world rotation in radians.\n   */\n  setTransform(position: Vec2, angle: number): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    this.m_xf.setNum(position, angle);\n    this.m_sweep.setTransform(this.m_xf);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, this.m_xf, this.m_xf);\n    }\n  }\n\n  synchronizeTransform(): void {\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Update fixtures in broad-phase.\n   */\n  synchronizeFixtures(): void {\n    const xf = Transform.identity();\n\n    this.m_sweep.getTransform(xf, 0);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, xf, this.m_xf);\n    }\n  }\n\n  /**\n   * Used in TOI.\n   */\n  advance(alpha: number): void {\n    // Advance to the new safe time. This doesn't sync the broad-phase.\n    this.m_sweep.advance(alpha);\n    this.m_sweep.c.setVec2(this.m_sweep.c0);\n    this.m_sweep.a = this.m_sweep.a0;\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Get the world position for the body's origin.\n   */\n  getPosition(): Vec2 {\n    return this.m_xf.p;\n  }\n\n  setPosition(p: Vec2): void {\n    this.setTransform(p, this.m_sweep.a);\n  }\n\n  /**\n   * Get the current world rotation angle in radians.\n   */\n  getAngle(): number {\n    return this.m_sweep.a;\n  }\n\n  setAngle(angle: number): void {\n    this.setTransform(this.m_xf.p, angle);\n  }\n\n  /**\n   * Get the world position of the center of mass.\n   */\n  getWorldCenter(): Vec2 {\n    return this.m_sweep.c;\n  }\n\n  /**\n   * Get the local position of the center of mass.\n   */\n  getLocalCenter(): Vec2 {\n    return this.m_sweep.localCenter;\n  }\n\n  /**\n   * Get the linear velocity of the center of mass.\n   *\n   * @return the linear velocity of the center of mass.\n   */\n  getLinearVelocity(): Vec2 {\n    return this.m_linearVelocity;\n  }\n\n  /**\n   * Get the world linear velocity of a world point attached to this body.\n   *\n   * @param worldPoint A point in world coordinates.\n   */\n  getLinearVelocityFromWorldPoint(worldPoint: Vec2): Vec2 {\n    const localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n    return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity,\n      localCenter));\n  }\n\n  /**\n   * Get the world velocity of a local point.\n   *\n   * @param localPoint A point in local coordinates.\n   */\n  getLinearVelocityFromLocalPoint(localPoint: Vec2): Vec2 {\n    return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n  }\n\n  /**\n   * Set the linear velocity of the center of mass.\n   *\n   * @param v The new linear velocity of the center of mass.\n   */\n  setLinearVelocity(v: Vec2): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (Vec2.dot(v, v) > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_linearVelocity.setVec2(v);\n  }\n\n  /**\n   * Get the angular velocity.\n   *\n   * @returns the angular velocity in radians/second.\n   */\n  getAngularVelocity(): number {\n    return this.m_angularVelocity;\n  }\n\n  /**\n   * Set the angular velocity.\n   *\n   * @param omega The new angular velocity in radians/second.\n   */\n  setAngularVelocity(w: number): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (w * w > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_angularVelocity = w;\n  }\n\n  getLinearDamping(): number {\n    return this.m_linearDamping;\n  }\n\n  setLinearDamping(linearDamping: number): void {\n    this.m_linearDamping = linearDamping;\n  }\n\n  getAngularDamping(): number {\n    return this.m_angularDamping;\n  }\n\n  setAngularDamping(angularDamping: number): void {\n    this.m_angularDamping = angularDamping;\n  }\n\n  getGravityScale(): number {\n    return this.m_gravityScale;\n  }\n\n  /**\n   * Scale the gravity applied to this body.\n   */\n  setGravityScale(scale: number): void {\n    this.m_gravityScale = scale;\n  }\n\n  /**\n   * Get the total mass of the body.\n   *\n   * @returns The mass, usually in kilograms (kg).\n   */\n  getMass(): number {\n    return this.m_mass;\n  }\n\n  /**\n   * Get the rotational inertia of the body about the local origin.\n   *\n   * @return the rotational inertia, usually in kg-m^2.\n   */\n  getInertia(): number {\n    return this.m_I + this.m_mass\n      * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n  }\n\n  /**\n   * Copy the mass data of the body to data.\n   */\n  getMassData(data: MassData): void {\n    data.mass = this.m_mass;\n    data.I = this.getInertia();\n    data.center.setVec2(this.m_sweep.localCenter);\n  }\n\n  /**\n   * This resets the mass properties to the sum of the mass properties of the\n   * fixtures. This normally does not need to be called unless you called\n   * SetMassData to override the mass and you later want to reset the mass.\n   */\n  resetMassData(): void {\n    // Compute mass data from shapes. Each shape has its own density.\n    this.m_mass = 0.0;\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n    this.m_sweep.localCenter.setZero();\n\n    // Static and kinematic bodies have zero mass.\n    if (this.isStatic() || this.isKinematic()) {\n      this.m_sweep.c0.setVec2(this.m_xf.p);\n      this.m_sweep.c.setVec2(this.m_xf.p);\n      this.m_sweep.a0 = this.m_sweep.a;\n      return;\n    }\n\n    _ASSERT && common.assert(this.isDynamic());\n\n    // Accumulate mass over all fixtures.\n    const localCenter = Vec2.zero();\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      if (f.m_density == 0.0) {\n        continue;\n      }\n\n      const massData = new MassData();\n      f.getMassData(massData);\n      this.m_mass += massData.mass;\n      localCenter.addMul(massData.mass, massData.center);\n      this.m_I += massData.I;\n    }\n\n    // Compute center of mass.\n    if (this.m_mass > 0.0) {\n      this.m_invMass = 1.0 / this.m_mass;\n      localCenter.mul(this.m_invMass);\n\n    } else {\n      // Force all dynamic bodies to have a positive mass.\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    }\n\n    if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n      // Center the inertia about the center of mass.\n      this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);\n      _ASSERT && common.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n\n    } else {\n      this.m_I = 0.0;\n      this.m_invI = 0.0;\n    }\n\n    // Move center of mass.\n    const oldCenter = Vec2.clone(this.m_sweep.c);\n    this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n\n    // Update center of mass velocity.\n    this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(\n      this.m_sweep.c, oldCenter)));\n  }\n\n  /**\n   * Set the mass properties to override the mass properties of the fixtures. Note\n   * that this changes the center of mass position. Note that creating or\n   * destroying fixtures can also alter the mass. This function has no effect if\n   * the body isn't dynamic.\n   *\n   * @param massData The mass properties.\n   */\n  setMassData(massData: MassData): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    this.m_mass = massData.mass;\n    if (this.m_mass <= 0.0) {\n      this.m_mass = 1.0;\n    }\n\n    this.m_invMass = 1.0 / this.m_mass;\n\n    if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n      this.m_I = massData.I - this.m_mass\n        * Vec2.dot(massData.center, massData.center);\n      _ASSERT && common.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n    }\n\n    // Move center of mass.\n    const oldCenter = Vec2.clone(this.m_sweep.c);\n    this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n\n    // Update center of mass velocity.\n    this.m_linearVelocity.add(Vec2.crossNumVec2(this.m_angularVelocity, Vec2.sub(\n      this.m_sweep.c, oldCenter)));\n  }\n\n  /**\n   * Apply a force at a world point. If the force is not applied at the center of\n   * mass, it will generate a torque and affect the angular velocity. This wakes\n   * up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyForce(force: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping.\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n      this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n    }\n  }\n\n  /**\n   * Apply a force to the center of mass. This wakes up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param wake Also wake up the body\n   */\n  applyForceToCenter(force: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n    }\n  }\n\n  /**\n   * Apply a torque. This affects the angular velocity without affecting the\n   * linear velocity of the center of mass. This wakes up the body.\n   *\n   * @param torque About the z-axis (out of the screen), usually in N-m.\n   * @param wake Also wake up the body\n   */\n  applyTorque(torque: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_torque += torque;\n    }\n  }\n\n  /**\n   * Apply an impulse at a point. This immediately modifies the velocity. It also\n   * modifies the angular velocity if the point of application is not at the\n   * center of mass. This wakes up the body.\n   *\n   * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyLinearImpulse(impulse: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_linearVelocity.addMul(this.m_invMass, impulse);\n      this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n    }\n  }\n\n  /**\n   * Apply an angular impulse.\n   *\n   * @param impulse The angular impulse in units of kg*m*m/s\n   * @param wake Also wake up the body\n   */\n  applyAngularImpulse(impulse: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_angularVelocity += this.m_invI * impulse;\n    }\n  }\n\n  /**\n   * This is used to prevent connected bodies (by joints) from colliding,\n   * depending on the joint's collideConnected flag.\n   */\n  shouldCollide(that: Body): boolean {\n    // At least one body should be dynamic.\n    if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n      return false;\n    }\n    // Does a joint prevent collision?\n    for (let jn = this.m_jointList; jn; jn = jn.next) {\n      if (jn.other == that) {\n        if (jn.joint.m_collideConnected == false) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addFixture(fixture: Fixture): Fixture {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.createProxies(broadPhase, this.m_xf);\n    }\n\n    fixture.m_next = this.m_fixtureList;\n    this.m_fixtureList = fixture;\n\n    // Adjust mass properties if needed.\n    if (fixture.m_density > 0.0) {\n      this.resetMassData();\n    }\n\n    // Let the world know we have a new fixture. This will cause new contacts\n    // to be created at the beginning of the next time step.\n    this.m_world.m_newFixture = true;\n\n    return fixture;\n  }\n\n  /**\n   * Creates a fixture and attach it to this body.\n   *\n   * If the density is non-zero, this function automatically updates the mass of\n   * the body.\n   *\n   * Contacts are not created until the next time step.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createFixture(def: FixtureDef): Fixture;\n  createFixture(shape: Shape, opt?: FixtureOpt): Fixture;\n  createFixture(shape: Shape, density?: number): Fixture;\n  // tslint:disable-next-line:typedef\n  createFixture(shape, fixdef?) {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    const fixture = new Fixture(this, shape, fixdef);\n    this._addFixture(fixture);\n    return fixture;\n  }\n\n  /**\n   * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n   * all contacts associated with this fixture. This will automatically adjust the\n   * mass of the body if the body is dynamic and the fixture has positive density.\n   * All fixtures attached to a body are implicitly destroyed when the body is\n   * destroyed.\n   *\n   * Warning: This function is locked during callbacks.\n   *\n   * @param fixture The fixture to be removed.\n   */\n  destroyFixture(fixture: Fixture): void {\n    _ASSERT && common.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    _ASSERT && common.assert(fixture.m_body == this);\n\n    // Remove the fixture from this body's singly linked list.\n    let found = false;\n    if (this.m_fixtureList === fixture) {\n      this.m_fixtureList = fixture.m_next;\n      found = true;\n\n    } else {\n      let node = this.m_fixtureList;\n      while (node != null) {\n        if (node.m_next === fixture) {\n          node.m_next = fixture.m_next;\n          found = true;\n          break;\n        }\n        node = node.m_next;\n      }\n    }\n\n    // You tried to remove a shape that is not attached to this body.\n    _ASSERT && common.assert(found);\n\n    // Destroy any contacts associated with the fixture.\n    let edge = this.m_contactList;\n    while (edge) {\n      const c = edge.contact;\n      edge = edge.next;\n\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n\n      if (fixture == fixtureA || fixture == fixtureB) {\n        // This destroys the contact and removes it from\n        // this body's contact list.\n        this.m_world.destroyContact(c);\n      }\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.destroyProxies(broadPhase);\n    }\n\n    fixture.m_body = null;\n    fixture.m_next = null;\n\n    this.m_world.publish('remove-fixture', fixture);\n\n    // Reset the mass data.\n    this.resetMassData();\n  }\n\n  /**\n   * Get the corresponding world point of a local point.\n   */\n  getWorldPoint(localPoint: Vec2): Vec2 {\n    return Transform.mulVec2(this.m_xf, localPoint);\n  }\n\n  /**\n   * Get the corresponding world vector of a local vector.\n   */\n  getWorldVector(localVector: Vec2): Vec2 {\n    return Rot.mulVec2(this.m_xf.q, localVector);\n  }\n\n  /**\n   * Gets the corresponding local point of a world point.\n   */\n  getLocalPoint(worldPoint: Vec2): Vec2 {\n    return Transform.mulTVec2(this.m_xf, worldPoint);\n  }\n\n  /**\n   * Gets the corresponding local vector of a world vector.\n   */\n  getLocalVector(worldVector: Vec2): Vec2 {\n    return Rot.mulTVec2(this.m_xf.q, worldVector);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Vec2 from './Vec2';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 2-by-2 matrix. Stored in column-major order.\n */\nexport default class Mat22 {\n  ex: Vec2;\n  ey: Vec2;\n\n  constructor(a: number, b: number, c: number, d: number);\n  constructor(a: { x: number; y: number }, b: { x: number; y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(a?, b?, c?, d?) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec2.clone(a);\n      this.ey = Vec2.clone(b);\n    } else if (typeof a === 'number') {\n      this.ex = Vec2.neo(a, c);\n      this.ey = Vec2.neo(b, d);\n    } else {\n      this.ex = Vec2.zero();\n      this.ey = Vec2.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Mat22.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Mat22!');\n    }\n  }\n\n  set(a: Mat22): void;\n  set(a: Vec2, b: Vec2): void;\n  set(a: number, b: number, c: number, d: number): void;\n  // tslint:disable-next-line:typedef\n  set(a, b?, c?, d?): void {\n    if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'\n      && typeof d === 'number') {\n      this.ex.setNum(a, c);\n      this.ey.setNum(b, d);\n\n    } else if (typeof a === 'object' && typeof b === 'object') {\n      this.ex.setVec2(a);\n      this.ey.setVec2(b);\n\n    } else if (typeof a === 'object') {\n      _ASSERT && Mat22.assert(a);\n      this.ex.setVec2(a.ex);\n      this.ey.setVec2(a.ey);\n\n    } else {\n      _ASSERT && common.assert(false);\n    }\n  }\n\n  setIdentity(): void {\n    this.ex.x = 1.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 1.0;\n  }\n\n  setZero(): void {\n    this.ex.x = 0.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 0.0;\n  }\n\n  getInverse(): Mat22 {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const imx = new Mat22();\n    imx.ex.x = det * d;\n    imx.ey.x = -det * b;\n    imx.ex.y = -det * c;\n    imx.ey.y = det * a;\n    return imx;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const w = Vec2.zero();\n    w.x = det * (d * v.x - b * v.y);\n    w.y = det * (a * v.y - c * v.x);\n    return w;\n  }\n\n  /**\n   * Multiply a matrix times a vector. If a rotation matrix is provided, then this\n   * transforms the vector from one frame to another.\n   */\n  static mul(mx: Mat22, my: Mat22): Mat22;\n  static mul(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mul(mx, v) {\n    if (v && 'x' in v && 'y' in v) {\n      _ASSERT && Vec2.assert(v);\n      const x = mx.ex.x * v.x + mx.ey.x * v.y;\n      const y = mx.ex.y * v.x + mx.ey.y * v.y;\n      return Vec2.neo(x, y);\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n      const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n      const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n      const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n      const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n      return new Mat22(a, b, c, d);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  static mulVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const x = mx.ex.x * v.x + mx.ey.x * v.y;\n    const y = mx.ex.y * v.x + mx.ey.y * v.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(v);\n    // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n    const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n    const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n    const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n    const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n    return new Mat22(a, b, c, d);\n  }\n\n  /**\n   * Multiply a matrix transpose times a vector. If a rotation matrix is provided,\n   * then this transforms the vector from one frame to another (inverse\n   * transform).\n   */\n  static mulT(mx: Mat22, my: Mat22): Mat22;\n  static mulT(mx: Mat22, v: Vec2): Vec2;\n  // tslint:disable-next-line:typedef\n  static mulT(mx, v) {\n    if (v && 'x' in v && 'y' in v) { // Vec2\n      _ASSERT && Vec2.assert(v);\n      return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n      const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n      return new Mat22(c1, c2);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  static mulTVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n  }\n\n  static mulTMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Mat22.assert(v);\n    const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n    const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n    return new Mat22(c1, c2);\n  }\n\n  static abs(mx: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n  }\n\n  static add(mx1: Mat22, mx2: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx1);\n    _ASSERT && Mat22.assert(mx2);\n    return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Vec2 from '../common/Vec2';\nimport Transform from '../common/Transform';\nimport Math from '../common/Math';\nimport Rot from '../common/Rot';\n\nexport enum ManifoldType {\n  e_circles = 0,\n  e_faceA = 1,\n  e_faceB = 2\n}\n\nexport enum ContactFeatureType {\n  e_vertex = 0,\n  e_face = 1\n}\n\n/**\n * This is used for determining the state of contact points.\n */\n export enum PointState {\n  /** Point does not exist */\n  nullState = 0,\n  /** Point was added in the update */\n  addState = 1,\n  /** Point persisted across the update */\n  persistState = 2,\n  /** Point was removed in the update */\n  removeState = 3\n}\n\n/**\n * Used for computing contact manifolds.\n */\n export class ClipVertex {\n  v: Vec2 = Vec2.zero();\n  id: ContactID = new ContactID();\n\n  set(o: ClipVertex): void {\n    this.v.setVec2(o.v);\n    this.id.set(o.id);\n  }\n}\n\n/**\n * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n * method of Contact subclasses.\n *\n * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n * with radius and e_circles point versus point with radius.\n *\n * We store contacts in this way so that position correction can account for\n * movement, which is critical for continuous physics. All contact scenarios\n * must be expressed in one of these types. This structure is stored across time\n * steps, so we keep it small.\n *\n * @prop type e_circle, e_faceA, e_faceB\n * @prop localPoint Usage depends on manifold type:<br>\n *       e_circles: the local center of circleA <br>\n *       e_faceA: the center of faceA <br>\n *       e_faceB: the center of faceB\n * @prop localNormal Usage depends on manifold type:<br>\n *       e_circles: not used <br>\n *       e_faceA: the normal on polygonA <br>\n *       e_faceB: the normal on polygonB\n * @prop points The points of contact {ManifoldPoint[]}\n * @prop pointCount The number of manifold points\n */\nexport default class Manifold {\n  type: ManifoldType;\n  localNormal: Vec2 = Vec2.zero();\n  localPoint: Vec2 = Vec2.zero();\n  points: ManifoldPoint[] = [ new ManifoldPoint(), new ManifoldPoint() ];\n  pointCount: number = 0;\n\n  /**\n   * Evaluate the manifold with supplied transforms. This assumes modest motion\n   * from the original state. This does not change the point count, impulses, etc.\n   * The radii must come from the shapes that generated the manifold.\n   */\n  getWorldManifold(wm: WorldManifold | undefined, xfA: Transform, radiusA: number, xfB: Transform, radiusB: number): WorldManifold {\n    if (this.pointCount == 0) {\n      return;\n    }\n\n    wm = wm || new WorldManifold();\n\n    let normal = wm.normal;\n    const points = wm.points;\n    const separations = wm.separations;\n\n    // TODO: improve\n    switch (this.type) {\n      case ManifoldType.e_circles: {\n        normal = Vec2.neo(1.0, 0.0);\n        const pointA = Transform.mulVec2(xfA, this.localPoint);\n        const pointB = Transform.mulVec2(xfB, this.points[0].localPoint);\n        const dist = Vec2.sub(pointB, pointA);\n        if (Vec2.lengthSquared(dist) > Math.EPSILON * Math.EPSILON) {\n          normal.setVec2(dist);\n          normal.normalize();\n        }\n        const cA = pointA.clone().addMul(radiusA, normal);\n        const cB = pointB.clone().addMul(-radiusB, normal);\n        points[0] = Vec2.mid(cA, cB);\n        separations[0] = Vec2.dot(Vec2.sub(cB, cA), normal);\n        points.length = 1;\n        separations.length = 1;\n        break;\n      }\n\n      case ManifoldType.e_faceA: {\n        normal = Rot.mulVec2(xfA.q, this.localNormal);\n        const planePoint = Transform.mulVec2(xfA, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const clipPoint = Transform.mulVec2(xfB, this.points[i].localPoint);\n          const cA = Vec2.clone(clipPoint).addMul(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n          const cB = Vec2.clone(clipPoint).subMul(radiusB, normal);\n          points[i] = Vec2.mid(cA, cB);\n          separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);\n        }\n        points.length = this.pointCount;\n        separations.length = this.pointCount;\n        break;\n      }\n\n      case ManifoldType.e_faceB: {\n        normal = Rot.mulVec2(xfB.q, this.localNormal);\n        const planePoint = Transform.mulVec2(xfB, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const clipPoint = Transform.mulVec2(xfA, this.points[i].localPoint);\n          const cB = Vec2.combine(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);\n          const cA = Vec2.combine(1, clipPoint, -radiusA, normal);\n          points[i] = Vec2.mid(cA, cB);\n          separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);\n        }\n        points.length = this.pointCount;\n        separations.length = this.pointCount;\n        // Ensure normal points from A to B.\n        normal.mul(-1);\n        break;\n      }\n    }\n\n    wm.normal = normal;\n    wm.points = points;\n    wm.separations = separations;\n    return wm;\n  }\n\n  static clipSegmentToLine = clipSegmentToLine;\n  static ClipVertex = ClipVertex;\n  static getPointStates = getPointStates;\n  static PointState = PointState;\n}\n\n/**\n * A manifold point is a contact point belonging to a contact manifold. It holds\n * details related to the geometry and dynamics of the contact points.\n *\n * This structure is stored across time steps, so we keep it small.\n *\n * Note: impulses are used for internal caching and may not provide reliable\n * contact forces, especially for high speed collisions.\n */\nexport class ManifoldPoint {\n  /**\n   * Usage depends on manifold type.\n   *       e_circles: the local center of circleB,\n   *       e_faceA: the local center of cirlceB or the clip point of polygonB,\n   *       e_faceB: the clip point of polygonA.\n   */\n  localPoint: Vec2 = Vec2.zero();\n  /**\n   * The non-penetration impulse\n   */\n  normalImpulse: number = 0;\n  /**\n   * The friction impulse\n   */\n  tangentImpulse: number = 0;\n  /**\n   * Uniquely identifies a contact point between two shapes to facilatate warm starting\n   */\n  id: ContactID = new ContactID();\n}\n\n/**\n * Contact ids to facilitate warm starting.\n */\nexport class ContactID {\n  cf: ContactFeature = new ContactFeature();\n\n  /**\n   * Used to quickly compare contact ids.\n   */\n  get key(): number {\n    return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;\n  }\n\n  set(o: ContactID): void {\n    // this.key = o.key;\n    this.cf.set(o.cf);\n  }\n}\n\n/**\n * The features that intersect to form the contact point.\n */\nexport class ContactFeature {\n  /**\n   * Feature index on shapeA\n   */\n  indexA: number;\n  /**\n   * Feature index on shapeB\n   */\n  indexB: number;\n  /**\n   * The feature type on shapeA\n   */\n  typeA: ContactFeatureType;\n  /**\n   * The feature type on shapeB\n   */\n  typeB: ContactFeatureType;\n  set(o: ContactFeature): void {\n    this.indexA = o.indexA;\n    this.indexB = o.indexB;\n    this.typeA = o.typeA;\n    this.typeB = o.typeB;\n  }\n}\n\n/**\n * This is used to compute the current state of a contact manifold.\n */\nexport class WorldManifold {\n  /**\n   * World vector pointing from A to B\n   */\n  normal: Vec2;\n  /**\n   * World contact point (point of intersection)\n   */\n  points: Vec2[] = []; // [maxManifoldPoints]\n  /**\n   * A negative value indicates overlap, in meters\n   */\n  separations: number[] = []; // [maxManifoldPoints]\n}\n\n/**\n * Compute the point states given two manifolds. The states pertain to the\n * transition from manifold1 to manifold2. So state1 is either persist or remove\n * while state2 is either add or persist.\n */\nexport function getPointStates(\n  state1: PointState[],\n  state2: PointState[],\n  manifold1: Manifold,\n  manifold2: Manifold\n): void {\n  // state1, state2: PointState[Settings.maxManifoldPoints]\n\n  // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n  // state1[i] = PointState.nullState;\n  // state2[i] = PointState.nullState;\n  // }\n\n  // Detect persists and removes.\n  for (let i = 0; i < manifold1.pointCount; ++i) {\n    const id = manifold1.points[i].id;\n\n    state1[i] = PointState.removeState;\n\n    for (let j = 0; j < manifold2.pointCount; ++j) {\n      if (manifold2.points[j].id.key == id.key) {\n        state1[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n\n  // Detect persists and adds.\n  for (let i = 0; i < manifold2.pointCount; ++i) {\n    const id = manifold2.points[i].id;\n\n    state2[i] = PointState.addState;\n\n    for (let j = 0; j < manifold1.pointCount; ++j) {\n      if (manifold1.points[j].id.key == id.key) {\n        state2[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n */\nexport function clipSegmentToLine(\n  vOut: ClipVertex[],\n  vIn: ClipVertex[],\n  normal: Vec2,\n  offset: number,\n  vertexIndexA: number\n): number {\n  // Start with no output points\n  let numOut = 0;\n\n  // Calculate the distance of end points to the line\n  const distance0 = Vec2.dot(normal, vIn[0].v) - offset;\n  const distance1 = Vec2.dot(normal, vIn[1].v) - offset;\n\n  // If the points are behind the plane\n  if (distance0 <= 0.0)\n    vOut[numOut++].set(vIn[0]);\n  if (distance1 <= 0.0)\n    vOut[numOut++].set(vIn[1]);\n\n  // If the points are on different sides of the plane\n  if (distance0 * distance1 < 0.0) {\n    // Find intersection point of edge and plane\n    const interp = distance0 / (distance0 - distance1);\n    vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);\n\n    // VertexA is hitting edgeB.\n    vOut[numOut].id.cf.indexA = vertexIndexA;\n    vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;\n    vOut[numOut].id.cf.typeA = ContactFeatureType.e_vertex;\n    vOut[numOut].id.cf.typeB = ContactFeatureType.e_face;\n    ++numOut;\n  }\n\n  return numOut;\n}\n","export default {\n  gjkCalls: 0,\n  gjkIters: 0,\n  gjkMaxIters: 0,\n\n  toiTime: 0,\n  toiMaxTime: 0,\n  toiCalls: 0,\n  toiIters: 0,\n  toiMaxIters: 0,\n  toiRootIters: 0,\n  toiMaxRootIters: 0,\n\n  toString(newline?: string): string {\n    newline = typeof newline === 'string' ? newline : '\\n';\n    let string = \"\";\n    // tslint:disable-next-line:no-for-in\n    for (const name in this) {\n      if (typeof this[name] !== 'function' && typeof this[name] !== 'object') {\n        string += name + ': ' + this[name] + newline;\n      }\n    }\n    return string;\n  }\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Settings from '../Settings';\nimport stats from '../util/stats';\nimport common from '../util/common';\n\nimport Shape from './Shape';\nimport Math from '../common/Math';\nimport Vec2 from '../common/Vec2';\nimport Rot from '../common/Rot';\nimport Transform from '../common/Transform';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n */\n\nstats.gjkCalls = 0;\nstats.gjkIters = 0;\nstats.gjkMaxIters = 0;\n\n/**\n * Input for Distance. You have to option to use the shape radii in the\n * computation. Even\n */\nexport class DistanceInput {\n  proxyA: DistanceProxy = new DistanceProxy();\n  proxyB: DistanceProxy = new DistanceProxy();\n  transformA: Transform | null = null;\n  transformB: Transform | null = null;\n  useRadii: boolean = false;\n}\n\n/**\n * Output for Distance.\n *\n * @prop {Vec2} pointA closest point on shapeA\n * @prop {Vec2} pointB closest point on shapeB\n * @prop distance\n * @prop iterations number of GJK iterations used\n */\nexport class DistanceOutput {\n  pointA: Vec2 = Vec2.zero();\n  pointB: Vec2 = Vec2.zero();\n  distance: number;\n  iterations: number;\n}\n\n/**\n * Used to warm start Distance. Set count to zero on first call.\n *\n * @prop {number} metric length or area\n * @prop {array} indexA vertices on shape A\n * @prop {array} indexB vertices on shape B\n * @prop {number} count\n */\nexport class SimplexCache {\n  metric: number = 0;\n  indexA: number[] = [];\n  indexB: number[] = [];\n  count: number = 0;\n}\n\n/**\n * Compute the closest points between two shapes. Supports any combination of:\n * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n * the first call set SimplexCache.count to zero.\n */\nexport default function Distance(output: DistanceOutput, cache: SimplexCache, input: DistanceInput): void {\n  ++stats.gjkCalls;\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  // Initialize the simplex.\n  const simplex = new Simplex();\n  simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n  const k_maxIters = Settings.maxDistnceIterations;\n\n  // These store the vertices of the last simplex so that we\n  // can check for duplicates and prevent cycling.\n  const saveA = [];\n  const saveB = []; // int[3]\n  let saveCount = 0;\n\n  let distanceSqr1 = Infinity;\n  let distanceSqr2 = Infinity;\n\n  // Main iteration loop.\n  let iter = 0;\n  while (iter < k_maxIters) {\n    // Copy simplex so we can identify duplicates.\n    saveCount = simplex.m_count;\n    for (let i = 0; i < saveCount; ++i) {\n      saveA[i] = vertices[i].indexA;\n      saveB[i] = vertices[i].indexB;\n    }\n\n    simplex.solve();\n\n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count === 3) {\n      break;\n    }\n\n    // Compute closest point.\n    const p = simplex.getClosestPoint();\n    distanceSqr2 = p.lengthSquared();\n\n    // Ensure progress\n    if (distanceSqr2 >= distanceSqr1) {\n      // break;\n    }\n    distanceSqr1 = distanceSqr2;\n\n    // Get search direction.\n    const d = simplex.getSearchDirection();\n\n    // Ensure the search direction is numerically fit.\n    if (d.lengthSquared() < Math.EPSILON * Math.EPSILON) {\n      // The origin is probably contained by a line segment\n      // or triangle. Thus the shapes are overlapped.\n\n      // We can't return zero here even though there may be overlap.\n      // In case the simplex is a point, segment, or triangle it is difficult\n      // to determine if the origin is contained in the CSO or very close to it.\n      break;\n    }\n\n    // Compute a tentative new simplex vertex using support points.\n    const vertex = vertices[simplex.m_count]; // SimplexVertex\n\n    vertex.indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(d)));\n    vertex.wA = Transform.mulVec2(xfA, proxyA.getVertex(vertex.indexA));\n\n    vertex.indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, d));\n    vertex.wB = Transform.mulVec2(xfB, proxyB.getVertex(vertex.indexB));\n\n    vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n    ++stats.gjkIters;\n\n    // Check for duplicate support points. This is the main termination\n    // criteria.\n    let duplicate = false;\n    for (let i = 0; i < saveCount; ++i) {\n      if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n        duplicate = true;\n        break;\n      }\n    }\n\n    // If we found a duplicate support point we must exit to avoid cycling.\n    if (duplicate) {\n      break;\n    }\n\n    // New vertex is ok and needed.\n    ++simplex.m_count;\n  }\n\n  stats.gjkMaxIters = Math.max(stats.gjkMaxIters, iter);\n\n  // Prepare output.\n  simplex.getWitnessPoints(output.pointA, output.pointB);\n  output.distance = Vec2.distance(output.pointA, output.pointB);\n  output.iterations = iter;\n\n  // Cache the simplex.\n  simplex.writeCache(cache);\n\n  // Apply radii if requested.\n  if (input.useRadii) {\n    const rA = proxyA.m_radius;\n    const rB = proxyB.m_radius;\n\n    if (output.distance > rA + rB && output.distance > Math.EPSILON) {\n      // Shapes are still no overlapped.\n      // Move the witness points to the outer surface.\n      output.distance -= rA + rB;\n      const normal = Vec2.sub(output.pointB, output.pointA);\n      normal.normalize();\n      output.pointA.addMul(rA, normal);\n      output.pointB.subMul(rB, normal);\n    } else {\n      // Shapes are overlapped when radii are considered.\n      // Move the witness points to the middle.\n      const p = Vec2.mid(output.pointA, output.pointB);\n      output.pointA.setVec2(p);\n      output.pointB.setVec2(p);\n      output.distance = 0.0;\n    }\n  }\n}\n\n/**\n * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n */\nexport class DistanceProxy {\n  /** internal */ m_buffer: Vec2[];\n  /** internal */ m_vertices: Vec2[];\n  /** internal */ m_count: number;\n  /** internal */ m_radius: number;\n\n\n  constructor() {\n    this.m_buffer = []; // Vec2[2]\n    this.m_vertices = []; // Vec2[]\n    this.m_count = 0;\n    this.m_radius = 0;\n  }\n\n  /**\n   * Get the vertex count.\n   */\n  getVertexCount(): number {\n    return this.m_count;\n  }\n\n  /**\n   * Get a vertex by index. Used by Distance.\n   */\n  getVertex(index: number): Vec2 {\n    _ASSERT && common.assert(0 <= index && index < this.m_count);\n    return this.m_vertices[index];\n  }\n\n  /**\n   * Get the supporting vertex index in the given direction.\n   */\n  getSupport(d: Vec2): number {\n    let bestIndex = 0;\n    let bestValue = Vec2.dot(this.m_vertices[0], d);\n    for (let i = 0; i < this.m_count; ++i) {\n      const value = Vec2.dot(this.m_vertices[i], d);\n      if (value > bestValue) {\n        bestIndex = i;\n        bestValue = value;\n      }\n    }\n    return bestIndex;\n  }\n\n  /**\n   * Get the supporting vertex in the given direction.\n   */\n  getSupportVertex(d: Vec2): Vec2 {\n    return this.m_vertices[this.getSupport(d)];\n  }\n\n  /**\n   * Initialize the proxy using the given shape. The shape must remain in scope\n   * while the proxy is in use.\n   */\n  set(shape: Shape, index: number): void {\n    // TODO remove, use shape instead\n    _ASSERT && common.assert(typeof shape.computeDistanceProxy === 'function');\n    shape.computeDistanceProxy(this, index);\n  }\n}\n\nclass SimplexVertex {\n  /** support point in proxyA */\n  wA: Vec2 = Vec2.zero();\n  /** wA index */\n  indexA: number;\n\n  /** support point in proxyB */\n  wB: Vec2 = Vec2.zero();\n  /** wB index */\n  indexB: number;\n\n  /** wB - wA; */\n  w: Vec2 = Vec2.zero();\n  /** barycentric coordinate for closest point */\n  a: number;\n\n  set(v: SimplexVertex): void {\n    this.indexA = v.indexA;\n    this.indexB = v.indexB;\n    this.wA = Vec2.clone(v.wA);\n    this.wB = Vec2.clone(v.wB);\n    this.w = Vec2.clone(v.w);\n    this.a = v.a;\n  }\n}\n\nclass Simplex {\n  m_v1: SimplexVertex;\n  m_v2: SimplexVertex;\n  m_v3: SimplexVertex;\n  m_v: SimplexVertex[];\n  m_count: number;\n\n  constructor() {\n    this.m_v1 = new SimplexVertex();\n    this.m_v2 = new SimplexVertex();\n    this.m_v3 = new SimplexVertex();\n    this.m_v = [ this.m_v1, this.m_v2, this.m_v3 ];\n    this.m_count;\n  }\n\n  /** @internal */\n  toString(): string {\n    if (this.m_count === 3) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,\n        this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y\n      ].toString();\n\n    } else if (this.m_count === 2) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y\n      ].toString();\n\n    } else if (this.m_count === 1) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y\n      ].toString();\n\n    } else {\n      return \"+\" + this.m_count;\n    }\n  }\n\n  readCache(cache: SimplexCache, proxyA: DistanceProxy, transformA: Transform, proxyB: DistanceProxy, transformB: Transform): void {\n    _ASSERT && common.assert(cache.count <= 3);\n\n    // Copy data from cache.\n    this.m_count = cache.count;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = this.m_v[i];\n      v.indexA = cache.indexA[i];\n      v.indexB = cache.indexB[i];\n      const wALocal = proxyA.getVertex(v.indexA);\n      const wBLocal = proxyB.getVertex(v.indexB);\n      v.wA = Transform.mulVec2(transformA, wALocal);\n      v.wB = Transform.mulVec2(transformB, wBLocal);\n      v.w = Vec2.sub(v.wB, v.wA);\n      v.a = 0.0;\n    }\n\n    // Compute the new simplex metric, if it is substantially different than\n    // old metric then flush the simplex.\n    if (this.m_count > 1) {\n      const metric1 = cache.metric;\n      const metric2 = this.getMetric();\n      if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2\n        || metric2 < Math.EPSILON) {\n        // Reset the simplex.\n        this.m_count = 0;\n      }\n    }\n\n    // If the cache is empty or invalid...\n    if (this.m_count === 0) {\n      const v = this.m_v[0];\n      v.indexA = 0;\n      v.indexB = 0;\n      const wALocal = proxyA.getVertex(0);\n      const wBLocal = proxyB.getVertex(0);\n      v.wA = Transform.mulVec2(transformA, wALocal);\n      v.wB = Transform.mulVec2(transformB, wBLocal);\n      v.w = Vec2.sub(v.wB, v.wA);\n      v.a = 1.0;\n      this.m_count = 1;\n    }\n  }\n\n  writeCache(cache: SimplexCache): void {\n    cache.metric = this.getMetric();\n    cache.count = this.m_count;\n    for (let i = 0; i < this.m_count; ++i) {\n      cache.indexA[i] = this.m_v[i].indexA;\n      cache.indexB[i] = this.m_v[i].indexB;\n    }\n  }\n\n  getSearchDirection(): Vec2 {\n    switch (this.m_count) {\n      case 1:\n        return Vec2.neg(this.m_v1.w);\n\n      case 2: {\n        const e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);\n        const sgn = Vec2.crossVec2Vec2(e12, Vec2.neg(this.m_v1.w));\n        if (sgn > 0.0) {\n          // Origin is left of e12.\n          return Vec2.crossNumVec2(1.0, e12);\n        } else {\n          // Origin is right of e12.\n          return Vec2.crossVec2Num(e12, 1.0);\n        }\n      }\n\n      default:\n        _ASSERT && common.assert(false);\n        return Vec2.zero();\n    }\n  }\n\n  getClosestPoint(): Vec2 {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && common.assert(false);\n        return Vec2.zero();\n\n      case 1:\n        return Vec2.clone(this.m_v1.w);\n\n      case 2:\n        return Vec2.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);\n\n      case 3:\n        return Vec2.zero();\n\n      default:\n        _ASSERT && common.assert(false);\n        return Vec2.zero();\n    }\n  }\n\n  getWitnessPoints(pA: Vec2, pB: Vec2): void {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && common.assert(false);\n        break;\n\n      case 1:\n        pA.setVec2(this.m_v1.wA);\n        pB.setVec2(this.m_v1.wB);\n        break;\n\n      case 2:\n        pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n        pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);\n        break;\n\n      case 3:\n        pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);\n        pA.addMul(this.m_v3.a, this.m_v3.wA);\n        pB.setVec2(pA);\n        break;\n\n      default:\n        _ASSERT && common.assert(false);\n        break;\n    }\n  }\n\n  getMetric(): number {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && common.assert(false);\n        return 0.0;\n\n      case 1:\n        return 0.0;\n\n      case 2:\n        return Vec2.distance(this.m_v1.w, this.m_v2.w);\n\n      case 3:\n        return Vec2.crossVec2Vec2(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w,\n          this.m_v1.w));\n\n      default:\n        _ASSERT && common.assert(false);\n        return 0.0;\n    }\n  }\n\n  solve(): void {\n    switch (this.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        this.solve2();\n        break;\n\n      case 3:\n        this.solve3();\n        break;\n\n      default:\n        _ASSERT && common.assert(false);\n    }\n  }\n\n// Solve a line segment using barycentric coordinates.\n//\n// p = a1 * w1 + a2 * w2\n// a1 + a2 = 1\n//\n// The vector from the origin to the closest point on the line is\n// perpendicular to the line.\n// e12 = w2 - w1\n// dot(p, e) = 0\n// a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n//\n// 2-by-2 linear system\n// [1 1 ][a1] = [1]\n// [w1.e12 w2.e12][a2] = [0]\n//\n// Define\n// d12_1 = dot(w2, e12)\n// d12_2 = -dot(w1, e12)\n// d12 = d12_1 + d12_2\n//\n// Solution\n// a1 = d12_1 / d12\n// a2 = d12_2 / d12\n  solve2(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    const e12 = Vec2.sub(w2, w1);\n\n    // w1 region\n    const d12_2 = -Vec2.dot(w1, e12);\n    if (d12_2 <= 0.0) {\n      // a2 <= 0, so we clamp it to 0\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // w2 region\n    const d12_1 = Vec2.dot(w2, e12);\n    if (d12_1 <= 0.0) {\n      // a1 <= 0, so we clamp it to 0\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // Must be in e12 region.\n    const inv_d12 = 1.0 / (d12_1 + d12_2);\n    this.m_v1.a = d12_1 * inv_d12;\n    this.m_v2.a = d12_2 * inv_d12;\n    this.m_count = 2;\n  }\n\n// Possible regions:\n// - points[2]\n// - edge points[0]-points[2]\n// - edge points[1]-points[2]\n// - inside the triangle\n  solve3(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    const w3 = this.m_v3.w;\n\n    // Edge12\n    // [1 1 ][a1] = [1]\n    // [w1.e12 w2.e12][a2] = [0]\n    // a3 = 0\n    const e12 = Vec2.sub(w2, w1);\n    const w1e12 = Vec2.dot(w1, e12);\n    const w2e12 = Vec2.dot(w2, e12);\n    const d12_1 = w2e12;\n    const d12_2 = -w1e12;\n\n    // Edge13\n    // [1 1 ][a1] = [1]\n    // [w1.e13 w3.e13][a3] = [0]\n    // a2 = 0\n    const e13 = Vec2.sub(w3, w1);\n    const w1e13 = Vec2.dot(w1, e13);\n    const w3e13 = Vec2.dot(w3, e13);\n    const d13_1 = w3e13;\n    const d13_2 = -w1e13;\n\n    // Edge23\n    // [1 1 ][a2] = [1]\n    // [w2.e23 w3.e23][a3] = [0]\n    // a1 = 0\n    const e23 = Vec2.sub(w3, w2);\n    const w2e23 = Vec2.dot(w2, e23);\n    const w3e23 = Vec2.dot(w3, e23);\n    const d23_1 = w3e23;\n    const d23_2 = -w2e23;\n\n    // Triangle123\n    const n123 = Vec2.crossVec2Vec2(e12, e13);\n\n    const d123_1 = n123 * Vec2.crossVec2Vec2(w2, w3);\n    const d123_2 = n123 * Vec2.crossVec2Vec2(w3, w1);\n    const d123_3 = n123 * Vec2.crossVec2Vec2(w1, w2);\n\n    // w1 region\n    if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // e12\n    if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n      const inv_d12 = 1.0 / (d12_1 + d12_2);\n      this.m_v1.a = d12_1 * inv_d12;\n      this.m_v2.a = d12_2 * inv_d12;\n      this.m_count = 2;\n      return;\n    }\n\n    // e13\n    if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n      const inv_d13 = 1.0 / (d13_1 + d13_2);\n      this.m_v1.a = d13_1 * inv_d13;\n      this.m_v3.a = d13_2 * inv_d13;\n      this.m_count = 2;\n      this.m_v2.set(this.m_v3);\n      return;\n    }\n\n    // w2 region\n    if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // w3 region\n    if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n      this.m_v3.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // e23\n    if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n      const inv_d23 = 1.0 / (d23_1 + d23_2);\n      this.m_v2.a = d23_1 * inv_d23;\n      this.m_v3.a = d23_2 * inv_d23;\n      this.m_count = 2;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // Must be in triangle123\n    const inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n    this.m_v1.a = d123_1 * inv_d123;\n    this.m_v2.a = d123_2 * inv_d123;\n    this.m_v3.a = d123_3 * inv_d123;\n    this.m_count = 3;\n  }\n}\n\n\n/**\n * Determine if two generic shapes overlap.\n */\nexport function testOverlap(shapeA: Shape, indexA: number, shapeB: Shape, indexB: number, xfA: Transform, xfB: Transform): boolean {\n  const input = new DistanceInput();\n  input.proxyA.set(shapeA, indexA);\n  input.proxyB.set(shapeB, indexB);\n  input.transformA = xfA;\n  input.transformB = xfB;\n  input.useRadii = true;\n\n  const cache = new SimplexCache();\n  const output = new DistanceOutput();\n\n  Distance(output, cache, input);\n\n  return output.distance < 10.0 * Math.EPSILON;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { ShapeType } from \"../collision/Shape\";\nimport common from '../util/common';\nimport Math from '../common/Math';\nimport Vec2 from '../common/Vec2';\nimport Transform from '../common/Transform';\nimport Mat22 from '../common/Mat22';\nimport Rot from '../common/Rot';\nimport Settings from '../Settings';\nimport Manifold, { ManifoldType, WorldManifold } from '../collision/Manifold';\nimport { testOverlap } from '../collision/Distance';\nimport Fixture from \"./Fixture\";\nimport Body from \"./Body\";\nimport { ContactImpulse, TimeStep } from \"./Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst DEBUG_SOLVER = false;\n\n/**\n * A contact edge is used to connect bodies and contacts together in a contact\n * graph where each body is a node and each contact is an edge. A contact edge\n * belongs to a doubly linked list maintained in each attached body. Each\n * contact has two contact nodes, one for each attached body.\n *\n * @prop {Contact} contact The contact\n * @prop {ContactEdge} prev The previous contact edge in the body's contact list\n * @prop {ContactEdge} next The next contact edge in the body's contact list\n * @prop {Body} other Provides quick access to the other body attached.\n */\nexport class ContactEdge {\n  contact: Contact;\n  prev: ContactEdge | undefined;\n  next: ContactEdge | undefined;\n  other: Body | undefined;\n  constructor(contact: Contact) {\n    this.contact = contact;\n  }\n}\n\nexport type EvaluateFunction = (\n  manifold: Manifold,\n  xfA: Transform,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: Transform,\n  fixtureB: Fixture,\n  indexB: number\n) => void;\n\nexport type ContactCallback = (\n  manifold: Manifold,\n  xfA: Transform,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: Transform,\n  fixtureB: Fixture,\n  indexB: number\n) => void /* & { destroyFcn?: (contact: Contact) => void }*/;\n\n\n/**\n * Friction mixing law. The idea is to allow either fixture to drive the\n * restitution to zero. For example, anything slides on ice.\n */\nexport function mixFriction(friction1: number, friction2: number): number {\n  return Math.sqrt(friction1 * friction2);\n}\n\n/**\n * Restitution mixing law. The idea is allow for anything to bounce off an\n * inelastic surface. For example, a superball bounces on anything.\n */\nexport function mixRestitution(restitution1: number, restitution2: number): number {\n  return restitution1 > restitution2 ? restitution1 : restitution2;\n}\n\n// TODO: move this to Settings?\nconst s_registers = [];\n\n// TODO: merge with ManifoldPoint?\nexport class VelocityConstraintPoint {\n  rA: Vec2 = Vec2.zero();\n  rB: Vec2 = Vec2.zero();\n  normalImpulse: number = 0;\n  tangentImpulse: number = 0;\n  normalMass: number = 0;\n  tangentMass: number = 0;\n  velocityBias: number = 0;\n}\n\n/**\n * The class manages contact between two shapes. A contact exists for each\n * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n * object may exist that has no contact points.\n */\nexport default class Contact {\n  /** @internal */\n  m_nodeA: ContactEdge;\n  /** @internal */\n  m_nodeB: ContactEdge;\n  /** @internal */\n  m_fixtureA: Fixture;\n  /** @internal */\n  m_fixtureB: Fixture;\n  /** @internal */\n  m_indexA: number;\n  /** @internal */\n  m_indexB: number;\n  /** @internal */\n  m_evaluateFcn: EvaluateFunction;\n  /** @internal */\n  m_manifold: Manifold = new Manifold();\n  /** @internal */\n  m_prev: Contact | null = null;\n  /** @internal */\n  m_next: Contact | null = null;\n  /** @internal */\n  m_toi: number = 1.0;\n  /** @internal */\n  m_toiCount: number = 0;\n  /** @internal This contact has a valid TOI in m_toi */\n  m_toiFlag: boolean = false;\n  /** @internal */\n  m_friction: number;\n  /** @internal */\n  m_restitution: number;\n  /** @internal */\n  m_tangentSpeed: number = 0.0;\n  /** @internal This contact can be disabled (by user) */\n  m_enabledFlag: boolean = true;\n  /** @internal Used when crawling contact graph when forming islands. */\n  m_islandFlag: boolean = false;\n  /** @internal Set when the shapes are touching. */\n  m_touchingFlag: boolean = false;\n  /** @internal This contact needs filtering because a fixture filter was changed. */\n  m_filterFlag: boolean = false;\n  /** @internal This bullet contact had a TOI event */\n  m_bulletHitFlag: boolean = false;\n\n  /** @internal Contact reporting impulse object cache */\n  m_impulse: ContactImpulse = new ContactImpulse(this);\n\n  // VelocityConstraint\n  /** @internal */ v_points: VelocityConstraintPoint[] = []; // [maxManifoldPoints];\n  /** @internal */ v_normal: Vec2 = Vec2.zero();\n  /** @internal */ v_normalMass: Mat22 = new Mat22();\n  /** @internal */ v_K: Mat22 = new Mat22();\n  /** @internal */ v_pointCount: number;\n  /** @internal */ v_tangentSpeed: number | undefined;\n  /** @internal */ v_friction: number | undefined;\n  /** @internal */ v_restitution: number | undefined;\n  /** @internal */ v_invMassA: number | undefined;\n  /** @internal */ v_invMassB: number | undefined;\n  /** @internal */ v_invIA: number | undefined;\n  /** @internal */ v_invIB: number | undefined;\n\n  // PositionConstraint\n  /** @internal */ p_localPoints: Vec2[] = []; // [maxManifoldPoints];\n  /** @internal */ p_localNormal: Vec2 = Vec2.zero();\n  /** @internal */ p_localPoint: Vec2 = Vec2.zero();\n  /** @internal */ p_localCenterA: Vec2 = Vec2.zero();\n  /** @internal */ p_localCenterB: Vec2 = Vec2.zero();\n  /** @internal */ p_type: ManifoldType | undefined;\n  /** @internal */ p_radiusA: number | undefined;\n  /** @internal */ p_radiusB: number | undefined;\n  /** @internal */ p_pointCount: number | undefined;\n  /** @internal */ p_invMassA: number | undefined;\n  /** @internal */ p_invMassB: number | undefined;\n  /** @internal */ p_invIA: number | undefined;\n  /** @internal */ p_invIB: number | undefined;\n\n  constructor(fA: Fixture, indexA: number, fB: Fixture, indexB: number, evaluateFcn: EvaluateFunction) {\n    // Nodes for connecting bodies.\n    this.m_nodeA = new ContactEdge(this);\n    this.m_nodeB = new ContactEdge(this);\n\n    this.m_fixtureA = fA;\n    this.m_fixtureB = fB;\n\n    this.m_indexA = indexA;\n    this.m_indexB = indexB;\n\n    this.m_evaluateFcn = evaluateFcn;\n\n    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n  }\n\n  initConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const shapeA = fixtureA.getShape();\n    const shapeB = fixtureB.getShape();\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const manifold = this.getManifold();\n\n    const pointCount = manifold.pointCount;\n    _ASSERT && common.assert(pointCount > 0);\n\n    this.v_invMassA = bodyA.m_invMass;\n    this.v_invMassB = bodyB.m_invMass;\n    this.v_invIA = bodyA.m_invI;\n    this.v_invIB = bodyB.m_invI;\n\n    this.v_friction = this.m_friction;\n    this.v_restitution = this.m_restitution;\n    this.v_tangentSpeed = this.m_tangentSpeed;\n\n    this.v_pointCount = pointCount;\n\n    this.v_K.setZero();\n    this.v_normalMass.setZero();\n\n    this.p_invMassA = bodyA.m_invMass;\n    this.p_invMassB = bodyB.m_invMass;\n    this.p_invIA = bodyA.m_invI;\n    this.p_invIB = bodyB.m_invI;\n    this.p_localCenterA = Vec2.clone(bodyA.m_sweep.localCenter);\n    this.p_localCenterB = Vec2.clone(bodyB.m_sweep.localCenter);\n\n    this.p_radiusA = shapeA.m_radius;\n    this.p_radiusB = shapeB.m_radius;\n\n    this.p_type = manifold.type;\n    this.p_localNormal = Vec2.clone(manifold.localNormal);\n    this.p_localPoint = Vec2.clone(manifold.localPoint);\n    this.p_pointCount = pointCount;\n\n    for (let j = 0; j < pointCount; ++j) {\n      const cp = manifold.points[j];\n      const vcp = this.v_points[j] = new VelocityConstraintPoint();\n\n      if (step.warmStarting) {\n        vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n        vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n\n      } else {\n        vcp.normalImpulse = 0.0;\n        vcp.tangentImpulse = 0.0;\n      }\n\n      vcp.rA.setZero();\n      vcp.rB.setZero();\n      vcp.normalMass = 0.0;\n      vcp.tangentMass = 0.0;\n      vcp.velocityBias = 0.0;\n\n      this.p_localPoints[j] = Vec2.clone(cp.localPoint);\n\n    }\n  }\n\n  /**\n   * Get the contact manifold. Do not modify the manifold unless you understand\n   * the internals of the library.\n   */\n  getManifold(): Manifold {\n    return this.m_manifold;\n  }\n\n  /**\n   * Get the world manifold.\n   */\n  getWorldManifold(worldManifold: WorldManifold | null | undefined): WorldManifold | undefined {\n    const bodyA = this.m_fixtureA.getBody();\n    const bodyB = this.m_fixtureB.getBody();\n    const shapeA = this.m_fixtureA.getShape();\n    const shapeB = this.m_fixtureB.getShape();\n\n    return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(),\n      shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);\n  }\n\n  /**\n   * Enable/disable this contact. This can be used inside the pre-solve contact\n   * listener. The contact is only disabled for the current time step (or sub-step\n   * in continuous collisions).\n   */\n  setEnabled(flag: boolean): void {\n    this.m_enabledFlag = !!flag;\n  }\n\n  /**\n   * Has this contact been disabled?\n   */\n  isEnabled(): boolean {\n    return this.m_enabledFlag;\n  }\n\n  /**\n   * Is this contact touching?\n   */\n  isTouching(): boolean {\n    return this.m_touchingFlag;\n  }\n\n  /**\n   * Get the next contact in the world's contact list.\n   */\n  getNext(): Contact | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get fixture A in this contact.\n   */\n  getFixtureA(): Fixture {\n    return this.m_fixtureA;\n  }\n\n  /**\n   * Get fixture B in this contact.\n   */\n  getFixtureB(): Fixture {\n    return this.m_fixtureB;\n  }\n\n  /**\n   * Get the child primitive index for fixture A.\n   */\n  getChildIndexA(): number {\n    return this.m_indexA;\n  }\n\n  /**\n   * Get the child primitive index for fixture B.\n   */\n  getChildIndexB(): number {\n    return this.m_indexB;\n  }\n\n  /**\n   * Flag this contact for filtering. Filtering will occur the next time step.\n   */\n  flagForFiltering(): void {\n    this.m_filterFlag = true;\n  }\n\n  /**\n   * Override the default friction mixture. You can call this in\n   * ContactListener.preSolve. This value persists until set or reset.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the friction.\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Reset the friction mixture to the default value.\n   */\n  resetFriction(): void {\n    this.m_friction = mixFriction(this.m_fixtureA.m_friction,\n      this.m_fixtureB.m_friction);\n  }\n\n  /**\n   * Override the default restitution mixture. You can call this in\n   * ContactListener.preSolve. The value persists until you set or reset.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Get the restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Reset the restitution to the default value.\n   */\n  resetRestitution(): void {\n    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution,\n      this.m_fixtureB.m_restitution);\n  }\n\n  /**\n   * Set the desired tangent speed for a conveyor belt behavior. In meters per\n   * second.\n   */\n  setTangentSpeed(speed: number): void {\n    this.m_tangentSpeed = speed;\n  }\n\n  /**\n   * Get the desired tangent speed. In meters per second.\n   */\n  getTangentSpeed(): number {\n    return this.m_tangentSpeed;\n  }\n\n  /**\n   * Called by Update method, and implemented by subclasses.\n   */\n  evaluate(manifold: Manifold, xfA: Transform, xfB: Transform): void {\n    this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB,\n      this.m_fixtureB, this.m_indexB);\n  }\n\n  /**\n   * Updates the contact manifold and touching status.\n   *\n   * Note: do not assume the fixture AABBs are overlapping or are valid.\n   *\n   * @param listener.beginContact\n   * @param listener.endContact\n   * @param listener.preSolve\n   */\n  update(listener?: {\n    beginContact(contact: Contact): void,\n    endContact(contact: Contact): void,\n    preSolve(contact: Contact, oldManifold: Manifold): void\n  }): void {\n\n    // Re-enable this contact.\n    this.m_enabledFlag = true;\n\n    let touching = false;\n    const wasTouching = this.m_touchingFlag;\n\n    const sensorA = this.m_fixtureA.isSensor();\n    const sensorB = this.m_fixtureB.isSensor();\n    const sensor = sensorA || sensorB;\n\n    const bodyA = this.m_fixtureA.getBody();\n    const bodyB = this.m_fixtureB.getBody();\n    const xfA = bodyA.getTransform();\n    const xfB = bodyB.getTransform();\n\n    let oldManifold;\n\n    // Is this contact a sensor?\n    if (sensor) {\n      const shapeA = this.m_fixtureA.getShape();\n      const shapeB = this.m_fixtureB.getShape();\n      touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n\n      // Sensors don't generate manifolds.\n      this.m_manifold.pointCount = 0;\n    } else {\n\n      // TODO reuse manifold\n      oldManifold = this.m_manifold;\n      this.m_manifold = new Manifold();\n\n      this.evaluate(this.m_manifold, xfA, xfB);\n      touching = this.m_manifold.pointCount > 0;\n\n      // Match old contact ids to new contact ids and copy the\n      // stored impulses to warm start the solver.\n      for (let i = 0; i < this.m_manifold.pointCount; ++i) {\n        const nmp = this.m_manifold.points[i];\n        nmp.normalImpulse = 0.0;\n        nmp.tangentImpulse = 0.0;\n\n        for (let j = 0; j < oldManifold.pointCount; ++j) {\n          const omp = oldManifold.points[j];\n          if (omp.id.key == nmp.id.key) {\n            nmp.normalImpulse = omp.normalImpulse;\n            nmp.tangentImpulse = omp.tangentImpulse;\n            break;\n          }\n        }\n      }\n\n      if (touching != wasTouching) {\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n      }\n    }\n\n    this.m_touchingFlag = touching;\n\n    if (!wasTouching && touching && listener) {\n      listener.beginContact(this);\n    }\n\n    if (wasTouching && !touching && listener) {\n      listener.endContact(this);\n    }\n\n    if (!sensor && touching && listener) {\n      listener.preSolve(this, oldManifold);\n    }\n  }\n\n  solvePositionConstraint(step: TimeStep): number {\n    return this._solvePositionConstraint(step);\n  }\n\n  solvePositionConstraintTOI(step: TimeStep, toiA: Body, toiB: Body): number {\n    return this._solvePositionConstraint(step, toiA, toiB);\n  }\n\n  private _solvePositionConstraint(step: TimeStep, toiA?: Body, toiB?: Body): number {\n    const toi: boolean = !!toiA && !!toiB;\n\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const localCenterA = Vec2.clone(this.p_localCenterA);\n    const localCenterB = Vec2.clone(this.p_localCenterB);\n\n    let mA = 0.0;\n    let iA = 0.0;\n    if (!toi || (bodyA == toiA || bodyA == toiB)) {\n      mA = this.p_invMassA;\n      iA = this.p_invIA;\n    }\n\n    let mB = 0.0;\n    let iB = 0.0;\n    if (!toi || (bodyB == toiA || bodyB == toiB)) {\n      mB = this.p_invMassB;\n      iB = this.p_invIB;\n    }\n\n    const cA = Vec2.clone(positionA.c);\n    let aA = positionA.a;\n\n    const cB = Vec2.clone(positionB.c);\n    let aB = positionB.a;\n\n    let minSeparation = 0.0;\n\n    // Solve normal constraints\n    for (let j = 0; j < this.p_pointCount; ++j) {\n      const xfA = Transform.identity();\n      const xfB = Transform.identity();\n      xfA.q.setAngle(aA);\n      xfB.q.setAngle(aB);\n      xfA.p = Vec2.sub(cA, Rot.mulVec2(xfA.q, localCenterA));\n      xfB.p = Vec2.sub(cB, Rot.mulVec2(xfB.q, localCenterB));\n\n      // PositionSolverManifold\n      let normal;\n      let point;\n      let separation;\n      switch (this.p_type) {\n        case ManifoldType.e_circles: {\n          const pointA = Transform.mulVec2(xfA, this.p_localPoint);\n          const pointB = Transform.mulVec2(xfB, this.p_localPoints[0]);\n          normal = Vec2.sub(pointB, pointA);\n          normal.normalize();\n          point = Vec2.combine(0.5, pointA, 0.5, pointB);\n          separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA - this.p_radiusB;\n          break;\n        }\n\n        case ManifoldType.e_faceA: {\n          normal = Rot.mulVec2(xfA.q, this.p_localNormal);\n          const planePoint = Transform.mulVec2(xfA, this.p_localPoint);\n          const clipPoint = Transform.mulVec2(xfB, this.p_localPoints[j]);\n          separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n          point = clipPoint;\n          break;\n        }\n\n        case ManifoldType.e_faceB: {\n          normal = Rot.mulVec2(xfB.q, this.p_localNormal);\n          const planePoint = Transform.mulVec2(xfB, this.p_localPoint);\n          const clipPoint = Transform.mulVec2(xfA, this.p_localPoints[j]);\n          separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal) - this.p_radiusA - this.p_radiusB;\n          point = clipPoint;\n\n          // Ensure normal points from A to B\n          normal.mul(-1);\n          break;\n        }\n      }\n\n      const rA = Vec2.sub(point, cA);\n      const rB = Vec2.sub(point, cB);\n\n      // Track max constraint error.\n      minSeparation = Math.min(minSeparation, separation);\n\n      const baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n      const linearSlop = Settings.linearSlop;\n      const maxLinearCorrection = Settings.maxLinearCorrection;\n\n      // Prevent large corrections and allow slop.\n      const C = Math.clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n\n      // Compute the effective mass.\n      const rnA = Vec2.crossVec2Vec2(rA, normal);\n      const rnB = Vec2.crossVec2Vec2(rB, normal);\n      const K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      // Compute normal impulse\n      const impulse = K > 0.0 ? -C / K : 0.0;\n\n      const P = Vec2.mulNumVec2(impulse, normal);\n\n      cA.subMul(mA, P);\n      aA -= iA * Vec2.crossVec2Vec2(rA, P);\n\n      cB.addMul(mB, P);\n      aB += iB * Vec2.crossVec2Vec2(rB, P);\n    }\n\n    positionA.c.setVec2(cA);\n    positionA.a = aA;\n\n    positionB.c.setVec2(cB);\n    positionB.a = aB;\n\n    return minSeparation;\n  }\n\n  initVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const radiusA = this.p_radiusA;\n    const radiusB = this.p_radiusB;\n    const manifold = this.getManifold();\n\n    const mA = this.v_invMassA;\n    const mB = this.v_invMassB;\n    const iA = this.v_invIA;\n    const iB = this.v_invIB;\n    const localCenterA = Vec2.clone(this.p_localCenterA);\n    const localCenterB = Vec2.clone(this.p_localCenterB);\n\n    const cA = Vec2.clone(positionA.c);\n    const aA = positionA.a;\n    const vA = Vec2.clone(velocityA.v);\n    const wA = velocityA.w;\n\n    const cB = Vec2.clone(positionB.c);\n    const aB = positionB.a;\n    const vB = Vec2.clone(velocityB.v);\n    const wB = velocityB.w;\n\n    _ASSERT && common.assert(manifold.pointCount > 0);\n\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    xfA.q.setAngle(aA);\n    xfB.q.setAngle(aB);\n    xfA.p.setCombine(1, cA, -1, Rot.mulVec2(xfA.q, localCenterA));\n    xfB.p.setCombine(1, cB, -1, Rot.mulVec2(xfB.q, localCenterB));\n\n    const worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);\n\n    this.v_normal.setVec2(worldManifold.normal);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      vcp.rA.setVec2(Vec2.sub(worldManifold.points[j], cA));\n      vcp.rB.setVec2(Vec2.sub(worldManifold.points[j], cB));\n\n      const rnA = Vec2.crossVec2Vec2(vcp.rA, this.v_normal);\n      const rnB = Vec2.crossVec2Vec2(vcp.rB, this.v_normal);\n\n      const kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n\n      const tangent = Vec2.crossVec2Num(this.v_normal, 1.0);\n\n      const rtA = Vec2.crossVec2Vec2(vcp.rA, tangent);\n      const rtB = Vec2.crossVec2Vec2(vcp.rB, tangent);\n\n      const kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n\n      vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n\n      // Setup a velocity bias for restitution.\n      vcp.velocityBias = 0.0;\n      const vRel = Vec2.dot(this.v_normal, vB)\n        + Vec2.dot(this.v_normal, Vec2.crossNumVec2(wB, vcp.rB))\n        - Vec2.dot(this.v_normal, vA)\n        - Vec2.dot(this.v_normal, Vec2.crossNumVec2(wA, vcp.rA));\n      if (vRel < -Settings.velocityThreshold) {\n        vcp.velocityBias = -this.v_restitution * vRel;\n      }\n    }\n\n    // If we have two points, then prepare the block solver.\n    if (this.v_pointCount == 2 && step.blockSolve) {\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      const rn1A = Vec2.crossVec2Vec2(vcp1.rA, this.v_normal);\n      const rn1B = Vec2.crossVec2Vec2(vcp1.rB, this.v_normal);\n      const rn2A = Vec2.crossVec2Vec2(vcp2.rA, this.v_normal);\n      const rn2B = Vec2.crossVec2Vec2(vcp2.rB, this.v_normal);\n\n      const k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n      const k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n      const k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n\n      // Ensure a reasonable condition number.\n      const k_maxConditionNumber = 1000.0;\n      if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n        // K is safe to invert.\n        this.v_K.ex.setNum(k11, k12);\n        this.v_K.ey.setNum(k12, k22);\n        this.v_normalMass.set(this.v_K.getInverse());\n      } else {\n        // The constraints are redundant, just use one.\n        // TODO_ERIN use deepest?\n        this.v_pointCount = 1;\n      }\n    }\n\n    positionA.c.setVec2(cA);\n    positionA.a = aA;\n    velocityA.v.setVec2(vA);\n    velocityA.w = wA;\n\n    positionB.c.setVec2(cB);\n    positionB.a = aB;\n    velocityB.v.setVec2(vB);\n    velocityB.w = wB;\n  }\n\n  warmStartConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    const vA = Vec2.clone(velocityA.v);\n    let wA = velocityA.w;\n    const vB = Vec2.clone(velocityB.v);\n    let wB = velocityB.w;\n\n    const normal = this.v_normal;\n    const tangent = Vec2.crossVec2Num(normal, 1.0);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      const P = Vec2.combine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n      wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n      vA.subMul(mA, P);\n      wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n      vB.addMul(mB, P);\n    }\n\n    velocityA.v.setVec2(vA);\n    velocityA.w = wA;\n    velocityB.v.setVec2(vB);\n    velocityB.w = wB;\n  }\n\n  storeConstraintImpulses(step: TimeStep): void {\n    const manifold = this.m_manifold;\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n      manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n    }\n  }\n\n  solveVelocityConstraint(step: TimeStep): void {\n    const bodyA = this.m_fixtureA.m_body;\n    const bodyB = this.m_fixtureB.m_body;\n\n    const velocityA = bodyA.c_velocity;\n    const positionA = bodyA.c_position;\n\n    const velocityB = bodyB.c_velocity;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    const vA = Vec2.clone(velocityA.v);\n    let wA = velocityA.w;\n    const vB = Vec2.clone(velocityB.v);\n    let wB = velocityB.w;\n\n    const normal = this.v_normal;\n    const tangent = Vec2.crossVec2Num(normal, 1.0);\n    const friction = this.v_friction;\n\n    _ASSERT && common.assert(this.v_pointCount == 1 || this.v_pointCount == 2);\n\n    // Solve tangent constraints first because non-penetration is more important\n    // than friction.\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      // Relative velocity at contact\n      const dv = Vec2.zero();\n      dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n      dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n\n      // Compute tangent force\n      const vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;\n      let lambda = vcp.tangentMass * (-vt);\n\n      // Clamp the accumulated force\n      const maxFriction = friction * vcp.normalImpulse;\n      const newImpulse = Math.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n      lambda = newImpulse - vcp.tangentImpulse;\n      vcp.tangentImpulse = newImpulse;\n\n      // Apply contact impulse\n      const P = Vec2.mulNumVec2(lambda, tangent);\n\n      vA.subMul(mA, P);\n      wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n\n      vB.addMul(mB, P);\n      wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n    }\n\n    // Solve normal constraints\n    if (this.v_pointCount == 1 || step.blockSolve == false) {\n      for (let i = 0; i < this.v_pointCount; ++i) {\n        const vcp = this.v_points[i]; // VelocityConstraintPoint\n\n        // Relative velocity at contact\n        const dv = Vec2.zero();\n        dv.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, vcp.rB));\n        dv.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, vcp.rA));\n\n        // Compute normal impulse\n        const vn = Vec2.dot(dv, normal);\n        let lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n\n        // Clamp the accumulated impulse\n        const newImpulse = Math.max(vcp.normalImpulse + lambda, 0.0);\n        lambda = newImpulse - vcp.normalImpulse;\n        vcp.normalImpulse = newImpulse;\n\n        // Apply contact impulse\n        const P = Vec2.mulNumVec2(lambda, normal);\n\n        vA.subMul(mA, P);\n        wA -= iA * Vec2.crossVec2Vec2(vcp.rA, P);\n\n        vB.addMul(mB, P);\n        wB += iB * Vec2.crossVec2Vec2(vcp.rB, P);\n      }\n    } else {\n      // Block solver developed in collaboration with Dirk Gregorius (back in\n      // 01/07 on Box2D_Lite).\n      // Build the mini LCP for this contact patch\n      //\n      // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =\n      // 1..2\n      //\n      // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n      // b = vn0 - velocityBias\n      //\n      // The system is solved using the \"Total enumeration method\" (s. Murty).\n      // The complementary constraint vn_i * x_i\n      // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n      // So for the 2D contact problem the cases\n      // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n      // vn1 = 0 need to be tested. The first valid\n      // solution that satisfies the problem is chosen.\n      //\n      // In order to account of the accumulated impulse 'a' (because of the\n      // iterative nature of the solver which only requires\n      // that the accumulated impulse is clamped and not the incremental\n      // impulse) we change the impulse variable (x_i).\n      //\n      // Substitute:\n      //\n      // x = a + d\n      //\n      // a := old total impulse\n      // x := new total impulse\n      // d := incremental impulse\n      //\n      // For the current iteration we extend the formula for the incremental\n      // impulse\n      // to compute the new total impulse:\n      //\n      // vn = A * d + b\n      // = A * (x - a) + b\n      // = A * x + b - A * a\n      // = A * x + b'\n      // b' = b - A * a;\n\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      const a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);\n      _ASSERT && common.assert(a.x >= 0.0 && a.y >= 0.0);\n\n      // Relative velocity at contact\n      let dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n      let dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n\n      // Compute normal velocity\n      let vn1 = Vec2.dot(dv1, normal);\n      let vn2 = Vec2.dot(dv2, normal);\n\n      const b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n\n      // Compute b'\n      b.sub(Mat22.mulVec2(this.v_K, a));\n\n      const k_errorTol = 1e-3;\n      // NOT_USED(k_errorTol);\n\n      while (true) {\n        //\n        // Case 1: vn = 0\n        //\n        // 0 = A * x + b'\n        //\n        // Solve for x:\n        //\n        // x = - inv(A) * b'\n        //\n        const x = Mat22.mulVec2(this.v_normalMass, b).neg();\n\n        if (x.x >= 0.0 && x.y >= 0.0) {\n          // Get the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            dv1 = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, vcp1.rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, vcp1.rA)));\n            dv2 = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, vcp2.rB)), Vec2.add(vA, Vec2.crossNumVec2(wA, vcp2.rA)));\n\n            // Compute normal velocity\n            vn1 = Vec2.dot(dv1, normal);\n            vn2 = Vec2.dot(dv2, normal);\n\n            _ASSERT && common.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n            _ASSERT && common.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 2: vn1 = 0 and x2 = 0\n        //\n        // 0 = a11 * x1 + a12 * 0 + b1'\n        // vn2 = a21 * x1 + a22 * 0 + b2'\n        //\n        x.x = -vcp1.normalMass * b.x;\n        x.y = 0.0;\n        vn1 = 0.0;\n        vn2 = this.v_K.ex.y * x.x + b.y;\n\n        if (x.x >= 0.0 && vn2 >= 0.0) {\n          // Get the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            const dv1B = Vec2.add(vB, Vec2.crossNumVec2(wB, vcp1.rB));\n            const dv1A = Vec2.add(vA, Vec2.crossNumVec2(wA, vcp1.rA));\n            const dv1 = Vec2.sub(dv1B, dv1A);\n\n            // Compute normal velocity\n            vn1 = Vec2.dot(dv1, normal);\n\n            _ASSERT && common.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 3: vn2 = 0 and x1 = 0\n        //\n        // vn1 = a11 * 0 + a12 * x2 + b1'\n        // 0 = a21 * 0 + a22 * x2 + b2'\n        //\n        x.x = 0.0;\n        x.y = -vcp2.normalMass * b.y;\n        vn1 = this.v_K.ey.x * x.y + b.x;\n        vn2 = 0.0;\n\n        if (x.y >= 0.0 && vn1 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            const dv2B = Vec2.add(vB, Vec2.crossNumVec2(wB, vcp2.rB));\n            const dv2A = Vec2.add(vA, Vec2.crossNumVec2(wA, vcp2.rA));\n            const dv1 = Vec2.sub(dv2B, dv2A);\n\n            // Compute normal velocity\n            vn2 = Vec2.dot(dv2, normal);\n\n            _ASSERT && common.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 4: x1 = 0 and x2 = 0\n        //\n        // vn1 = b1\n        // vn2 = b2;\n        //\n        x.x = 0.0;\n        x.y = 0.0;\n        vn1 = b.x;\n        vn2 = b.y;\n\n        if (vn1 >= 0.0 && vn2 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          const d = Vec2.sub(x, a);\n\n          // Apply incremental impulse\n          const P1 = Vec2.mulNumVec2(d.x, normal);\n          const P2 = Vec2.mulNumVec2(d.y, normal);\n          vA.subCombine(mA, P1, mA, P2);\n          wA -= iA * (Vec2.crossVec2Vec2(vcp1.rA, P1) + Vec2.crossVec2Vec2(vcp2.rA, P2));\n\n          vB.addCombine(mB, P1, mB, P2);\n          wB += iB * (Vec2.crossVec2Vec2(vcp1.rB, P1) + Vec2.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          break;\n        }\n\n        // No solution, give up. This is hit sometimes, but it doesn't seem to\n        // matter.\n        break;\n      }\n    }\n\n    velocityA.v.setVec2(vA);\n    velocityA.w = wA;\n\n    velocityB.v.setVec2(vB);\n    velocityB.w = wB;\n  }\n\n  /**\n   * @internal\n   */\n  static addType(type1: ShapeType, type2: ShapeType, callback: ContactCallback): void {\n    s_registers[type1] = s_registers[type1] || {};\n    s_registers[type1][type2] = callback;\n  }\n\n  /**\n   * @internal\n   */\n  static create(fixtureA: Fixture, indexA: number, fixtureB: Fixture, indexB: number): Contact | null {\n    const typeA = fixtureA.getType();\n    const typeB = fixtureB.getType();\n\n    // TODO: pool contacts\n    let contact;\n    let evaluateFcn;\n    if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n      contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n    } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n      contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n    } else {\n      return null;\n    }\n\n    // Contact creation may swap fixtures.\n    fixtureA = contact.getFixtureA();\n    fixtureB = contact.getFixtureB();\n    indexA = contact.getChildIndexA();\n    indexB = contact.getChildIndexB();\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    // Connect to body A\n    contact.m_nodeA.contact = contact;\n    contact.m_nodeA.other = bodyB;\n\n    contact.m_nodeA.prev = null;\n    contact.m_nodeA.next = bodyA.m_contactList;\n    if (bodyA.m_contactList != null) {\n      bodyA.m_contactList.prev = contact.m_nodeA;\n    }\n    bodyA.m_contactList = contact.m_nodeA;\n\n    // Connect to body B\n    contact.m_nodeB.contact = contact;\n    contact.m_nodeB.other = bodyA;\n\n    contact.m_nodeB.prev = null;\n    contact.m_nodeB.next = bodyB.m_contactList;\n    if (bodyB.m_contactList != null) {\n      bodyB.m_contactList.prev = contact.m_nodeB;\n    }\n    bodyB.m_contactList = contact.m_nodeB;\n\n    // Wake up the bodies\n    if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    return contact;\n  }\n\n  /**\n   * @internal\n   */\n  static destroy(contact: Contact, listener: { endContact: (contact: Contact) => void }): void {\n    const fixtureA = contact.m_fixtureA;\n    const fixtureB = contact.m_fixtureB;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    if (contact.isTouching()) {\n      listener.endContact(contact);\n    }\n\n    // Remove from body 1\n    if (contact.m_nodeA.prev) {\n      contact.m_nodeA.prev.next = contact.m_nodeA.next;\n    }\n\n    if (contact.m_nodeA.next) {\n      contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n    }\n\n    if (contact.m_nodeA == bodyA.m_contactList) {\n      bodyA.m_contactList = contact.m_nodeA.next;\n    }\n\n    // Remove from body 2\n    if (contact.m_nodeB.prev) {\n      contact.m_nodeB.prev.next = contact.m_nodeB.next;\n    }\n\n    if (contact.m_nodeB.next) {\n      contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n    }\n\n    if (contact.m_nodeB == bodyB.m_contactList) {\n      bodyB.m_contactList = contact.m_nodeB.next;\n    }\n\n    if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false\n      && fixtureB.isSensor() == false) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    const typeA = fixtureA.getType();\n    const typeB = fixtureB.getType();\n\n    // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n    // if (typeof destroyFcn === 'function') {\n    //   destroyFcn(contact);\n    // }\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport type Vec2 from '../common/Vec2';\nimport type Body from './Body';\nimport { TimeStep } from \"./Solver\";\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/**\n * A joint edge is used to connect bodies and joints together in a joint graph\n * where each body is a node and each joint is an edge. A joint edge belongs to\n * a doubly linked list maintained in each attached body. Each joint has two\n * joint nodes, one for each attached body.\n */\nexport class JointEdge {\n  /**\n   * provides quick access to the other body attached.\n   */\n  other: Body | null = null;\n  /**\n   * the joint\n   */\n  joint: Joint | null = null;\n  /**\n   * prev the previous joint edge in the body's joint list\n   */\n  prev: JointEdge | null = null;\n  /**\n   * the next joint edge in the body's joint list\n   */\n  next: JointEdge | null = null;\n}\n\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointOpt {\n  /**\n   * Use this to attach application specific data to your joints.\n   */\n  userData?: any;\n  /**\n   * Set this flag to true if the attached bodies\n   * should collide.\n   */\n  collideConnected?: boolean;\n}\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointDef extends JointOpt {\n  /**\n   * The first attached body.\n   */\n  bodyA: Body;\n  /**\n   * The second attached body.\n   */\n  bodyB: Body;\n}\n\nconst DEFAULTS = {\n  userData : null,\n  collideConnected : false\n};\n\n/**\n * The base joint class. Joints are used to constraint two bodies together in\n * various fashions. Some joints also feature limits and motors.\n */\nexport default abstract class Joint {\n\n  /** @internal */ m_type: string = 'unknown-joint';\n\n  /** @internal */ m_bodyA: Body;\n  /** @internal */ m_bodyB: Body;\n\n  /** @internal */ m_collideConnected: boolean;\n\n  /** @internal */ m_prev: Joint | null = null;\n  /** @internal */ m_next: Joint | null = null;\n\n  /** @internal */ m_edgeA: JointEdge = new JointEdge();\n  /** @internal */ m_edgeB: JointEdge = new JointEdge();\n\n  /** @internal */ m_islandFlag: boolean = false;\n  /** @internal */ m_userData: unknown;\n\n  constructor(def: JointDef);\n  constructor(def: JointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: JointDef | JointOpt, bodyA?: Body, bodyB?: Body) {\n    bodyA = 'bodyA' in def ? def.bodyA : bodyA;\n    bodyB = 'bodyB' in def ? def.bodyB : bodyB;\n\n    _ASSERT && common.assert(!!bodyA);\n    _ASSERT && common.assert(!!bodyB);\n    _ASSERT && common.assert(bodyA != bodyB);\n\n    this.m_bodyA = bodyA!;\n    this.m_bodyB = bodyB!;\n\n    this.m_collideConnected = !!def.collideConnected;\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Short-cut function to determine if either body is inactive.\n   */\n  isActive(): boolean {\n    return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n  }\n\n  /**\n   * Get the type of the concrete joint.\n   */\n  getType(): string {\n    return this.m_type;\n  }\n\n  /**\n   * Get the first body attached to this joint.\n   */\n  getBodyA(): Body {\n    return this.m_bodyA;\n  }\n\n  /**\n   * Get the second body attached to this joint.\n   */\n  getBodyB(): Body {\n    return this.m_bodyB;\n  }\n\n  /**\n   * Get the next joint the world joint list.\n   */\n  getNext(): Joint {\n    return this.m_next;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get collide connected. Note: modifying the collide connect flag won't work\n   * correctly because the flag is only checked when fixture AABBs begin to\n   * overlap.\n   */\n  getCollideConnected(): boolean {\n    return this.m_collideConnected;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  abstract getAnchorA(): Vec2;\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  abstract getAnchorB(): Vec2;\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  abstract getReactionForce(inv_dt: number): Vec2;\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  abstract getReactionTorque(inv_dt: number): number;\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2): void {}\n\n  abstract initVelocityConstraints(step: TimeStep): void;\n\n  abstract solveVelocityConstraints(step: TimeStep): void;\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  abstract solvePositionConstraints(step: TimeStep): boolean;\n\n}\n","export const now = function(): number {\n  return Date.now();\n};\n\nexport const diff = function(time: number): number {\n  return Date.now() - time;\n};\n\nexport default {\n  now,\n  diff,\n};\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Settings from '../Settings';\n\nimport common from '../util/common';\nimport stats from '../util/stats';\nimport Timer from '../util/Timer';\n\nimport Math from '../common/Math';\nimport Vec2 from '../common/Vec2';\nimport Rot from '../common/Rot';\nimport Sweep from '../common/Sweep';\nimport Transform from '../common/Transform';\n\nimport Distance, { DistanceInput, DistanceOutput, DistanceProxy, SimplexCache } from './Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Input parameters for TimeOfImpact.\n */\nexport class TOIInput {\n  proxyA: DistanceProxy = new DistanceProxy();\n  proxyB: DistanceProxy = new DistanceProxy();\n  sweepA: Sweep = new Sweep();\n  sweepB: Sweep = new Sweep();\n  /** defines sweep interval [0, tMax] */\n  tMax: number | undefined;\n}\n\nexport enum TOIOutputState {\n  e_unknown = 0,\n  e_failed = 1,\n  e_overlapped = 2,\n  e_touching = 3,\n  e_separated = 4,\n}\n\n/**\n * Output parameters for TimeOfImpact.\n */\nexport class TOIOutput {\n  state: TOIOutputState | undefined;\n  t: number | undefined;\n}\n\nstats.toiTime = 0;\nstats.toiMaxTime = 0;\nstats.toiCalls = 0;\nstats.toiIters = 0;\nstats.toiMaxIters = 0;\nstats.toiRootIters = 0;\nstats.toiMaxRootIters = 0;\n\n/**\n * Compute the upper bound on time before two shapes penetrate. Time is\n * represented as a fraction between [0,tMax]. This uses a swept separating axis\n * and may miss some intermediate, non-tunneling collision. If you change the\n * time interval, you should call this function again.\n *\n * Note: use Distance to compute the contact point and normal at the time of\n * impact.\n *\n * CCD via the local separating axis method. This seeks progression by computing\n * the largest time at which separation is maintained.\n */\nexport default function TimeOfImpact(output: TOIOutput, input: TOIInput): void {\n  const timer = Timer.now();\n\n  ++stats.toiCalls;\n\n  output.state = TOIOutputState.e_unknown;\n  output.t = input.tMax;\n\n  const proxyA = input.proxyA; // DistanceProxy\n  const proxyB = input.proxyB; // DistanceProxy\n\n  const sweepA = input.sweepA; // Sweep\n  const sweepB = input.sweepB; // Sweep\n\n  // Large rotations can make the root finder fail, so we normalize the\n  // sweep angles.\n  sweepA.normalize();\n  sweepB.normalize();\n\n  const tMax = input.tMax;\n\n  const totalRadius = proxyA.m_radius + proxyB.m_radius;\n  const target = Math.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n  const tolerance = 0.25 * Settings.linearSlop;\n  _ASSERT && common.assert(target > tolerance);\n\n  let t1 = 0.0;\n  const k_maxIterations = Settings.maxTOIIterations;\n  let iter = 0;\n\n  // Prepare input for distance query.\n  const cache = new SimplexCache();\n\n  const distanceInput = new DistanceInput();\n  distanceInput.proxyA = input.proxyA;\n  distanceInput.proxyB = input.proxyB;\n  distanceInput.useRadii = false;\n\n  // The outer loop progressively attempts to compute new separating axes.\n  // This loop terminates when an axis is repeated (no progress is made).\n  while (true) {\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    sweepA.getTransform(xfA, t1);\n    sweepB.getTransform(xfB, t1);\n\n    // Get the distance between shapes. We can also use the results\n    // to get a separating axis.\n    distanceInput.transformA = xfA;\n    distanceInput.transformB = xfB;\n    const distanceOutput = new DistanceOutput();\n    Distance(distanceOutput, cache, distanceInput);\n\n    // If the shapes are overlapped, we give up on continuous collision.\n    if (distanceOutput.distance <= 0.0) {\n      // Failure!\n      output.state = TOIOutputState.e_overlapped;\n      output.t = 0.0;\n      break;\n    }\n\n    if (distanceOutput.distance < target + tolerance) {\n      // Victory!\n      output.state = TOIOutputState.e_touching;\n      output.t = t1;\n      break;\n    }\n\n    // Initialize the separating axis.\n    const fcn = new SeparationFunction();\n    fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n\n    // if (false) {\n    //   // Dump the curve seen by the root finder\n    //   const N = 100;\n    //   const dx = 1.0 / N;\n    //   const xs = []; // [ N + 1 ];\n    //   const fs = []; // [ N + 1 ];\n    //   const x = 0.0;\n    //   for (const i = 0; i <= N; ++i) {\n    //     sweepA.getTransform(xfA, x);\n    //     sweepB.getTransform(xfB, x);\n    //     const f = fcn.evaluate(xfA, xfB) - target;\n    //     printf(\"%g %g\\n\", x, f);\n    //     xs[i] = x;\n    //     fs[i] = f;\n    //     x += dx;\n    //   }\n    // }\n\n    // Compute the TOI on the separating axis. We do this by successively\n    // resolving the deepest point. This loop is bounded by the number of\n    // vertices.\n    let done = false;\n    let t2 = tMax;\n    let pushBackIter = 0;\n    while (true) {\n      // Find the deepest point at t2. Store the witness point indices.\n      let s2 = fcn.findMinSeparation(t2);\n      // const indexA = fcn.indexA;\n      // const indexB = fcn.indexB;\n\n      // Is the final configuration separated?\n      if (s2 > target + tolerance) {\n        // Victory!\n        output.state = TOIOutputState.e_separated;\n        output.t = tMax;\n        done = true;\n        break;\n      }\n\n      // Has the separation reached tolerance?\n      if (s2 > target - tolerance) {\n        // Advance the sweeps\n        t1 = t2;\n        break;\n      }\n\n      // Compute the initial separation of the witness points.\n      let s1 = fcn.evaluate(t1);\n      // const indexA = fcn.indexA;\n      // const indexB = fcn.indexB;\n\n      // Check for initial overlap. This might happen if the root finder\n      // runs out of iterations.\n      if (s1 < target - tolerance) {\n        output.state = TOIOutputState.e_failed;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Check for touching\n      if (s1 <= target + tolerance) {\n        // Victory! t1 should hold the TOI (could be 0.0).\n        output.state = TOIOutputState.e_touching;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Compute 1D root of: f(x) - target = 0\n      let rootIterCount = 0;\n      let a1 = t1;\n      let a2 = t2;\n      while (true) {\n        // Use a mix of the secant rule and bisection.\n        let t;\n        if (rootIterCount & 1) {\n          // Secant rule to improve convergence.\n          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n        } else {\n          // Bisection to guarantee progress.\n          t = 0.5 * (a1 + a2);\n        }\n\n        ++rootIterCount;\n        ++stats.toiRootIters;\n\n        const s = fcn.evaluate(t);\n        const indexA = fcn.indexA;\n        const indexB = fcn.indexB;\n\n        if (Math.abs(s - target) < tolerance) {\n          // t2 holds a tentative value for t1\n          t2 = t;\n          break;\n        }\n\n        // Ensure we continue to bracket the root.\n        if (s > target) {\n          a1 = t;\n          s1 = s;\n        } else {\n          a2 = t;\n          s2 = s;\n        }\n\n        if (rootIterCount === 50) {\n          break;\n        }\n      }\n\n      stats.toiMaxRootIters = Math.max(stats.toiMaxRootIters, rootIterCount);\n\n      ++pushBackIter;\n\n      if (pushBackIter === Settings.maxPolygonVertices) {\n        break;\n      }\n    }\n\n    ++iter;\n    ++stats.toiIters;\n\n    if (done) {\n      break;\n    }\n\n    if (iter === k_maxIterations) {\n      // Root finder got stuck. Semi-victory.\n      output.state = TOIOutputState.e_failed;\n      output.t = t1;\n      break;\n    }\n  }\n\n  stats.toiMaxIters = Math.max(stats.toiMaxIters, iter);\n\n  const time = Timer.diff(timer);\n  stats.toiMaxTime = Math.max(stats.toiMaxTime, time);\n  stats.toiTime += time;\n}\n\nenum SeparationFunctionType {\n  e_points = 1,\n  e_faceA = 2,\n  e_faceB = 3,\n}\n\nclass SeparationFunction {\n  m_proxyA: DistanceProxy = new DistanceProxy();\n  m_proxyB: DistanceProxy = new DistanceProxy();\n  m_sweepA: Sweep;\n  m_sweepB: Sweep;\n  indexA: number;\n  indexB: number;\n  m_type: SeparationFunctionType;\n  m_localPoint: Vec2 = Vec2.zero();\n  m_axis: Vec2 = Vec2.zero();\n\n  // TODO_ERIN might not need to return the separation\n\n  initialize(cache: SimplexCache, proxyA: DistanceProxy, sweepA: Sweep, proxyB: DistanceProxy, sweepB: Sweep, t1: number): number {\n    this.m_proxyA = proxyA;\n    this.m_proxyB = proxyB;\n    const count = cache.count;\n    _ASSERT && common.assert(0 < count && count < 3);\n\n    this.m_sweepA = sweepA;\n    this.m_sweepB = sweepB;\n\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    this.m_sweepA.getTransform(xfA, t1);\n    this.m_sweepB.getTransform(xfB, t1);\n\n    if (count === 1) {\n      this.m_type = SeparationFunctionType.e_points;\n      const localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      const pointA = Transform.mulVec2(xfA, localPointA);\n      const pointB = Transform.mulVec2(xfB, localPointB);\n      this.m_axis.setCombine(1, pointB, -1, pointA);\n      const s = this.m_axis.normalize();\n      return s;\n\n    } else if (cache.indexA[0] === cache.indexA[1]) {\n      // Two points on B and one on A.\n      this.m_type = SeparationFunctionType.e_faceB;\n      const localPointB1 = proxyB.getVertex(cache.indexB[0]);\n      const localPointB2 = proxyB.getVertex(cache.indexB[1]);\n\n      this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointB2, localPointB1), 1.0);\n      this.m_axis.normalize();\n      const normal = Rot.mulVec2(xfB.q, this.m_axis);\n\n      this.m_localPoint = Vec2.mid(localPointB1, localPointB2);\n      const pointB = Transform.mulVec2(xfB, this.m_localPoint);\n\n      const localPointA = proxyA.getVertex(cache.indexA[0]);\n      const pointA = Transform.mulVec2(xfA, localPointA);\n\n      let s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n      if (s < 0.0) {\n        this.m_axis = Vec2.neg(this.m_axis);\n        s = -s;\n      }\n      return s;\n\n    } else {\n      // Two points on A and one or two points on B.\n      this.m_type = SeparationFunctionType.e_faceA;\n      const localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n\n      this.m_axis = Vec2.crossVec2Num(Vec2.sub(localPointA2, localPointA1), 1.0);\n      this.m_axis.normalize();\n      const normal = Rot.mulVec2(xfA.q, this.m_axis);\n\n      this.m_localPoint = Vec2.mid(localPointA1, localPointA2);\n      const pointA = Transform.mulVec2(xfA, this.m_localPoint);\n\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      const pointB = Transform.mulVec2(xfB, localPointB);\n\n      let s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n      if (s < 0.0) {\n        this.m_axis = Vec2.neg(this.m_axis);\n        s = -s;\n      }\n      return s;\n    }\n  }\n\n  compute(find: boolean, t: number): number {\n    // It was findMinSeparation and evaluate\n    const xfA = Transform.identity();\n    const xfB = Transform.identity();\n    this.m_sweepA.getTransform(xfA, t);\n    this.m_sweepB.getTransform(xfB, t);\n\n    switch (this.m_type) {\n      case SeparationFunctionType.e_points: {\n        if (find) {\n          const axisA = Rot.mulTVec2(xfA.q, this.m_axis);\n          const axisB = Rot.mulTVec2(xfB.q, Vec2.neg(this.m_axis));\n\n          this.indexA = this.m_proxyA.getSupport(axisA);\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        const localPointA = this.m_proxyA.getVertex(this.indexA);\n        const localPointB = this.m_proxyB.getVertex(this.indexB);\n\n        const pointA = Transform.mulVec2(xfA, localPointA);\n        const pointB = Transform.mulVec2(xfB, localPointB);\n\n        const sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceA: {\n        const normal = Rot.mulVec2(xfA.q, this.m_axis);\n        const pointA = Transform.mulVec2(xfA, this.m_localPoint);\n\n        if (find) {\n          const axisB = Rot.mulTVec2(xfB.q, Vec2.neg(normal));\n\n          this.indexA = -1;\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        const localPointB = this.m_proxyB.getVertex(this.indexB);\n        const pointB = Transform.mulVec2(xfB, localPointB);\n\n        const sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceB: {\n        const normal = Rot.mulVec2(xfB.q, this.m_axis);\n        const pointB = Transform.mulVec2(xfB, this.m_localPoint);\n\n        if (find) {\n          const axisA = Rot.mulTVec2(xfA.q, Vec2.neg(normal));\n\n          this.indexB = -1;\n          this.indexA = this.m_proxyA.getSupport(axisA);\n        }\n\n        const localPointA = this.m_proxyA.getVertex(this.indexA);\n        const pointA = Transform.mulVec2(xfA, localPointA);\n\n        const sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);\n        return sep;\n      }\n\n      default:\n        _ASSERT && common.assert(false);\n        if (find) {\n          this.indexA = -1;\n          this.indexB = -1;\n        }\n        return 0.0;\n    }\n  }\n\n  findMinSeparation(t: number): number {\n    return this.compute(true, t);\n  }\n\n  evaluate(t: number): number {\n    return this.compute(false, t);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Settings from '../Settings';\nimport common from '../util/common';\nimport Vec2 from '../common/Vec2';\nimport Math from '../common/Math';\nimport Body from './Body';\nimport Contact from './Contact';\nimport Joint from './Joint';\nimport TimeOfImpact, { TOIInput, TOIOutput, TOIOutputState } from '../collision/TimeOfImpact';\nimport Distance, { DistanceInput, DistanceOutput, SimplexCache } from '../collision/Distance';\nimport World from \"./World\";\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport class TimeStep {\n  /** time step */\n  dt: number = 0;\n  /** inverse time step (0 if dt == 0) */\n  inv_dt: number = 0;\n  velocityIterations: number = 0;\n  positionIterations: number = 0;\n  warmStarting: boolean = false;\n  blockSolve: boolean = true;\n\n  /** timestep ratio for variable timestep */\n  inv_dt0: number = 0.0;\n  /** dt * inv_dt0 */\n  dtRatio: number = 1;\n\n  reset(dt: number): void {\n    if (this.dt > 0.0) {\n      this.inv_dt0 = this.inv_dt;\n    }\n    this.dt = dt;\n    this.inv_dt = dt == 0 ? 0 : 1 / dt;\n    this.dtRatio = dt * this.inv_dt0;\n  }\n}\n\n// reuse\nconst s_subStep = new TimeStep();\n\n/**\n * Contact impulses for reporting. Impulses are used instead of forces because\n * sub-step forces may approach infinity for rigid body collisions. These match\n * up one-to-one with the contact points in Manifold.\n */\nexport class ContactImpulse {\n  // TODO: merge with Contact class?\n\n  private readonly contact: Contact;\n  private readonly normals: number[];\n  private readonly tangents: number[];\n\n  constructor(contact: Contact) {\n    this.contact = contact;\n    this.normals = [];\n    this.tangents = [];\n  }\n\n  get normalImpulses(): number[] {\n    const contact = this.contact;\n    const normals = this.normals;\n    normals.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      normals.push(contact.v_points[p].normalImpulse);\n    }\n    return normals;\n  }\n\n  get tangentImpulses(): number[] {\n    const contact = this.contact;\n    const tangents = this.tangents;\n    tangents.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      tangents.push(contact.v_points[p].tangentImpulse);\n    }\n    return tangents;\n  }\n}\n\n/**\n * Finds and solves islands. An island is a connected subset of the world.\n */\nexport default class Solver {\n  m_world: World;\n  m_stack: Body[];\n  m_bodies: Body[];\n  m_contacts: Contact[];\n  m_joints: Joint[];\n\n  constructor(world: World) {\n    this.m_world = world;\n    this.m_stack = [];\n    this.m_bodies = [];\n    this.m_contacts = [];\n    this.m_joints = [];\n  }\n\n  clear(): void {\n    this.m_stack.length = 0;\n    this.m_bodies.length = 0;\n    this.m_contacts.length = 0;\n    this.m_joints.length = 0;\n  }\n\n  addBody(body: Body): void {\n    _ASSERT && common.assert(body instanceof Body, 'Not a Body!', body);\n    this.m_bodies.push(body);\n    // why?\n    // body.c_position.c.setZero();\n    // body.c_position.a = 0;\n    // body.c_velocity.v.setZero();\n    // body.c_velocity.w = 0;\n  }\n\n  addContact(contact: Contact): void {\n    _ASSERT && common.assert(contact instanceof Contact, 'Not a Contact!', contact);\n    this.m_contacts.push(contact);\n  }\n\n  addJoint(joint: Joint): void {\n    _ASSERT && common.assert(joint instanceof Joint, 'Not a Joint!', joint);\n    this.m_joints.push(joint);\n  }\n\n  solveWorld(step: TimeStep): void {\n    const world = this.m_world;\n\n    // Clear all the island flags.\n    for (let b = world.m_bodyList; b; b = b.m_next) {\n      b.m_islandFlag = false;\n    }\n    for (let c = world.m_contactList; c; c = c.m_next) {\n      c.m_islandFlag = false;\n    }\n    for (let j = world.m_jointList; j; j = j.m_next) {\n      j.m_islandFlag = false;\n    }\n\n    // Build and simulate all awake islands.\n    const stack = this.m_stack;\n    let loop = -1;\n    for (let seed = world.m_bodyList; seed; seed = seed.m_next) {\n      loop++;\n      if (seed.m_islandFlag) {\n        continue;\n      }\n\n      if (seed.isAwake() == false || seed.isActive() == false) {\n        continue;\n      }\n\n      // The seed can be dynamic or kinematic.\n      if (seed.isStatic()) {\n        continue;\n      }\n\n      // Reset island and stack.\n      this.clear();\n\n      stack.push(seed);\n\n      seed.m_islandFlag = true;\n\n      // Perform a depth first search (DFS) on the constraint graph.\n      while (stack.length > 0) {\n        // Grab the next body off the stack and add it to the island.\n        const b = stack.pop();\n        _ASSERT && common.assert(b.isActive() == true);\n        this.addBody(b);\n\n        // Make sure the body is awake.\n        b.setAwake(true);\n\n        // To keep islands as small as possible, we don't\n        // propagate islands across static bodies.\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Search all contacts connected to this body.\n        for (let ce = b.m_contactList; ce; ce = ce.next) {\n          const contact = ce.contact;\n\n          // Has this contact already been added to an island?\n          if (contact.m_islandFlag) {\n            continue;\n          }\n\n          // Is this contact solid and touching?\n          if (contact.isEnabled() == false || contact.isTouching() == false) {\n            continue;\n          }\n\n          // Skip sensors.\n          const sensorA = contact.m_fixtureA.m_isSensor;\n          const sensorB = contact.m_fixtureB.m_isSensor;\n          if (sensorA || sensorB) {\n            continue;\n          }\n\n          this.addContact(contact);\n          contact.m_islandFlag = true;\n\n          const other = ce.other;\n\n          // Was the other body already added to this island?\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n\n        // Search all joints connect to this body.\n        for (let je = b.m_jointList; je; je = je.next) {\n          if (je.joint.m_islandFlag == true) {\n            continue;\n          }\n\n          const other = je.other;\n\n          // Don't simulate joints connected to inactive bodies.\n          if (other.isActive() == false) {\n            continue;\n          }\n\n          this.addJoint(je.joint);\n          je.joint.m_islandFlag = true;\n\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && common.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n      }\n\n      this.solveIsland(step);\n\n      // Post solve cleanup.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        // Allow static bodies to participate in other islands.\n        // TODO: are they added at all?\n        const b = this.m_bodies[i];\n        if (b.isStatic()) {\n          b.m_islandFlag = false;\n        }\n      }\n    }\n  }\n\n  solveIsland(step: TimeStep): void {\n    // B2: Island Solve\n    const world = this.m_world;\n    const gravity = world.m_gravity;\n    const allowSleep = world.m_allowSleep;\n\n    const h = step.dt;\n\n    // Integrate velocities and apply damping. Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      const c = Vec2.clone(body.m_sweep.c);\n      const a = body.m_sweep.a;\n      const v = Vec2.clone(body.m_linearVelocity);\n      let w = body.m_angularVelocity;\n\n      // Store positions for continuous collision.\n      body.m_sweep.c0.setVec2(body.m_sweep.c);\n      body.m_sweep.a0 = body.m_sweep.a;\n\n      if (body.isDynamic()) {\n        // Integrate velocities.\n        v.addMul(h * body.m_gravityScale, gravity);\n        v.addMul(h * body.m_invMass, body.m_force);\n        w += h * body.m_invI * body.m_torque;\n        /**\n         * <pre>\n         * Apply damping.\n         * ODE: dv/dt + c * v = 0\n         * Solution: v(t) = v0 * exp(-c * t)\n         * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n         * v2 = exp(-c * dt) * v1\n         * Pade approximation:\n         * v2 = v1 * 1 / (1 + c * dt)\n         * </pre>\n         */\n        v.mul(1.0 / (1.0 + h * body.m_linearDamping));\n        w *= 1.0 / (1.0 + h * body.m_angularDamping);\n      }\n\n      body.c_position.c = c;\n      body.c_position.a = a;\n      body.c_velocity.v = v;\n      body.c_velocity.w = w;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(step);\n    }\n\n    _DEBUG && this.printBodies('M: ');\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(step);\n    }\n\n    _DEBUG && this.printBodies('R: ');\n\n    if (step.warmStarting) {\n      // Warm start.\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const contact = this.m_contacts[i];\n        contact.warmStartConstraint(step);\n      }\n    }\n\n    _DEBUG && this.printBodies('Q: ');\n\n    for (let i = 0; i < this.m_joints.length; ++i) {\n      const joint = this.m_joints[i];\n      joint.initVelocityConstraints(step);\n    }\n\n    _DEBUG && this.printBodies('E: ');\n\n    // Solve velocity constraints\n    for (let i = 0; i < step.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        joint.solveVelocityConstraints(step);\n      }\n\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(step);\n      }\n    }\n\n    _DEBUG && this.printBodies('D: ');\n\n    // Store impulses for warm starting\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.storeConstraintImpulses(step);\n    }\n\n    _DEBUG && this.printBodies('C: ');\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      const c = Vec2.clone(body.c_position.c);\n      let a = body.c_position.a;\n      const v = Vec2.clone(body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      const translation = Vec2.mulNumVec2(h, v);\n      if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / translation.length();\n        v.mul(ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      c.addMul(h, v);\n      a += h * w;\n\n      body.c_position.c.setVec2(c);\n      body.c_position.a = a;\n      body.c_velocity.v.setVec2(v);\n      body.c_velocity.w = w;\n    }\n\n    _DEBUG && this.printBodies('B: ');\n\n    // Solve position constraints\n    let positionSolved = false;\n    for (let i = 0; i < step.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraint(step);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;\n\n      let jointsOkay = true;\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        const jointOkay = joint.solvePositionConstraints(step);\n        jointsOkay = jointsOkay && jointOkay;\n      }\n\n      if (contactsOkay && jointsOkay) {\n        // Exit early if the position errors are small.\n        positionSolved = true;\n        break;\n      }\n    }\n\n    _DEBUG && this.printBodies('L: ');\n\n    // Copy state buffers back to the bodies\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      body.m_sweep.c.setVec2(body.c_position.c);\n      body.m_sweep.a = body.c_position.a;\n      body.m_linearVelocity.setVec2(body.c_velocity.v);\n      body.m_angularVelocity = body.c_velocity.w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n\n    if (allowSleep) {\n      let minSleepTime = Infinity;\n\n      const linTolSqr = Settings.linearSleepToleranceSqr;\n      const angTolSqr = Settings.angularSleepToleranceSqr;\n\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        if (body.isStatic()) {\n          continue;\n        }\n\n        if ((body.m_autoSleepFlag == false)\n          || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)\n          || (Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr)) {\n          body.m_sleepTime = 0.0;\n          minSleepTime = 0.0;\n        } else {\n          body.m_sleepTime += h;\n          minSleepTime = Math.min(minSleepTime, body.m_sleepTime);\n        }\n      }\n\n      if (minSleepTime >= Settings.timeToSleep && positionSolved) {\n        for (let i = 0; i < this.m_bodies.length; ++i) {\n          const body = this.m_bodies[i];\n          body.setAwake(false);\n        }\n      }\n    }\n  }\n\n  /** @internal */\n  printBodies(tag: string): void {\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const b = this.m_bodies[i];\n      common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);\n    }\n  }\n\n  /**\n   * Find TOI contacts and solve them.\n   */\n  solveWorldTOI(step: TimeStep): void {\n    const world = this.m_world;\n\n    if (world.m_stepComplete) {\n      for (let b = world.m_bodyList; b; b = b.m_next) {\n        b.m_islandFlag = false;\n        b.m_sweep.alpha0 = 0.0;\n      }\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Invalidate TOI\n        c.m_toiFlag = false;\n        c.m_islandFlag = false;\n        c.m_toiCount = 0;\n        c.m_toi = 1.0;\n      }\n    }\n\n    // Find TOI events and solve them.\n    while (true) {\n      // Find the first TOI.\n      let minContact = null; // Contact\n      let minAlpha = 1.0;\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Is this contact disabled?\n        if (c.isEnabled() == false) {\n          continue;\n        }\n\n        // Prevent excessive sub-stepping.\n        if (c.m_toiCount > Settings.maxSubSteps) {\n          continue;\n        }\n\n        let alpha = 1.0;\n        if (c.m_toiFlag) {\n          // This contact has a valid cached TOI.\n          alpha = c.m_toi;\n        } else {\n          const fA = c.getFixtureA();\n          const fB = c.getFixtureB();\n\n          // Is there a sensor?\n          if (fA.isSensor() || fB.isSensor()) {\n            continue;\n          }\n\n          const bA = fA.getBody();\n          const bB = fB.getBody();\n\n          _ASSERT && common.assert(bA.isDynamic() || bB.isDynamic());\n\n          const activeA = bA.isAwake() && !bA.isStatic();\n          const activeB = bB.isAwake() && !bB.isStatic();\n\n          // Is at least one body active (awake and dynamic or kinematic)?\n          if (activeA == false && activeB == false) {\n            continue;\n          }\n\n          const collideA = bA.isBullet() || !bA.isDynamic();\n          const collideB = bB.isBullet() || !bB.isDynamic();\n\n          // Are these two non-bullet dynamic bodies?\n          if (collideA == false && collideB == false) {\n            continue;\n          }\n\n          // Compute the TOI for this contact.\n          // Put the sweeps onto the same time interval.\n          let alpha0 = bA.m_sweep.alpha0;\n\n          if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {\n            alpha0 = bB.m_sweep.alpha0;\n            bA.m_sweep.advance(alpha0);\n          } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {\n            alpha0 = bA.m_sweep.alpha0;\n            bB.m_sweep.advance(alpha0);\n          }\n\n          _ASSERT && common.assert(alpha0 < 1.0);\n\n          const indexA = c.getChildIndexA();\n          const indexB = c.getChildIndexB();\n\n          const sweepA = bA.m_sweep;\n          const sweepB = bB.m_sweep;\n\n          // Compute the time of impact in interval [0, minTOI]\n          const input = new TOIInput(); // TODO: reuse\n          input.proxyA.set(fA.getShape(), indexA);\n          input.proxyB.set(fB.getShape(), indexB);\n          input.sweepA.set(bA.m_sweep);\n          input.sweepB.set(bB.m_sweep);\n          input.tMax = 1.0;\n\n          const output = new TOIOutput(); // TODO: reuse\n          TimeOfImpact(output, input);\n\n          // Beta is the fraction of the remaining portion of the [time?].\n          const beta = output.t;\n          if (output.state == TOIOutputState.e_touching) {\n            alpha = Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n          } else {\n            alpha = 1.0;\n          }\n\n          c.m_toi = alpha;\n          c.m_toiFlag = true;\n        }\n\n        if (alpha < minAlpha) {\n          // This is the minimum TOI found so far.\n          minContact = c;\n          minAlpha = alpha;\n        }\n      }\n\n      if (minContact == null || 1.0 - 10.0 * Math.EPSILON < minAlpha) {\n        // No more TOI events. Done!\n        world.m_stepComplete = true;\n        break;\n      }\n\n      // Advance the bodies to the TOI.\n      const fA = minContact.getFixtureA();\n      const fB = minContact.getFixtureB();\n      const bA = fA.getBody();\n      const bB = fB.getBody();\n\n      const backup1 = bA.m_sweep.clone();\n      const backup2 = bB.m_sweep.clone();\n\n      bA.advance(minAlpha);\n      bB.advance(minAlpha);\n\n      // The TOI contact likely has some new contact points.\n      minContact.update(world);\n      minContact.m_toiFlag = false;\n      ++minContact.m_toiCount;\n\n      // Is the contact solid?\n      if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n        // Restore the sweeps.\n        minContact.setEnabled(false);\n        bA.m_sweep.set(backup1);\n        bB.m_sweep.set(backup2);\n        bA.synchronizeTransform();\n        bB.synchronizeTransform();\n        continue;\n      }\n\n      bA.setAwake(true);\n      bB.setAwake(true);\n\n      // Build the island\n      this.clear();\n      this.addBody(bA);\n      this.addBody(bB);\n      this.addContact(minContact);\n\n      bA.m_islandFlag = true;\n      bB.m_islandFlag = true;\n      minContact.m_islandFlag = true;\n\n      // Get contacts on bodyA and bodyB.\n      const bodies = [ bA, bB ];\n      for (let i = 0; i < bodies.length; ++i) {\n        const body = bodies[i];\n        if (body.isDynamic()) {\n          for (let ce = body.m_contactList; ce; ce = ce.next) {\n            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n            // if (this.m_contactCount == this.m_contactCapacity) { break; }\n\n            const contact = ce.contact;\n\n            // Has this contact already been added to the island?\n            if (contact.m_islandFlag) {\n              continue;\n            }\n\n            // Only add if either is static, kinematic or bullet.\n            const other = ce.other;\n            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n              continue;\n            }\n\n            // Skip sensors.\n            const sensorA = contact.m_fixtureA.m_isSensor;\n            const sensorB = contact.m_fixtureB.m_isSensor;\n            if (sensorA || sensorB) {\n              continue;\n            }\n\n            // Tentatively advance the body to the TOI.\n            const backup = other.m_sweep.clone();\n            if (other.m_islandFlag == false) {\n              other.advance(minAlpha);\n            }\n\n            // Update the contact points\n            contact.update(world);\n\n            // Was the contact disabled by the user?\n            // Are there contact points?\n            if (contact.isEnabled() == false || contact.isTouching() == false) {\n              other.m_sweep.set(backup);\n              other.synchronizeTransform();\n              continue;\n            }\n\n            // Add the contact to the island\n            contact.m_islandFlag = true;\n            this.addContact(contact);\n\n            // Has the other body already been added to the island?\n            if (other.m_islandFlag) {\n              continue;\n            }\n\n            // Add the other body to the island.\n            other.m_islandFlag = true;\n\n            if (!other.isStatic()) {\n              other.setAwake(true);\n            }\n\n            this.addBody(other);\n          }\n        }\n      }\n\n      s_subStep.reset((1.0 - minAlpha) * step.dt);\n      s_subStep.dtRatio = 1.0;\n      s_subStep.positionIterations = 20;\n      s_subStep.velocityIterations = step.velocityIterations;\n      s_subStep.warmStarting = false;\n\n      this.solveIslandTOI(s_subStep, bA, bB);\n\n      // Reset island flags and synchronize broad-phase proxies.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        body.m_islandFlag = false;\n\n        if (!body.isDynamic()) {\n          continue;\n        }\n\n        body.synchronizeFixtures();\n\n        // Invalidate all contact TOIs on this displaced body.\n        for (let ce = body.m_contactList; ce; ce = ce.next) {\n          ce.contact.m_toiFlag = false;\n          ce.contact.m_islandFlag = false;\n        }\n      }\n\n      // Commit fixture proxy movements to the broad-phase so that new contacts\n      // are created.\n      // Also, some contacts can be destroyed.\n      world.findNewContacts();\n\n      if (world.m_subStepping) {\n        world.m_stepComplete = false;\n        break;\n      }\n    }\n\n    if (_DEBUG) for (let b = world.m_bodyList; b; b = b.m_next) {\n      const c = b.m_sweep.c;\n      const a = b.m_sweep.a;\n      const v = b.m_linearVelocity;\n      const w = b.m_angularVelocity;\n    }\n  }\n\n  solveIslandTOI(subStep: TimeStep, toiA: Body, toiB: Body): void {\n    const world = this.m_world;\n\n    // Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n      body.c_position.c.setVec2(body.m_sweep.c);\n      body.c_position.a = body.m_sweep.a;\n      body.c_velocity.v.setVec2(body.m_linearVelocity);\n      body.c_velocity.w = body.m_angularVelocity;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(subStep);\n    }\n\n    // Solve position constraints.\n    for (let i = 0; i < subStep.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n        minSeparation = Math.min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n      if (contactsOkay) {\n        break;\n      }\n    }\n\n    if (false) {\n      // Is the new position really safe?\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const c = this.m_contacts[i];\n        const fA = c.getFixtureA();\n        const fB = c.getFixtureB();\n\n        const bA = fA.getBody();\n        const bB = fB.getBody();\n\n        const indexA = c.getChildIndexA();\n        const indexB = c.getChildIndexB();\n\n        const input = new DistanceInput();\n        input.proxyA.set(fA.getShape(), indexA);\n        input.proxyB.set(fB.getShape(), indexB);\n        input.transformA = bA.getTransform();\n        input.transformB = bB.getTransform();\n        input.useRadii = false;\n\n        const output = new DistanceOutput();\n        const cache = new SimplexCache();\n        Distance(output, cache, input);\n\n        if (output.distance == 0 || cache.count == 3) {\n          cache.count += 0;\n        }\n      }\n    }\n\n    // Leap of faith to new safe state.\n    toiA.m_sweep.c0.setVec2(toiA.c_position.c);\n    toiA.m_sweep.a0 = toiA.c_position.a;\n    toiB.m_sweep.c0.setVec2(toiB.c_position.c);\n    toiB.m_sweep.a0 = toiB.c_position.a;\n\n    // No warm starting is needed for TOI events because warm\n    // starting impulses were applied in the discrete solver.\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(subStep);\n    }\n\n    // Solve velocity constraints.\n    for (let i = 0; i < subStep.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(subStep);\n      }\n    }\n\n    // Don't store the TOI contact forces for warm starting\n    // because they can be quite large.\n\n    const h = subStep.dt;\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      const c = Vec2.clone(body.c_position.c);\n      let a = body.c_position.a;\n      const v = Vec2.clone(body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      const translation = Vec2.mulNumVec2(h, v);\n      if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / translation.length();\n        v.mul(ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / Math.abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      c.addMul(h, v);\n      a += h * w;\n\n      body.c_position.c = c;\n      body.c_position.a = a;\n      body.c_velocity.v = v;\n      body.c_velocity.w = w;\n\n      // Sync bodies\n      body.m_sweep.c = c;\n      body.m_sweep.a = a;\n      body.m_linearVelocity = v;\n      body.m_angularVelocity = w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n  }\n\n  /** @internal */\n  postSolveIsland(): void {\n    for (let c = 0; c < this.m_contacts.length; ++c) {\n      const contact = this.m_contacts[c];\n      this.m_world.postSolve(contact, contact.m_impulse);\n    }\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport options from '../util/options';\nimport common from '../util/common';\nimport Vec2 from '../common/Vec2';\nimport BroadPhase from '../collision/BroadPhase';\nimport Solver, { ContactImpulse, TimeStep } from './Solver';\nimport Body, { BodyDef } from './Body';\nimport Joint from './Joint';\nimport Contact from './Contact';\nimport AABB, { RayCastInput, RayCastOutput } from \"../collision/AABB\";\nimport Fixture, { FixtureProxy } from \"./Fixture\";\nimport Manifold from \"../collision/Manifold\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * @prop gravity [{ x : 0, y : 0}]\n * @prop allowSleep [true]\n * @prop warmStarting [true]\n * @prop continuousPhysics [true]\n * @prop subStepping [false]\n * @prop blockSolve [true]\n * @prop velocityIterations [8] For the velocity constraint solver.\n * @prop positionIterations [3] For the position constraint solver.\n */\nexport interface WorldDef {\n  gravity?: Vec2;\n  allowSleep?: boolean;\n  warmStarting?: boolean;\n  continuousPhysics?: boolean;\n  subStepping?: boolean;\n  blockSolve?: boolean;\n  velocityIterations?: number;\n  positionIterations?: number;\n}\n\nconst WorldDefDefault: WorldDef = {\n  gravity : Vec2.zero(),\n  allowSleep : true,\n  warmStarting : true,\n  continuousPhysics : true,\n  subStepping : false,\n  blockSolve : true,\n  velocityIterations : 8,\n  positionIterations : 3\n};\n\n/**\n * Callback function for ray casts, see {@link World.rayCast}.\n *\n * Called for each fixture found in the query. You control how the ray cast\n * proceeds by returning a float: return -1: ignore this fixture and continue\n * return 0: terminate the ray cast return fraction: clip the ray to this point\n * return 1: don't clip the ray and continue\n *\n * @param fixture The fixture hit by the ray\n * @param point The point of initial intersection\n * @param normal The normal vector at the point of intersection\n * @param fraction\n *\n * @return -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue\n */\nexport type WorldRayCastCallback = (fixture: Fixture, point: Vec2, normal: Vec2, fraction: number) => number;\n\n/**\n * Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n */\nexport type WorldAABBQueryCallback = (fixture: Fixture) => boolean;\n\nexport default class World {\n  /** @internal */ m_solver: Solver;\n  /** @internal */ m_broadPhase: BroadPhase;\n  /** @internal */ m_contactList: Contact | null;\n  /** @internal */ m_contactCount: number;\n  /** @internal */ m_bodyList: Body | null;\n  /** @internal */ m_bodyCount: number;\n  /** @internal */ m_jointList: Joint | null;\n  /** @internal */ m_jointCount: number;\n  /** @internal */ m_stepComplete: boolean;\n  /** @internal */ m_allowSleep: boolean;\n  /** @internal */ m_gravity: Vec2;\n  /** @internal */ m_clearForces: boolean;\n  /** @internal */ m_newFixture: boolean;\n  /** @internal */ m_locked: boolean;\n  /** @internal */ m_warmStarting: boolean;\n  /** @internal */ m_continuousPhysics: boolean;\n  /** @internal */ m_subStepping: boolean;\n  /** @internal */ m_blockSolve: boolean;\n  /** @internal */ m_velocityIterations: number;\n  /** @internal */ m_positionIterations: number;\n  /** @internal */ m_t: number;\n\n  // TODO\n  /** @internal */ _listeners: {\n    [key: string]: any[]\n  };\n\n  /**\n   * @param def World definition or gravity vector.\n   */\n  constructor(def?: WorldDef | Vec2 | null) {\n    if (!(this instanceof World)) {\n      return new World(def);\n    }\n\n    if (def && Vec2.isValid(def)) {\n      def = { gravity: def as Vec2 };\n    }\n\n    def = options(def, WorldDefDefault) as WorldDef;\n\n    this.m_solver = new Solver(this);\n\n    this.m_broadPhase = new BroadPhase();\n\n    this.m_contactList = null;\n    this.m_contactCount = 0;\n\n    this.m_bodyList = null;\n    this.m_bodyCount = 0;\n\n    this.m_jointList = null;\n    this.m_jointCount = 0;\n\n    this.m_stepComplete = true;\n\n    this.m_allowSleep = def.allowSleep;\n    this.m_gravity = Vec2.clone(def.gravity);\n\n    this.m_clearForces = true;\n    this.m_newFixture = false;\n    this.m_locked = false;\n\n    // These are for debugging the solver.\n    this.m_warmStarting = def.warmStarting;\n    this.m_continuousPhysics = def.continuousPhysics;\n    this.m_subStepping = def.subStepping;\n\n    this.m_blockSolve = def.blockSolve;\n    this.m_velocityIterations = def.velocityIterations;\n    this.m_positionIterations = def.positionIterations;\n\n    this.m_t = 0;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const bodies = [];\n    const joints = [];\n\n    for (let b = this.getBodyList(); b; b = b.getNext()) {\n      bodies.push(b);\n    }\n\n    for (let j = this.getJointList(); j; j = j.getNext()) {\n      // @ts-ignore\n      if (typeof j._serialize === 'function') {\n        joints.push(j);\n      }\n    }\n\n    return {\n      gravity: this.m_gravity,\n      bodies,\n      joints,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, context: any, restore: any): World {\n    if (!data) {\n      return new World();\n    }\n\n    const world = new World(data.gravity);\n\n    if (data.bodies) {\n      for (let i = data.bodies.length - 1; i >= 0; i -= 1) {\n        world._addBody(restore(Body, data.bodies[i], world));\n      }\n    }\n\n    if (data.joints) {\n      for (let i = data.joints.length - 1; i >= 0; i--) {\n        world.createJoint(restore(Joint, data.joints[i], world));\n      }\n    }\n\n    return world;\n  }\n\n  /**\n   * Get the world body list. With the returned body, use Body.getNext to get the\n   * next body in the world list. A null body indicates the end of the list.\n   *\n   * @return the head of the world body list.\n   */\n  getBodyList(): Body | null {\n    return this.m_bodyList;\n  }\n\n  /**\n   * Get the world joint list. With the returned joint, use Joint.getNext to get\n   * the next joint in the world list. A null joint indicates the end of the list.\n   *\n   * @return the head of the world joint list.\n   */\n  getJointList(): Joint | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Get the world contact list. With the returned contact, use Contact.getNext to\n   * get the next contact in the world list. A null contact indicates the end of\n   * the list.\n   *\n   * Warning: contacts are created and destroyed in the middle of a time step.\n   * Use ContactListener to avoid missing contacts.\n   *\n   * @return the head of the world contact list.\n   */\n  getContactList(): Contact | null {\n    return this.m_contactList;\n  }\n\n  getBodyCount(): number {\n    return this.m_bodyCount;\n  }\n\n  getJointCount(): number {\n    return this.m_jointCount;\n  }\n\n  /**\n   * Get the number of contacts (each may have 0 or more contact points).\n   */\n  getContactCount(): number {\n    return this.m_contactCount;\n  }\n\n  /**\n   * Change the global gravity vector.\n   */\n  setGravity(gravity: Vec2): void {\n    this.m_gravity = gravity;\n  }\n\n  /**\n   * Get the global gravity vector.\n   */\n  getGravity(): Vec2 {\n    return this.m_gravity;\n  }\n\n  /**\n   * Is the world locked (in the middle of a time step).\n   */\n  isLocked(): boolean {\n    return this.m_locked;\n  }\n\n  /**\n   * Enable/disable sleep.\n   */\n  setAllowSleeping(flag: boolean): void {\n    if (flag == this.m_allowSleep) {\n      return;\n    }\n\n    this.m_allowSleep = flag;\n    if (this.m_allowSleep == false) {\n      for (let b = this.m_bodyList; b; b = b.m_next) {\n        b.setAwake(true);\n      }\n    }\n  }\n\n  getAllowSleeping(): boolean {\n    return this.m_allowSleep;\n  }\n\n  /**\n   * Enable/disable warm starting. For testing.\n   */\n  setWarmStarting(flag: boolean): void {\n    this.m_warmStarting = flag;\n  }\n\n  getWarmStarting(): boolean {\n    return this.m_warmStarting;\n  }\n\n  /**\n   * Enable/disable continuous physics. For testing.\n   */\n  setContinuousPhysics(flag: boolean): void {\n    this.m_continuousPhysics = flag;\n  }\n\n  getContinuousPhysics(): boolean {\n    return this.m_continuousPhysics;\n  }\n\n  /**\n   * Enable/disable single stepped continuous physics. For testing.\n   */\n  setSubStepping(flag: boolean): void {\n    this.m_subStepping = flag;\n  }\n\n  getSubStepping(): boolean {\n    return this.m_subStepping;\n  }\n\n  /**\n   * Set flag to control automatic clearing of forces after each time step.\n   */\n  setAutoClearForces(flag: boolean): void {\n    this.m_clearForces = flag;\n  }\n\n  /**\n   * Get the flag that controls automatic clearing of forces after each time step.\n   */\n  getAutoClearForces(): boolean {\n    return this.m_clearForces;\n  }\n\n  /**\n   * Manually clear the force buffer on all bodies. By default, forces are cleared\n   * automatically after each call to step. The default behavior is modified by\n   * calling setAutoClearForces. The purpose of this function is to support\n   * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n   * under a variable frame-rate. When you perform sub-stepping you will disable\n   * auto clearing of forces and instead call clearForces after all sub-steps are\n   * complete in one pass of your game loop.\n   *\n   * See {@link World.setAutoClearForces}\n   */\n  clearForces(): void {\n    for (let body = this.m_bodyList; body; body = body.getNext()) {\n      body.m_force.setZero();\n      body.m_torque = 0.0;\n    }\n  }\n\n  /**\n   * Query the world for all fixtures that potentially overlap the provided AABB.\n   *\n   * @param aabb The query box.\n   * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n   */\n  queryAABB(aabb: AABB, callback: WorldAABBQueryCallback): void {\n    _ASSERT && common.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n    this.m_broadPhase.query(aabb, function(proxyId: number): boolean { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      return callback(proxy.fixture);\n    });\n  }\n\n  /**\n   * Ray-cast the world for all fixtures in the path of the ray. Your callback\n   * controls whether you get the closest point, any point, or n-points. The\n   * ray-cast ignores shapes that contain the starting point.\n   *\n   * @param point1 The ray starting point\n   * @param point2 The ray ending point\n   * @param callback A user implemented callback function.\n   */\n  rayCast(point1: Vec2, point2: Vec2, callback: WorldRayCastCallback): void {\n    _ASSERT && common.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n\n    this.m_broadPhase.rayCast({\n      maxFraction : 1.0,\n      p1 : point1,\n      p2 : point2\n    }, function(input: RayCastInput, proxyId: number): number { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      const fixture = proxy.fixture;\n      const index = proxy.childIndex;\n      // @ts-ignore\n      const output: RayCastOutput = {}; // TODO GC\n      const hit = fixture.rayCast(output, input, index);\n      if (hit) {\n        const fraction = output.fraction;\n        const point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));\n        return callback(fixture, point, output.normal, fraction);\n      }\n      return input.maxFraction;\n    });\n  }\n\n  /**\n   * Get the number of broad-phase proxies.\n   */\n  getProxyCount(): number {\n    return this.m_broadPhase.getProxyCount();\n  }\n\n  /**\n   * Get the height of broad-phase dynamic tree.\n   */\n  getTreeHeight(): number {\n    return this.m_broadPhase.getTreeHeight();\n  }\n\n  /**\n   * Get the balance of broad-phase dynamic tree.\n   */\n  getTreeBalance(): number {\n    return this.m_broadPhase.getTreeBalance();\n  }\n\n  /**\n   * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n   * The minimum is 1.\n   */\n  getTreeQuality(): number {\n    return this.m_broadPhase.getTreeQuality();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The body shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    _ASSERT && common.assert(this.m_locked == false);\n    if (this.m_locked) {\n      return;\n    }\n\n    for (let b = this.m_bodyList; b; b = b.m_next) {\n      b.m_xf.p.sub(newOrigin);\n      b.m_sweep.c0.sub(newOrigin);\n      b.m_sweep.c.sub(newOrigin);\n    }\n\n    for (let j = this.m_jointList; j; j = j.m_next) {\n      j.shiftOrigin(newOrigin);\n    }\n\n    this.m_broadPhase.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * @internal Used for deserialize.\n   */\n  _addBody(body: Body): void {\n    _ASSERT && common.assert(this.isLocked() === false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Add to world doubly linked list.\n    body.m_prev = null;\n    body.m_next = this.m_bodyList;\n    if (this.m_bodyList) {\n      this.m_bodyList.m_prev = body;\n    }\n    this.m_bodyList = body;\n    ++this.m_bodyCount;\n  }\n\n  /**\n   * Create a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createBody(def?: BodyDef): Body;\n  createBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createBody(arg1?, arg2?) {\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n\n    const body = new Body(this, def);\n    this._addBody(body);\n    return body;\n  }\n\n  createDynamicBody(def?: BodyDef): Body;\n  createDynamicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createDynamicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'dynamic';\n    return this.createBody(def);\n  }\n\n  createKinematicBody(def?: BodyDef): Body;\n  createKinematicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createKinematicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'kinematic';\n    return this.createBody(def);\n  }\n\n  /**\n   * Destroy a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This automatically deletes all associated shapes and joints.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  destroyBody(b: Body): boolean {\n    _ASSERT && common.assert(this.m_bodyCount > 0);\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    if (b.m_destroyed) {\n      return false;\n    }\n\n    // Delete the attached joints.\n    let je = b.m_jointList;\n    while (je) {\n      const je0 = je;\n      je = je.next;\n\n      this.publish('remove-joint', je0.joint);\n      this.destroyJoint(je0.joint);\n\n      b.m_jointList = je;\n    }\n    b.m_jointList = null;\n\n    // Delete the attached contacts.\n    let ce = b.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n\n      this.destroyContact(ce0.contact);\n\n      b.m_contactList = ce;\n    }\n    b.m_contactList = null;\n\n    // Delete the attached fixtures. This destroys broad-phase proxies.\n    let f = b.m_fixtureList;\n    while (f) {\n      const f0 = f;\n      f = f.m_next;\n\n      this.publish('remove-fixture', f0);\n      f0.destroyProxies(this.m_broadPhase);\n\n      b.m_fixtureList = f;\n    }\n    b.m_fixtureList = null;\n\n    // Remove world body list.\n    if (b.m_prev) {\n      b.m_prev.m_next = b.m_next;\n    }\n\n    if (b.m_next) {\n      b.m_next.m_prev = b.m_prev;\n    }\n\n    if (b == this.m_bodyList) {\n      this.m_bodyList = b.m_next;\n    }\n\n    b.m_destroyed = true;\n\n    --this.m_bodyCount;\n\n    this.publish('remove-body', b);\n\n    return true;\n  }\n\n  /**\n   * Create a joint to constrain bodies together. No reference to the definition\n   * is retained. This may cause the connected bodies to cease colliding.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createJoint<T extends Joint>(joint: T): T | null {\n    _ASSERT && common.assert(!!joint.m_bodyA);\n    _ASSERT && common.assert(!!joint.m_bodyB);\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    // Connect to the world list.\n    joint.m_prev = null;\n    joint.m_next = this.m_jointList;\n    if (this.m_jointList) {\n      this.m_jointList.m_prev = joint;\n    }\n    this.m_jointList = joint;\n    ++this.m_jointCount;\n\n    // Connect to the bodies' doubly linked lists.\n    joint.m_edgeA.joint = joint;\n    joint.m_edgeA.other = joint.m_bodyB;\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n    if (joint.m_bodyA.m_jointList)\n      joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n    joint.m_bodyA.m_jointList = joint.m_edgeA;\n\n    joint.m_edgeB.joint = joint;\n    joint.m_edgeB.other = joint.m_bodyA;\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n    if (joint.m_bodyB.m_jointList)\n      joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n    joint.m_bodyB.m_jointList = joint.m_edgeB;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      for (let edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n        if (edge.other == joint.m_bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n      }\n    }\n\n    // Note: creating a joint doesn't wake the bodies.\n\n    return joint;\n  }\n\n  /**\n   * Destroy a joint. This may cause the connected bodies to begin colliding.\n   * Warning: This function is locked during callbacks.\n   */\n  destroyJoint(joint: Joint): void {\n    _ASSERT && common.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Remove from the doubly linked list.\n    if (joint.m_prev) {\n      joint.m_prev.m_next = joint.m_next;\n    }\n\n    if (joint.m_next) {\n      joint.m_next.m_prev = joint.m_prev;\n    }\n\n    if (joint == this.m_jointList) {\n      this.m_jointList = joint.m_next;\n    }\n\n    // Disconnect from bodies.\n    const bodyA = joint.m_bodyA;\n    const bodyB = joint.m_bodyB;\n\n    // Wake up connected bodies.\n    bodyA.setAwake(true);\n    bodyB.setAwake(true);\n\n    // Remove from body 1.\n    if (joint.m_edgeA.prev) {\n      joint.m_edgeA.prev.next = joint.m_edgeA.next;\n    }\n\n    if (joint.m_edgeA.next) {\n      joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n    }\n\n    if (joint.m_edgeA == bodyA.m_jointList) {\n      bodyA.m_jointList = joint.m_edgeA.next;\n    }\n\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = null;\n\n    // Remove from body 2\n    if (joint.m_edgeB.prev) {\n      joint.m_edgeB.prev.next = joint.m_edgeB.next;\n    }\n\n    if (joint.m_edgeB.next) {\n      joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n    }\n\n    if (joint.m_edgeB == bodyB.m_jointList) {\n      bodyB.m_jointList = joint.m_edgeB.next;\n    }\n\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = null;\n\n    _ASSERT && common.assert(this.m_jointCount > 0);\n    --this.m_jointCount;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      let edge = bodyB.getContactList();\n      while (edge) {\n        if (edge.other == bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n\n        edge = edge.next;\n      }\n    }\n\n    this.publish('remove-joint', joint);\n  }\n\n  /** @internal */\n  s_step: TimeStep = new TimeStep(); // reuse\n\n  /**\n   * Take a time step. This performs collision detection, integration, and\n   * constraint solution.\n   *\n   * Broad-phase, narrow-phase, solve and solve time of impacts.\n   *\n   * @param timeStep Time step, this should not vary.\n   */\n  step(timeStep: number, velocityIterations?: number, positionIterations?: number): void {\n    this.publish('pre-step', timeStep);\n\n    if ((velocityIterations | 0) !== velocityIterations) {\n      // TODO: remove this in future\n      velocityIterations = 0;\n    }\n\n    velocityIterations = velocityIterations || this.m_velocityIterations;\n    positionIterations = positionIterations || this.m_positionIterations;\n\n    // If new fixtures were added, we need to find the new contacts.\n    if (this.m_newFixture) {\n      this.findNewContacts();\n      this.m_newFixture = false;\n    }\n\n    this.m_locked = true;\n\n    this.s_step.reset(timeStep);\n    this.s_step.velocityIterations = velocityIterations;\n    this.s_step.positionIterations = positionIterations;\n    this.s_step.warmStarting = this.m_warmStarting;\n    this.s_step.blockSolve = this.m_blockSolve;\n\n    // Update contacts. This is where some contacts are destroyed.\n    this.updateContacts();\n\n    // Integrate velocities, solve velocity constraints, and integrate positions.\n    if (this.m_stepComplete && timeStep > 0.0) {\n      this.m_solver.solveWorld(this.s_step);\n\n      // Synchronize fixtures, check for out of range bodies.\n      for (let b = this.m_bodyList; b; b = b.getNext()) {\n        // If a body was not in an island then it did not move.\n        if (b.m_islandFlag == false) {\n          continue;\n        }\n\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Update fixtures (for broad-phase).\n        b.synchronizeFixtures();\n      }\n      // Look for new contacts.\n      this.findNewContacts();\n    }\n\n    // Handle TOI events.\n    if (this.m_continuousPhysics && timeStep > 0.0) {\n      this.m_solver.solveWorldTOI(this.s_step);\n    }\n\n    if (this.m_clearForces) {\n      this.clearForces();\n    }\n\n    this.m_locked = false;\n\n    this.publish('post-step', timeStep);\n  }\n\n  /**\n   * @internal\n   * Call this method to find new contacts.\n   */\n  findNewContacts(): void {\n    this.m_broadPhase.updatePairs(this.createContact);\n  }\n\n  /**\n   * @internal\n   * Callback for broad-phase.\n   */\n  createContact = (proxyA: FixtureProxy, proxyB: FixtureProxy): void => {\n    const fixtureA = proxyA.fixture;\n    const fixtureB = proxyB.fixture;\n\n    const indexA = proxyA.childIndex;\n    const indexB = proxyB.childIndex;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    // Are the fixtures on the same body?\n    if (bodyA == bodyB) {\n      return;\n    }\n\n    // TODO_ERIN use a hash table to remove a potential bottleneck when both\n    // bodies have a lot of contacts.\n    // Does a contact already exist?\n    let edge = bodyB.getContactList(); // ContactEdge\n    while (edge) {\n      if (edge.other == bodyA) {\n        const fA = edge.contact.getFixtureA();\n        const fB = edge.contact.getFixtureB();\n        const iA = edge.contact.getChildIndexA();\n        const iB = edge.contact.getChildIndexB();\n\n        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n          // A contact already exists.\n          return;\n        }\n\n        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n          // A contact already exists.\n          return;\n        }\n      }\n\n      edge = edge.next;\n    }\n\n    if (bodyB.shouldCollide(bodyA) == false) {\n      return;\n    }\n    if (fixtureB.shouldCollide(fixtureA) == false) {\n      return;\n    }\n\n    // Call the factory.\n    const contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n    if (contact == null) {\n      return;\n    }\n\n    // Insert into the world.\n    contact.m_prev = null;\n    if (this.m_contactList != null) {\n      contact.m_next = this.m_contactList;\n      this.m_contactList.m_prev = contact;\n    }\n    this.m_contactList = contact;\n\n    ++this.m_contactCount;\n  }\n\n  /**\n   * @internal\n   * Removes old non-overlapping contacts, applies filters and updates contacts.\n   */\n  updateContacts(): void {\n    // Update awake contacts.\n    let c;\n    let next_c = this.m_contactList;\n    while (c = next_c) {\n      next_c = c.getNext();\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n      const indexA = c.getChildIndexA();\n      const indexB = c.getChildIndexB();\n      const bodyA = fixtureA.getBody();\n      const bodyB = fixtureB.getBody();\n\n      // Is this contact flagged for filtering?\n      if (c.m_filterFlag) {\n        if (bodyB.shouldCollide(bodyA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        if (fixtureB.shouldCollide(fixtureA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        // Clear the filtering flag.\n        c.m_filterFlag = false;\n      }\n\n      const activeA = bodyA.isAwake() && !bodyA.isStatic();\n      const activeB = bodyB.isAwake() && !bodyB.isStatic();\n\n      // At least one body must be awake and it must be dynamic or kinematic.\n      if (activeA == false && activeB == false) {\n        continue;\n      }\n\n      const proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n      const proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n      const overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n\n      // Here we destroy contacts that cease to overlap in the broad-phase.\n      if (overlap == false) {\n        this.destroyContact(c);\n        continue;\n      }\n\n      // The contact persists.\n      c.update(this);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  destroyContact(contact: Contact): void {\n    Contact.destroy(contact, this);\n\n    // Remove from the world.\n    if (contact.m_prev) {\n      contact.m_prev.m_next = contact.m_next;\n    }\n    if (contact.m_next) {\n      contact.m_next.m_prev = contact.m_prev;\n    }\n    if (contact == this.m_contactList) {\n      this.m_contactList = contact.m_next;\n    }\n\n    --this.m_contactCount;\n  }\n\n\n  /**\n   * Called when two fixtures begin to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  /**\n   * Called when two fixtures cease to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'end-contact', listener: (contact: Contact) => void): World;\n  /**\n   * This is called after a contact is updated. This allows you to inspect a\n   * contact before it goes to the solver. If you are careful, you can modify the\n   * contact manifold (e.g. disable contact). A copy of the old manifold is\n   * provided so that you can detect changes. Note: this is called only for awake\n   * bodies. Note: this is called even when the number of contact points is zero.\n   * Note: this is not called for sensors. Note: if you set the number of contact\n   * points to zero, you will not get an endContact callback. However, you may get\n   * a beginContact callback the next step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  /**\n   * This lets you inspect a contact after the solver is finished. This is useful\n   * for inspecting impulses. Note: the contact manifold does not include time of\n   * impact impulses, which can be arbitrarily large if the sub-step is small.\n   * Hence the impulse is provided explicitly in a separate data structure. Note:\n   * this is only called for contacts that are touching, solid, and awake.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  /** Listener is called whenever a body is removed. */\n  on(name: 'remove-body', listener: (body: Body) => void): World;\n  /** Listener is called whenever a joint is removed implicitly or explicitly. */\n  on(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  /** Listener is called whenever a fixture is removed implicitly or explicitly. */\n  on(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Register an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  on(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    if (!this._listeners) {\n      this._listeners = {};\n    }\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    this._listeners[name].push(listener);\n    return this;\n  }\n\n  off(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  off(name: 'end-contact', listener: (contact: Contact) => void): World;\n  off(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  off(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  off(name: 'remove-body', listener: (body: Body) => void): World;\n  off(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  off(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Remove an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  off(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n    const index = listeners.indexOf(listener);\n    if (index >= 0) {\n      listeners.splice(index, 1);\n    }\n    return this;\n  }\n\n  publish(name: string, arg1?: any, arg2?: any, arg3?: any): number {\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return 0;\n    }\n    for (let l = 0; l < listeners.length; l++) {\n      listeners[l].call(this, arg1, arg2, arg3);\n    }\n    return listeners.length;\n  }\n\n  /**\n   * @internal\n   */\n  beginContact(contact: Contact): void {\n    this.publish('begin-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  endContact(contact: Contact): void {\n    this.publish('end-contact', contact);\n  }\n\n  /**\n   * @internal\n   */\n  preSolve(contact: Contact, oldManifold: Manifold): void {\n    this.publish('pre-solve', contact, oldManifold);\n  }\n\n  /**\n   * @internal\n   */\n  postSolve(contact: Contact, impulse: ContactImpulse): void {\n    this.publish('post-solve', contact, impulse);\n  }\n\n  /**\n   * Joints and fixtures are destroyed when their associated body is destroyed.\n   * Register a destruction listener so that you may nullify references to these\n   * joints and shapes.\n   *\n   * `function(object)` is called when any joint or fixture is about to\n   * be destroyed due to the destruction of one of its attached or parent bodies.\n   */\n\n  /**\n   * Register a contact filter to provide specific control over collision.\n   * Otherwise the default filter is used (defaultFilter). The listener is owned\n   * by you and must remain in scope.\n   *\n   * Moved to Fixture.\n   */\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Math from './Math';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport default class Vec3 {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z: number);\n  constructor(obj: { x: number, y: number, z: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?, z?) {\n    if (!(this instanceof Vec3)) {\n      return new Vec3(x, y, z);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n      this.z = x.z;\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n    _ASSERT && Vec3.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    obj.z = data.z;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number, z: number): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = x;\n    obj.y = y;\n    obj.z = z;\n    return obj;\n  }\n\n  static zero(): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    obj.z = 0;\n    return obj;\n  }\n\n  static clone(v: Vec3): Vec3 {\n    _ASSERT && Vec3.assert(v);\n    return Vec3.neo(v.x, v.y, v.z);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Math.isFinite(obj.x) && Math.isFinite(obj.y) && Math.isFinite(obj.z);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Vec3.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Vec3!');\n    }\n  }\n\n  setZero(): Vec3 {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number, z: number): Vec3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  add(w: Vec3): Vec3 {\n    this.x += w.x;\n    this.y += w.y;\n    this.z += w.z;\n    return this;\n  }\n\n  sub(w: Vec3): Vec3 {\n    this.x -= w.x;\n    this.y -= w.y;\n    this.z -= w.z;\n    return this;\n  }\n\n  mul(m: number): Vec3 {\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    return this;\n  }\n\n  static areEqual(v: Vec3, w: Vec3): boolean {\n    _ASSERT && Vec3.assert(v);\n    _ASSERT && Vec3.assert(w);\n    return v === w ||\n      typeof v === 'object' && v !== null &&\n      typeof w === 'object' && w !== null &&\n      v.x === w.x && v.y === w.y && v.z === w.z;\n  }\n\n  /**\n   * Perform the dot product on two vectors.\n   */\n  static dot(v: Vec3, w: Vec3): number {\n    return v.x * w.x + v.y * w.y + v.z * w.z;\n  }\n\n  /**\n   * Perform the cross product on two vectors. In 2D this produces a scalar.\n   */\n  static cross(v: Vec3, w: Vec3): Vec3 {\n    return new Vec3(\n      v.y * w.z - v.z * w.y,\n      v.z * w.x - v.x * w.z,\n      v.x * w.y - v.y * w.x\n    );\n  }\n\n  static add(v: Vec3, w: Vec3): Vec3 {\n    return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n  }\n\n  static sub(v: Vec3, w: Vec3): Vec3 {\n    return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n  }\n\n  static mul(v: Vec3, m: number): Vec3 {\n    return new Vec3(m * v.x, m * v.y, m * v.z);\n  }\n\n  neg(): Vec3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  static neg(v: Vec3): Vec3 {\n    return new Vec3(-v.x, -v.y, -v.z);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport Settings from '../../Settings';\nimport Shape from '../Shape';\nimport Transform from '../../common/Transform';\nimport Rot from '../../common/Rot';\nimport Vec2 from '../../common/Vec2';\nimport AABB, { RayCastInput, RayCastOutput } from '../AABB';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n/**\n * A line segment (edge) shape. These can be connected in chains or loops to\n * other edge shapes. The connectivity information is used to ensure correct\n * contact normals.\n */\nexport default class EdgeShape extends Shape {\n  static TYPE = 'edge' as const;\n\n  // These are the edge vertices\n  m_vertex1: Vec2;\n  m_vertex2: Vec2;\n\n  // Optional adjacent vertices. These are used for smooth collision.\n  // Used by chain shape.\n  m_vertex0: Vec2;\n  m_vertex3: Vec2;\n  m_hasVertex0: boolean;\n  m_hasVertex3: boolean;\n\n  constructor(v1?: Vec2, v2?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof EdgeShape)) {\n      return new EdgeShape(v1, v2);\n    }\n\n    super();\n\n    this.m_type = EdgeShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n\n\n    this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n    this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n\n    this.m_vertex0 = Vec2.zero();\n    this.m_vertex3 = Vec2.zero();\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertex1: this.m_vertex1,\n      vertex2: this.m_vertex2,\n\n      vertex0: this.m_vertex0,\n      vertex3: this.m_vertex3,\n      hasVertex0: this.m_hasVertex0,\n      hasVertex3: this.m_hasVertex3,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): EdgeShape {\n    const shape = new EdgeShape(data.vertex1, data.vertex2);\n    if (shape.m_hasVertex0) {\n      shape.setPrevVertex(data.vertex0);\n    }\n    if (shape.m_hasVertex3) {\n      shape.setNextVertex(data.vertex3);\n    }\n    return shape;\n  }\n\n  /** @internal @deprecated */\n  setNext(v?: Vec2): EdgeShape {\n    return this.setNextVertex(v);\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  setNextVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex3.setVec2(v);\n      this.m_hasVertex3 = true;\n    } else {\n      this.m_vertex3.setZero();\n      this.m_hasVertex3 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  getNextVertex(): Vec2 {\n    return this.m_vertex3;\n  }\n\n  /** @internal @deprecated */\n  setPrev(v?: Vec2): EdgeShape {\n    return this.setPrevVertex(v);\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  setPrevVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex0.setVec2(v);\n      this.m_hasVertex0 = true;\n    } else {\n      this.m_vertex0.setZero();\n      this.m_hasVertex0 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  getPrevVertex(): Vec2 {\n    return this.m_vertex0;\n  }\n\n  /**\n   * Set this as an isolated edge.\n   */\n  _set(v1: Vec2, v2: Vec2): EdgeShape {\n    this.m_vertex1.setVec2(v1);\n    this.m_vertex2.setVec2(v2);\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n    return this;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): EdgeShape {\n    const clone = new EdgeShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_vertex1.setVec2(this.m_vertex1);\n    clone.m_vertex2.setVec2(this.m_vertex2);\n    clone.m_vertex0.setVec2(this.m_vertex0);\n    clone.m_vertex3.setVec2(this.m_vertex3);\n    clone.m_hasVertex0 = this.m_hasVertex0;\n    clone.m_hasVertex3 = this.m_hasVertex3;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // p = p1 + t * d\n    // v = v1 + s * e\n    // p1 + t * d = v1 + s * e\n    // s * e - t * d = p1 - v1\n\n    // NOT_USED(childIndex);\n\n    // Put the ray into the edge's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    const v1 = this.m_vertex1;\n    const v2 = this.m_vertex2;\n    const e = Vec2.sub(v2, v1);\n    const normal = Vec2.neo(e.y, -e.x);\n    normal.normalize();\n\n    // q = p1 + t * d\n    // dot(normal, q - v1) = 0\n    // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n    const numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n    const denominator = Vec2.dot(normal, d);\n\n    if (denominator == 0.0) {\n      return false;\n    }\n\n    const t = numerator / denominator;\n    if (t < 0.0 || input.maxFraction < t) {\n      return false;\n    }\n\n    const q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n\n    // q = v1 + s * r\n    // s = dot(q - v1, r) / dot(r, r)\n    const r = Vec2.sub(v2, v1);\n    const rr = Vec2.dot(r, r);\n    if (rr == 0.0) {\n      return false;\n    }\n\n    const s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n    if (s < 0.0 || 1.0 < s) {\n      return false;\n    }\n\n    output.fraction = t;\n    if (numerator > 0.0) {\n      output.normal = Rot.mulVec2(xf.q, normal).neg();\n    } else {\n      output.normal = Rot.mulVec2(xf.q, normal);\n    }\n    return true;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    const v1 = Transform.mulVec2(xf, this.m_vertex1);\n    const v2 = Transform.mulVec2(xf, this.m_vertex2);\n\n    aabb.combinePoints(v1, v2);\n    aabb.extend(this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    massData.center.setCombine(0.5, this.m_vertex1, 0.5, this.m_vertex2);\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices.push(this.m_vertex1);\n    proxy.m_vertices.push(this.m_vertex2);\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../../dynamics/Body';\nimport AABB, { RayCastOutput, RayCastInput } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport common from '../../util/common';\nimport Transform from '../../common/Transform';\nimport Vec2 from '../../common/Vec2';\nimport Settings from '../../Settings';\nimport Shape from '../Shape';\nimport EdgeShape from './EdgeShape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A chain shape is a free form sequence of line segments. The chain has\n * two-sided collision, so you can use inside and outside collision. Therefore,\n * you may use any winding order. Connectivity information is used to create\n * smooth collisions.\n *\n * WARNING: The chain will not collide properly if there are self-intersections.\n */\nexport default class ChainShape extends Shape {\n  static TYPE = 'chain' as const;\n\n  m_vertices: Vec2[];\n  m_count: number;\n  m_prevVertex: Vec2 | null;\n  m_nextVertex: Vec2 | null;\n  m_hasPrevVertex: boolean;\n  m_hasNextVertex: boolean;\n\n  m_isLoop: boolean;\n\n  constructor(vertices?: Vec2[], loop?: boolean) {\n    // @ts-ignore\n    if (!(this instanceof ChainShape)) {\n      return new ChainShape(vertices, loop);\n    }\n\n    super();\n\n    this.m_type = ChainShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_vertices = [];\n    this.m_count = 0;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n\n    this.m_isLoop = !!loop;\n\n    if (vertices && vertices.length) {\n      if (loop) {\n        this._createLoop(vertices);\n      } else {\n        this._createChain(vertices);\n      }\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const data = {\n      type: this.m_type,\n      vertices: this.m_vertices,\n      isLoop: this.m_isLoop,\n      hasPrevVertex: this.m_hasPrevVertex,\n      hasNextVertex: this.m_hasNextVertex,\n      prevVertex: null as Vec2 | null,\n      nextVertex: null as Vec2 | null,\n    };\n    if (this.m_prevVertex) {\n      data.prevVertex = this.m_prevVertex;\n    }\n    if (this.m_nextVertex) {\n      data.nextVertex = this.m_nextVertex;\n    }\n    return data;\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): ChainShape {\n    const vertices = [] as Vec2[];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n    const shape = new ChainShape(vertices, data.isLoop);\n    if (data.prevVertex) {\n      shape.setPrevVertex(data.prevVertex);\n    }\n    if (data.nextVertex) {\n      shape.setNextVertex(data.nextVertex);\n    }\n    return shape;\n  }\n\n  // clear() {\n  //   this.m_vertices.length = 0;\n  //   this.m_count = 0;\n  // }\n\n  /**\n   * @internal\n   * Create a loop. This automatically adjusts connectivity.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createLoop(vertices: Vec2[]): ChainShape {\n    _ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && common.assert(vertices.length >= 3);\n    for (let i = 1; i < vertices.length; ++i) {\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      // If the code crashes here, it means your vertices are too close together.\n      _ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_vertices = [];\n    this.m_count = vertices.length + 1;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n    this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n\n    this.m_prevVertex = this.m_vertices[this.m_count - 2];\n    this.m_nextVertex = this.m_vertices[1];\n    this.m_hasPrevVertex = true;\n    this.m_hasNextVertex = true;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Create a chain with isolated end vertices.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createChain(vertices: Vec2[]): ChainShape {\n    _ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && common.assert(vertices.length >= 2);\n    for (let i = 1; i < vertices.length; ++i) {\n      // If the code crashes here, it means your vertices are too close together.\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      _ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_count = vertices.length;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    return this;\n  }\n\n  /** @internal */\n  _reset(): void {\n    if (this.m_isLoop) {\n      this._createLoop(this.m_vertices);\n    } else {\n      this._createChain(this.m_vertices);\n    }\n  }\n\n  /**\n   * Establish connectivity to a vertex that precedes the first vertex. Don't call\n   * this for loops.\n   */\n  setPrevVertex(prevVertex: Vec2): void {\n    this.m_prevVertex = prevVertex;\n    this.m_hasPrevVertex = true;\n  }\n\n  getPrevVertex(): Vec2 {\n    return this.m_prevVertex;\n  }\n\n  /**\n   * Establish connectivity to a vertex that follows the last vertex. Don't call\n   * this for loops.\n   */\n  setNextVertex(nextVertex: Vec2): void {\n    this.m_nextVertex = nextVertex;\n    this.m_hasNextVertex = true;\n  }\n\n  getNextVertex(): Vec2 {\n    return this.m_nextVertex;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): ChainShape {\n    const clone = new ChainShape();\n    clone._createChain(this.m_vertices);\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_prevVertex = this.m_prevVertex;\n    clone.m_nextVertex = this.m_nextVertex;\n    clone.m_hasPrevVertex = this.m_hasPrevVertex;\n    clone.m_hasNextVertex = this.m_hasNextVertex;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): number {\n    // edge count = vertex count - 1\n    return this.m_count - 1;\n  }\n\n  // Get a child edge.\n  getChildEdge(edge: EdgeShape, childIndex: number): void {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count - 1);\n    edge.m_type = EdgeShape.TYPE;\n    edge.m_radius = this.m_radius;\n\n    edge.m_vertex1 = this.m_vertices[childIndex];\n    edge.m_vertex2 = this.m_vertices[childIndex + 1];\n\n    if (childIndex > 0) {\n      edge.m_vertex0 = this.m_vertices[childIndex - 1];\n      edge.m_hasVertex0 = true;\n    } else {\n      edge.m_vertex0 = this.m_prevVertex;\n      edge.m_hasVertex0 = this.m_hasPrevVertex;\n    }\n\n    if (childIndex < this.m_count - 2) {\n      edge.m_vertex3 = this.m_vertices[childIndex + 2];\n      edge.m_hasVertex3 = true;\n    } else {\n      edge.m_vertex3 = this.m_nextVertex;\n      edge.m_hasVertex3 = this.m_hasNextVertex;\n    }\n  }\n\n  getVertex(index: number): Vec2 {\n    _ASSERT && common.assert(0 <= index && index <= this.m_count);\n    if (index < this.m_count) {\n      return this.m_vertices[index];\n    } else {\n      return this.m_vertices[0];\n    }\n  }\n\n  isLoop(): boolean {\n    return this.m_isLoop;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * This always return false.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);\n\n    const edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n    return edgeShape.rayCast(output, input, xf, 0);\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);\n\n    const v1 = Transform.mulVec2(xf, this.getVertex(childIndex));\n    const v2 = Transform.mulVec2(xf, this.getVertex(childIndex + 1));\n\n    aabb.combinePoints(v1, v2);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * Chains have zero mass.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    massData.center = Vec2.zero();\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void {\n    _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);\n    proxy.m_buffer[0] = this.getVertex(childIndex);\n    proxy.m_buffer[1] = this.getVertex(childIndex + 1);\n    proxy.m_vertices = proxy.m_buffer;\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../../dynamics/Body';\nimport AABB, { RayCastOutput, RayCastInput } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport common from '../../util/common';\nimport Math from '../../common/Math';\nimport Transform from '../../common/Transform';\nimport Rot from '../../common/Rot';\nimport Vec2 from '../../common/Vec2';\nimport Settings from '../../Settings';\nimport Shape from '../Shape';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A convex polygon. It is assumed that the interior of the polygon is to the\n * left of each edge. Polygons have a maximum number of vertices equal to\n * Settings.maxPolygonVertices. In most cases you should not need many vertices\n * for a convex polygon. extends Shape\n */\nexport default class PolygonShape extends Shape {\n  static TYPE = 'polygon' as const;\n\n  m_centroid: Vec2;\n  m_vertices: Vec2[]; // [Settings.maxPolygonVertices]\n  m_normals: Vec2[]; // [Settings.maxPolygonVertices]\n  m_count: number;\n\n  // @ts-ignore\n  constructor(vertices?: Vec2[]) {\n    // @ts-ignore\n    if (!(this instanceof PolygonShape)) {\n      return new PolygonShape(vertices);\n    }\n\n    super();\n\n    this.m_type = PolygonShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_centroid = Vec2.zero();\n    this.m_vertices = [];\n    this.m_normals = [];\n    this.m_count = 0;\n\n    if (vertices && vertices.length) {\n      this._set(vertices);\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertices: this.m_vertices,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): PolygonShape {\n    const vertices = [] as Vec2[];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n\n    const shape = new PolygonShape(vertices);\n    return shape;\n  }\n\n  getVertex(index: number): Vec2 {\n    _ASSERT && common.assert(0 <= index && index < this.m_count);\n    return this.m_vertices[index];\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): PolygonShape {\n    const clone = new PolygonShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_count = this.m_count;\n    clone.m_centroid.setVec2(this.m_centroid);\n    for (let i = 0; i < this.m_count; i++) {\n      clone.m_vertices.push(this.m_vertices[i].clone());\n    }\n    for (let i = 0; i < this.m_normals.length; i++) {\n      clone.m_normals.push(this.m_normals[i].clone());\n    }\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /** @internal */\n  _reset(): void {\n    this._set(this.m_vertices);\n  }\n\n  /**\n   * @internal\n   *\n   * Create a convex hull from the given array of local points. The count must be\n   * in the range [3, Settings.maxPolygonVertices].\n   *\n   * Warning: the points may be re-ordered, even if they form a convex polygon\n   * Warning: collinear points are handled but not removed. Collinear points may\n   * lead to poor stacking behavior.\n   */\n  _set(vertices: Vec2[]): void {\n    _ASSERT && common.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);\n    if (vertices.length < 3) {\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    let n = Math.min(vertices.length, Settings.maxPolygonVertices);\n\n    // Perform welding and copy vertices into local buffer.\n    const ps = [] as Vec2[]; // [Settings.maxPolygonVertices];\n    for (let i = 0; i < n; ++i) {\n      const v = vertices[i];\n\n      let unique = true;\n      for (let j = 0; j < ps.length; ++j) {\n        if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n          unique = false;\n          break;\n        }\n      }\n\n      if (unique) {\n        ps.push(v);\n      }\n    }\n\n    n = ps.length;\n    if (n < 3) {\n      // Polygon is degenerate.\n      _ASSERT && common.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    // Create the convex hull using the Gift wrapping algorithm\n    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n\n    // Find the right most point on the hull (in case of multiple points bottom most is used)\n    let i0 = 0;\n    let x0 = ps[0].x;\n    for (let i = 1; i < n; ++i) {\n      const x = ps[i].x;\n      if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\n        i0 = i;\n        x0 = x;\n      }\n    }\n\n    const hull = [] as number[]; // [Settings.maxPolygonVertices];\n    let m = 0;\n    let ih = i0;\n\n    while (true) {\n      hull[m] = ih;\n\n      let ie = 0;\n      for (let j = 1; j < n; ++j) {\n        if (ie === ih) {\n          ie = j;\n          continue;\n        }\n\n        const r = Vec2.sub(ps[ie], ps[hull[m]]);\n        const v = Vec2.sub(ps[j], ps[hull[m]]);\n        const c = Vec2.crossVec2Vec2(r, v);\n        // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n        if (c < 0.0) {\n          ie = j;\n        }\n\n        // Collinearity check\n        if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {\n          ie = j;\n        }\n      }\n\n      ++m;\n      ih = ie;\n\n      if (ie === i0) {\n        break;\n      }\n    }\n\n    if (m < 3) {\n      // Polygon is degenerate.\n      _ASSERT && common.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    this.m_count = m;\n\n    // Copy vertices.\n    this.m_vertices = [];\n    for (let i = 0; i < m; ++i) {\n      this.m_vertices[i] = ps[hull[i]];\n    }\n\n    // Compute normals. Ensure the edges have non-zero length.\n    for (let i = 0; i < m; ++i) {\n      const i1 = i;\n      const i2 = i + 1 < m ? i + 1 : 0;\n      const edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n      _ASSERT && common.assert(edge.lengthSquared() > Math.EPSILON * Math.EPSILON);\n      this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n      this.m_normals[i].normalize();\n    }\n\n    // Compute the polygon centroid.\n    this.m_centroid = ComputeCentroid(this.m_vertices, m);\n  }\n\n  /** @internal */\n  _setAsBox(hx: number, hy: number, center?: Vec2, angle?: number): void {\n    // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n    this.m_vertices[0] = Vec2.neo(hx, -hy);\n    this.m_vertices[1] = Vec2.neo(hx, hy);\n    this.m_vertices[2] = Vec2.neo(-hx, hy);\n    this.m_vertices[3] = Vec2.neo(-hx, -hy);\n\n    this.m_normals[0] = Vec2.neo(1.0, 0.0);\n    this.m_normals[1] = Vec2.neo(0.0, 1.0);\n    this.m_normals[2] = Vec2.neo(-1.0, 0.0);\n    this.m_normals[3] = Vec2.neo(0.0, -1.0);\n\n    this.m_count = 4;\n\n    if (Vec2.isValid(center)) {\n      angle = angle || 0;\n\n      this.m_centroid.setVec2(center);\n\n      const xf = Transform.identity();\n      xf.p.setVec2(center);\n      xf.q.setAngle(angle);\n\n      // Transform vertices and normals.\n      for (let i = 0; i < this.m_count; ++i) {\n        this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n        this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n      }\n    }\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): boolean {\n    const pLocal = Rot.mulTVec2(xf.q, Vec2.sub(p, xf.p));\n\n    for (let i = 0; i < this.m_count; ++i) {\n      const dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));\n      if (dot > 0.0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n\n    // Put the ray into the polygon's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    let lower = 0.0;\n    let upper = input.maxFraction;\n\n    let index = -1;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // p = p1 + a * d\n      // dot(normal, p - v) = 0\n      // dot(normal, p1 - v) + a * dot(normal, d) = 0\n      const numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n      const denominator = Vec2.dot(this.m_normals[i], d);\n\n      if (denominator == 0.0) {\n        if (numerator < 0.0) {\n          return false;\n        }\n      } else {\n        // Note: we want this predicate without division:\n        // lower < numerator / denominator, where denominator < 0\n        // Since denominator < 0, we have to flip the inequality:\n        // lower < numerator / denominator <==> denominator * lower > numerator.\n        if (denominator < 0.0 && numerator < lower * denominator) {\n          // Increase lower.\n          // The segment enters this half-space.\n          lower = numerator / denominator;\n          index = i;\n        } else if (denominator > 0.0 && numerator < upper * denominator) {\n          // Decrease upper.\n          // The segment exits this half-space.\n          upper = numerator / denominator;\n        }\n      }\n\n      // The use of epsilon here causes the assert on lower to trip\n      // in some cases. Apparently the use of epsilon was to make edge\n      // shapes work, but now those are handled separately.\n      // if (upper < lower - Math.EPSILON)\n      if (upper < lower) {\n        return false;\n      }\n    }\n\n    _ASSERT && common.assert(0.0 <= lower && lower <= input.maxFraction);\n\n    if (index >= 0) {\n      output.fraction = lower;\n      output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = Transform.mulVec2(xf, this.m_vertices[i]);\n      minX = Math.min(minX, v.x);\n      maxX = Math.max(maxX, v.x);\n      minY = Math.min(minY, v.y);\n      maxY = Math.max(maxY, v.y);\n    }\n\n    aabb.lowerBound.setNum(minX, minY);\n    aabb.upperBound.setNum(maxX, maxY);\n    aabb.extend(this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    // Polygon mass, centroid, and inertia.\n    // Let rho be the polygon density in mass per unit area.\n    // Then:\n    // mass = rho * int(dA)\n    // centroid.x = (1/mass) * rho * int(x * dA)\n    // centroid.y = (1/mass) * rho * int(y * dA)\n    // I = rho * int((x*x + y*y) * dA)\n    //\n    // We can compute these integrals by summing all the integrals\n    // for each triangle of the polygon. To evaluate the integral\n    // for a single triangle, we make a change of variables to\n    // the (u,v) coordinates of the triangle:\n    // x = x0 + e1x * u + e2x * v\n    // y = y0 + e1y * u + e2y * v\n    // where 0 <= u && 0 <= v && u + v <= 1.\n    //\n    // We integrate u from [0,1-v] and then v from [0,1].\n    // We also need to use the Jacobian of the transformation:\n    // D = cross(e1, e2)\n    //\n    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\n    //\n    // The rest of the derivation is handled by computer algebra.\n\n    _ASSERT && common.assert(this.m_count >= 3);\n\n    const center = Vec2.zero();\n    let area = 0.0;\n    let I = 0.0;\n\n    // s is the reference point for forming triangles.\n    // It's location doesn't change the result (except for rounding error).\n    const s = Vec2.zero();\n\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < this.m_count; ++i) {\n      s.add(this.m_vertices[i]);\n    }\n    s.mul(1.0 / this.m_count);\n\n    const k_inv3 = 1.0 / 3.0;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // Triangle vertices.\n      const e1 = Vec2.sub(this.m_vertices[i], s);\n      const e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2 .sub(this.m_vertices[0], s);\n\n      const D = Vec2.crossVec2Vec2(e1, e2);\n\n      const triangleArea = 0.5 * D;\n      area += triangleArea;\n\n      // Area weighted centroid\n      center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);\n\n      const ex1 = e1.x;\n      const ey1 = e1.y;\n      const ex2 = e2.x;\n      const ey2 = e2.y;\n\n      const intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n      const inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n\n      I += (0.25 * k_inv3 * D) * (intx2 + inty2);\n    }\n\n    // Total mass\n    massData.mass = density * area;\n\n    // Center of mass\n    _ASSERT && common.assert(area > Math.EPSILON);\n    center.mul(1.0 / area);\n    massData.center.setCombine(1, center, 1, s);\n\n    // Inertia tensor relative to the local origin (point s).\n    massData.I = density * I;\n\n    // Shift to center of mass then to original body origin.\n    massData.I += massData.mass * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));\n  }\n\n  /**\n   * Validate convexity. This is a very time consuming operation.\n   * @returns true if valid\n   */\n  validate(): boolean {\n    for (let i = 0; i < this.m_count; ++i) {\n      const i1 = i;\n      const i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n      const p = this.m_vertices[i1];\n      const e = Vec2.sub(this.m_vertices[i2], p);\n\n      for (let j = 0; j < this.m_count; ++j) {\n        if (j == i1 || j == i2) {\n          continue;\n        }\n\n        const v = Vec2.sub(this.m_vertices[j], p);\n        const c = Vec2.crossVec2Vec2(e, v);\n        if (c < 0.0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices = this.m_vertices;\n    proxy.m_count = this.m_count;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nfunction ComputeCentroid(vs: Vec2[], count: number): Vec2 {\n  _ASSERT && common.assert(count >= 3);\n\n  const c = Vec2.zero();\n  let area = 0.0;\n\n  // pRef is the reference point for forming triangles.\n  // It's location doesn't change the result (except for rounding error).\n  const pRef = Vec2.zero();\n  if (false) {\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < count; ++i) {\n      pRef.add(vs[i]);\n    }\n    pRef.mul(1.0 / count);\n  }\n\n  const inv3 = 1.0 / 3.0;\n\n  for (let i = 0; i < count; ++i) {\n    // Triangle vertices.\n    const p1 = pRef;\n    const p2 = vs[i];\n    const p3 = i + 1 < count ? vs[i + 1] : vs[0];\n\n    const e1 = Vec2.sub(p2, p1);\n    const e2 = Vec2.sub(p3, p1);\n\n    const D = Vec2.crossVec2Vec2(e1, e2);\n\n    const triangleArea = 0.5 * D;\n    area += triangleArea;\n\n    // Area weighted centroid\n    c.addMul(triangleArea * inv3, p1);\n    c.addMul(triangleArea * inv3, p2);\n    c.addMul(triangleArea * inv3, p3);\n  }\n\n  // Centroid\n  _ASSERT && common.assert(area > Math.EPSILON);\n  c.mul(1.0 / area);\n  return c;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type Vec2 from '../../common/Vec2';\nimport PolygonShape from './PolygonShape';\n\n/**\n * A rectangle polygon which extend PolygonShape.\n */\nexport default class BoxShape extends PolygonShape {\n  static TYPE = 'polygon' as const;\n\n  constructor(hx: number, hy: number, center?: Vec2, angle?: number) {\n    // @ts-ignore\n    if (!(this instanceof BoxShape)) {\n      return new BoxShape(hx, hy, center, angle);\n    }\n\n    super();\n\n    this._setAsBox(hx, hy, center, angle);\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport Math from '../../common/Math';\nimport Rot from '../../common/Rot';\nimport Vec2 from '../../common/Vec2';\nimport Shape from '../Shape';\nimport AABB, { RayCastInput, RayCastOutput } from '../AABB';\nimport Transform from '../../common/Transform';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport default class CircleShape extends Shape {\n  static TYPE = 'circle' as const;\n\n  m_p: Vec2;\n\n  constructor(position: Vec2, radius?: number);\n  constructor(radius?: number);\n  // tslint:disable-next-line:typedef\n  constructor(a, b?) {\n    // @ts-ignore\n    if (!(this instanceof CircleShape)) {\n      return new CircleShape(a, b);\n    }\n\n    super();\n\n    this.m_type = CircleShape.TYPE;\n    this.m_p = Vec2.zero();\n    this.m_radius = 1;\n\n    if (typeof a === 'object' && Vec2.isValid(a)) {\n      this.m_p.setVec2(a);\n\n      if (typeof b === 'number') {\n        this.m_radius = b;\n      }\n\n    } else if (typeof a === 'number') {\n      this.m_radius = a;\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      p: this.m_p,\n      radius: this.m_radius,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): CircleShape {\n    return new CircleShape(data.p, data.radius);\n  }\n\n  // TODO: already defined in Shape\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getCenter(): Vec2 {\n    return this.m_p;\n  }\n\n  getVertex(index: 0): Vec2 {\n    _ASSERT && common.assert(index == 0);\n    return this.m_p;\n  }\n\n  /**\n   * @internal\n   * @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): CircleShape {\n    const clone = new CircleShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_p = this.m_p.clone();\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: Transform, p: Vec2): boolean {\n    const center = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    const d = Vec2.sub(p, center);\n    return Vec2.dot(d, d) <= this.m_radius * this.m_radius;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n    // From Section 3.1.2\n    // x = s + a * r\n    // norm(x) = radius\n\n    const position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    const s = Vec2.sub(input.p1, position);\n    const b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n\n    // Solve quadratic equation.\n    const r = Vec2.sub(input.p2, input.p1);\n    const c = Vec2.dot(s, r);\n    const rr = Vec2.dot(r, r);\n    const sigma = c * c - rr * b;\n\n    // Check for negative discriminant and short segment.\n    if (sigma < 0.0 || rr < Math.EPSILON) {\n      return false;\n    }\n\n    // Find the point of intersection of the line with the circle.\n    let a = -(c + Math.sqrt(sigma));\n\n    // Is the intersection point on the segment?\n    if (0.0 <= a && a <= input.maxFraction * rr) {\n      a /= rr;\n      output.fraction = a;\n      output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n      output.normal.normalize();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABB, xf: Transform, childIndex: number): void {\n    const p = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    aabb.lowerBound.setNum(p.x - this.m_radius, p.y - this.m_radius);\n    aabb.upperBound.setNum(p.x + this.m_radius, p.y + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    massData.mass = density * Math.PI * this.m_radius * this.m_radius;\n    massData.center = this.m_p;\n    // inertia about the local origin\n    massData.I = massData.mass\n        * (0.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices.push(this.m_p);\n    proxy.m_count = 1;\n    proxy.m_radius = this.m_radius;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. A value of 0 disables softness.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * Distance length.\n   */\n  length?: number;\n}\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointDef extends JointDef, DistanceJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0\n};\n\n/**\n * A distance joint constrains two points on two bodies to remain at a fixed\n * distance from each other. You can view this as a massless, rigid rod.\n *\n * @param anchorA Anchor A in global coordination.\n * @param anchorB Anchor B in global coordination.\n */\nexport default class DistanceJoint extends Joint {\n  static TYPE = 'distance-joint' as const;\n\n  // Solver shared\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_length: number;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_gamma: number;\n  /** @internal */ m_bias: number;\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: DistanceJointDef);\n  constructor(def: DistanceJointOpt, bodyA: Body, bodyB: Body, anchorA: Vec2, anchorB: Vec2);\n  constructor(def: DistanceJointDef, bodyA?: Body, bodyB?: Body, anchorA?: Vec2, anchorB?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof DistanceJoint)) {\n      return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n    }\n\n    // order of constructor arguments is changed in v0.2\n    if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {\n      const temp = bodyB;\n      bodyB = anchorA;\n      anchorA = temp;\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = DistanceJoint.TYPE;\n\n    // Solver shared\n    this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n    this.m_length = Math.isFinite(def.length) ? def.length :\n      Vec2.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n    this.m_impulse = 0.0;\n    this.m_gamma = 0.0;\n    this.m_bias = 0.0;\n\n    // 1-D constrained system\n    // m (v2 - v1) = lambda\n    // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n    // x2 = x1 + h * v2\n\n    // 1-D mass-damper-spring system\n    // m (v2 - v1) + h * d * v2 + h * k *\n\n    // C = norm(p2 - p1) - L\n    // u = (p2 - p1) / norm(p2 - p1)\n    // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n    // J = [-u -cross(r1, u) u cross(r2, u)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      length: this.m_length,\n\n      impulse: this.m_impulse,\n      gamma: this.m_gamma,\n      bias: this.m_bias,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): DistanceJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new DistanceJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    length?: number,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.length > 0) {\n      this.m_length = +def.length;\n    } else if (def.length < 0) { // don't change length\n    } else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n      this.m_length = Vec2.distance(\n          this.m_bodyA.getWorldPoint(this.m_localAnchorA),\n          this.m_bodyB.getWorldPoint(this.m_localAnchorB)\n      );\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the natural length. Manipulating the length can lead to non-physical\n   * behavior when the frequency is zero.\n   */\n  setLength(length: number): void {\n    this.m_length = length;\n  }\n\n  /**\n   * Get the natural length.\n   */\n  getLength(): number {\n    return this.m_length;\n  }\n\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n\n    // Handle singularity.\n    const length = this.m_u.length();\n    if (length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / length);\n    } else {\n      this.m_u.setNum(0.0, 0.0);\n    }\n\n    const crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n    const crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n    let invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB\n        + this.m_invIB * crBu * crBu;\n\n    // Compute the effective mass matrix.\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C = length - this.m_length;\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n      // Damping coefficient\n      const d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n\n      // Spring stiffness\n      const k = this.m_mass * omega * omega;\n\n      // magic formulas\n      const h = step.dt;\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invMass += this.m_gamma;\n      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n    } else {\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n    const Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n\n    const impulse = -this.m_mass\n        * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n    this.m_impulse += impulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u);\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    if (this.m_frequencyHz > 0.0) {\n      // There is no position correction for soft distance constraints.\n      return true;\n    }\n\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n\n    const length = u.normalize();\n    let C = length - this.m_length;\n    C = Math\n        .clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C;\n    const P = Vec2.mulNumVec2(impulse, u);\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport options from '../../util/options';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Mat22 from '../../common/Mat22';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointOpt extends JointOpt {\n  /**\n   * The maximum friction force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum friction torque in N-m.\n   */\n  maxTorque?: number;\n}\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointDef extends JointDef, FrictionJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  maxTorque : 0.0,\n};\n\n/**\n * Friction joint. This is used for top-down friction. It provides 2D\n * translational friction and angular friction.\n *\n * @param anchor Anchor in global coordination.\n */\nexport default class FrictionJoint extends Joint {\n  static TYPE = 'friction-joint' as const;\n\n  /** @internal */ m_type: 'friction-joint';\n\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  // Solver shared\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: FrictionJointDef);\n  constructor(def: FrictionJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: FrictionJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof FrictionJoint)) {\n      return new FrictionJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = FrictionJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n\n    // Solver shared\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): FrictionJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new FrictionJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && common.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && common.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y\n        * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x\n        * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt; // float\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA; // float\n      let impulse = -this.m_angularMass * Cdot; // float\n\n      const oldImpulse = this.m_angularImpulse; // float\n      const maxImpulse = h * this.m_maxTorque; // float\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.sub(Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA,\n          Vec2.crossNumVec2(wA, this.m_rA))); // Vec2\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2\n      const oldImpulse = this.m_linearImpulse; // Vec2\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce; // float\n\n      if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n        this.m_linearImpulse.normalize();\n        this.m_linearImpulse.mul(maxImpulse);\n      }\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../util/common';\nimport Vec2 from './Vec2';\nimport Vec3 from './Vec3';\n\n\nconst _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 3-by-3 matrix. Stored in column-major order.\n */\nexport default class Mat33 {\n  ex: Vec3;\n  ey: Vec3;\n  ez: Vec3;\n\n  constructor(a: Vec3, b: Vec3, c: Vec3);\n  constructor();\n  constructor(a?: Vec3, b?: Vec3, c?: Vec3) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec3.clone(a);\n      this.ey = Vec3.clone(b);\n      this.ez = Vec3.clone(c);\n    } else {\n      this.ex = Vec3.zero();\n      this.ey = Vec3.zero();\n      this.ez = Vec3.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n  }\n\n  static assert(o: any): void {\n    if (!_ASSERT) return;\n    if (!Mat33.isValid(o)) {\n      _DEBUG && common.debug(o);\n      throw new Error('Invalid Mat33!');\n    }\n  }\n\n  /**\n   * Set this matrix to all zeros.\n   */\n  setZero(): Mat33 {\n    this.ex.setZero();\n    this.ey.setZero();\n    this.ez.setZero();\n    return this;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve33(v: Vec3): Vec3 {\n    let det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = new Vec3();\n    r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));\n    r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));\n    r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));\n    return r;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n   * equation.\n   */\n  solve22(v: Vec2): Vec2 {\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a21 = this.ex.y;\n    const a22 = this.ey.y;\n    let det = a11 * a22 - a12 * a21;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = Vec2.zero();\n    r.x = det * (a22 * v.x - a12 * v.y);\n    r.y = det * (a11 * v.y - a21 * v.x);\n    return r;\n  }\n\n  /**\n   * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n   * singular.\n   */\n  getInverse22(M: Mat33): void {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    M.ex.x = det * d;\n    M.ey.x = -det * b;\n    M.ex.z = 0.0;\n    M.ex.y = -det * c;\n    M.ey.y = det * a;\n    M.ey.z = 0.0;\n    M.ez.x = 0.0;\n    M.ez.y = 0.0;\n    M.ez.z = 0.0;\n  }\n\n  /**\n   * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n   * if singular.\n   */\n  getSymInverse33(M: Mat33): void {\n    let det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a13 = this.ez.x;\n    const a22 = this.ey.y;\n    const a23 = this.ez.y;\n    const a33 = this.ez.z;\n\n    M.ex.x = det * (a22 * a33 - a23 * a23);\n    M.ex.y = det * (a13 * a23 - a12 * a33);\n    M.ex.z = det * (a12 * a23 - a13 * a22);\n\n    M.ey.x = M.ex.y;\n    M.ey.y = det * (a11 * a33 - a13 * a13);\n    M.ey.z = det * (a13 * a12 - a11 * a23);\n\n    M.ez.x = M.ex.z;\n    M.ez.y = M.ey.z;\n    M.ez.z = det * (a11 * a22 - a12 * a12);\n  }\n\n  /**\n   * Multiply a matrix times a vector.\n   */\n  static mul(a: Mat33, b: Vec2): Vec2;\n  static mul(a: Mat33, b: Vec3): Vec3;\n  // tslint:disable-next-line:typedef\n  static mul(a, b) {\n    _ASSERT && Mat33.assert(a);\n    if (b && 'z' in b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec3.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n      const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n      const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n      return new Vec3(x, y, z);\n\n    } else if (b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec2.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y;\n      const y = a.ex.y * b.x + a.ey.y * b.y;\n      return Vec2.neo(x, y);\n    }\n\n    _ASSERT && common.assert(false);\n  }\n\n  static mulVec3(a: Mat33, b: Vec3): Vec3 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec3.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n    const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n    const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n    return new Vec3(x, y, z);\n  }\n\n  static mulVec2(a: Mat33, b: Vec2): Vec2 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y;\n    const y = a.ex.y * b.x + a.ey.y * b.y;\n    return Vec2.neo(x, y);\n  }\n\n  static add(a: Mat33, b: Mat33): Mat33 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Mat33.assert(b);\n    return new Mat33(\n      Vec3.add(a.ex, b.ex),\n      Vec3.add(a.ey, b.ey),\n      Vec3.add(a.ez, b.ez)\n    );\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Vec3 from '../../common/Vec3';\nimport Mat22 from '../../common/Mat22';\nimport Mat33 from '../../common/Mat33';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointOpt extends JointOpt {\n  /**\n   * The lower angle for the joint limit (radians).\n   */\n  lowerAngle?: number;\n  /**\n   * The upper angle for the joint limit (radians).\n   */\n  upperAngle?: number;\n  /**\n   * The maximum motor torque used to achieve the desired motor speed. Usually\n   * in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed. Usually in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * A flag to enable joint limits.\n   */\n  enableLimit?: boolean;\n  /**\n   * A flag to enable the joint motor.\n   */\n  enableMotor?: boolean;\n}\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointDef extends JointDef, RevoluteJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  lowerAngle : 0.0,\n  upperAngle : 0.0,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  enableLimit : false,\n  enableMotor : false\n};\n\n/**\n * A revolute joint constrains two bodies to share a common point while they are\n * free to rotate about the point. The relative rotation about the shared point\n * is the joint angle. You can limit the relative rotation with a joint limit\n * that specifies a lower and upper angle. You can use a motor to drive the\n * relative rotation about the shared point. A maximum motor torque is provided\n * so that infinite forces are not generated.\n */\nexport default class RevoluteJoint extends Joint {\n  static TYPE = 'revolute-joint' as const;\n\n  /** @internal */ m_type: 'revolute-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerAngle: number;\n  /** @internal */ m_upperAngle: number;\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  // effective mass for point-to-point constraint.\n  /** @internal */ m_mass: Mat33 = new Mat33();\n  // effective mass for motor/limit angular constraint.\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_limitState: number = inactiveLimit; // TODO enum\n\n  constructor(def: RevoluteJointDef);\n  constructor(def: RevoluteJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  // @ts-ignore\n  constructor(def: RevoluteJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof RevoluteJoint)) {\n      return new RevoluteJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RevoluteJoint.TYPE;\n\n    this.m_localAnchorA =  Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB =  Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerAngle = def.lowerAngle;\n    this.m_upperAngle = def.upperAngle;\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Motor constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerAngle: this.m_lowerAngle,\n      upperAngle: this.m_upperAngle,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any):RevoluteJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RevoluteJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle in radians.\n   */\n  getJointAngle(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle speed in radians per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_angularVelocity - bA.m_angularVelocity;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step. Unit is N*m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set the motor speed in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set the maximum motor torque, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit in radians.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerAngle;\n  }\n\n  /**\n   * Get the upper joint limit in radians.\n   */\n  getUpperLimit(): number {\n    return this.m_upperAngle;\n  }\n\n  /**\n   * Set the joint limits in radians.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && common.assert(lower <= upper);\n\n    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_impulse.z = 0.0;\n      this.m_lowerAngle = lower;\n      this.m_upperAngle = upper;\n    }\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force given the inverse time step. Unit is N.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque due to the joint limit given the inverse time step.\n   * Unit is N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y\n        * this.m_rB.y * iB;\n    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y\n        * this.m_rB.x * iB;\n    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    this.m_mass.ex.y = this.m_mass.ey.x;\n    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x\n        * this.m_rB.x * iB;\n    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    this.m_mass.ex.z = this.m_mass.ez.x;\n    this.m_mass.ey.z = this.m_mass.ez.y;\n    this.m_mass.ez.z = iA + iB;\n\n    this.m_motorMass = iA + iB;\n    if (this.m_motorMass > 0.0) {\n      this.m_motorMass = 1.0 / this.m_motorMass;\n    }\n\n    if (this.m_enableMotor == false || fixedRotation) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (this.m_enableLimit && fixedRotation == false) {\n      const jointAngle = aB - aA - this.m_referenceAngle; // float\n\n      if (Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointAngle <= this.m_lowerAngle) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atLowerLimit;\n\n      } else if (jointAngle >= this.m_upperAngle) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = atUpperLimit;\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const fixedRotation = (iA + iB === 0.0); // bool\n\n    // Solve motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits\n        && fixedRotation == false) {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3\n\n      if (this.m_limitState == equalLimits) {\n        this.m_impulse.add(impulse);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse < 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n\n      } else if (this.m_limitState == atUpperLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z; // float\n\n        if (newImpulse > 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2\n          const reduced = this.m_mass.solve22(rhs); // Vec2\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n\n    } else {\n      // Solve point-to-point constraint\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2\n\n      this.m_impulse.x += impulse.x;\n      this.m_impulse.y += impulse.y;\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    let angularError = 0.0; // float\n    let positionError = 0.0; // float\n\n    const fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool\n\n    // Solve angular limit constraint.\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit\n        && fixedRotation == false) {\n      const angle = aB - aA - this.m_referenceAngle; // float\n      let limitImpulse = 0.0; // float\n\n      if (this.m_limitState == equalLimits) {\n        // Prevent large angular corrections\n        const C = Math.clamp(angle - this.m_lowerAngle,\n            -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float\n        limitImpulse = -this.m_motorMass * C;\n        angularError = Math.abs(C);\n\n      } else if (this.m_limitState == atLowerLimit) {\n        let C = angle - this.m_lowerAngle; // float\n        angularError = -C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection,\n            0.0);\n        limitImpulse = -this.m_motorMass * C;\n\n      } else if (this.m_limitState == atUpperLimit) {\n        let C = angle - this.m_upperAngle; // float\n        angularError = C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = Math.clamp(C - Settings.angularSlop, 0.0,\n            Settings.maxAngularCorrection);\n        limitImpulse = -this.m_motorMass * C;\n      }\n\n      aA -= this.m_invIA * limitImpulse;\n      aB += this.m_invIB * limitImpulse;\n    }\n\n    // Solve point-to-point constraint.\n    {\n      qA.setAngle(aA);\n      qB.setAngle(aB);\n      const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n      const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n\n      const C = Vec2.zero();\n      C.addCombine(1, cB, 1, rB);\n      C.subCombine(1, cA, 1, rA);\n      positionError = C.length();\n\n      const mA = this.m_invMassA;\n      const mB = this.m_invMassB; // float\n      const iA = this.m_invIA;\n      const iB = this.m_invIB; // float\n\n      const K = new Mat22();\n      K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n      K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n\n      const impulse = Vec2.neg(K.solve(C)); // Vec2\n\n      cA.subMul(mA, impulse);\n      aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n\n      cB.addMul(mB, impulse);\n      aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n    }\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Vec3 from '../../common/Vec3';\nimport Mat22 from '../../common/Mat22';\nimport Mat33 from '../../common/Mat33';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit?: boolean;\n  /**\n   * The lower translation limit, usually in meters.\n   */\n  lowerTranslation?: number;\n  /**\n   * The upper translation limit, usually in meters.\n   */\n  upperTranslation?: number;\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorForce?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n}\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointDef extends JointDef, PrismaticJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation unit axis in bodyA.\n   */\n  localAxisA: Vec2;\n  /**\n   * referenceAngle The constrained angle between the bodies:\n   * bodyB_angle - bodyA_angle.\n   */\n  referenceAngle: number;\n}\n\nconst DEFAULTS = {\n  enableLimit : false,\n  lowerTranslation : 0.0,\n  upperTranslation : 0.0,\n  enableMotor : false,\n  maxMotorForce : 0.0,\n  motorSpeed : 0.0\n};\n\n/**\n * A prismatic joint. This joint provides one degree of freedom: translation\n * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n * joint limit to restrict the range of motion and a joint motor to drive the\n * motion or to model joint friction.\n */\nexport default class PrismaticJoint extends Joint {\n  static TYPE = 'prismatic-joint' as const;\n\n  /** @internal */ m_type: 'prismatic-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerTranslation: number;\n  /** @internal */ m_upperTranslation: number;\n  /** @internal */ m_maxMotorForce: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n  /** @internal */ m_limitState: number; // TODO enum\n  /** @internal */ m_axis: Vec2;\n  /** @internal */ m_perp: Vec2;\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_s1: number;\n  /** @internal */ m_s2: number;\n  /** @internal */ m_a1: number;\n  /** @internal */ m_a2: number;\n  /** @internal */ m_K: Mat33;\n\n  constructor(def: PrismaticJointDef);\n  constructor(def: PrismaticJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  constructor(def: PrismaticJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof PrismaticJoint)) {\n      return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PrismaticJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n    this.m_localXAxisA.normalize();\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerTranslation = def.lowerTranslation;\n    this.m_upperTranslation = def.upperTranslation;\n    this.m_maxMotorForce = def.maxMotorForce;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n    this.m_limitState = inactiveLimit;\n\n    this.m_axis = Vec2.zero();\n    this.m_perp = Vec2.zero();\n\n    this.m_K = new Mat33();\n\n    // Linear constraint (point-to-line)\n    // d = p2 - p1 = x2 + r2 - x1 - r1\n    // C = dot(perp, d)\n    // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n    // cross(w1, r1))\n    // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n    // dot(cross(r2, perp), v2)\n    // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n    //\n    // Angular constraint\n    // C = a2 - a1 + a_initial\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    //\n    // K = J * invM * JT\n    //\n    // J = [-a -s1 a s2]\n    // [0 -1 0 1]\n    // a = perp\n    // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n    // s2 = cross(r2, a) = cross(p2 - x2, a)\n\n    // Motor/Limit linear constraint\n    // C = dot(ax1, d)\n    // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n    // dot(cross(r2, ax1), v2)\n    // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n\n    // Block Solver\n    // We develop a block solver that includes the joint limit. This makes the\n    // limit stiff (inelastic) even\n    // when the mass has poor distribution (leading to large torques about the\n    // joint anchor points).\n    //\n    // The Jacobian has 3 rows:\n    // J = [-uT -s1 uT s2] // linear\n    // [0 -1 0 1] // angular\n    // [-vT -a1 vT a2] // limit\n    //\n    // u = perp\n    // v = axis\n    // s1 = cross(d + r1, u), s2 = cross(r2, u)\n    // a1 = cross(d + r1, v), a2 = cross(r2, v)\n\n    // M * (v2 - v1) = JT * df\n    // J * v2 = bias\n    //\n    // v2 = v1 + invM * JT * df\n    // J * (v1 + invM * JT * df) = bias\n    // K * df = bias - J * v1 = -Cdot\n    // K = J * invM * JT\n    // Cdot = J * v1 - bias\n    //\n    // Now solve for f2.\n    // df = f2 - f1\n    // K * (f2 - f1) = -Cdot\n    // f2 = invK * (-Cdot) + f1\n    //\n    // Clamp accumulated limit impulse.\n    // lower: f2(3) = max(f2(3), 0)\n    // upper: f2(3) = min(f2(3), 0)\n    //\n    // Solve for correct f2(1:2)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n    // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n    // K(1:2,1:2) * f1(1:2)\n    // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n    // f1(1:2)\n    //\n    // Now compute impulse to be applied:\n    // df = f2 - f1\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerTranslation: this.m_lowerTranslation,\n      upperTranslation: this.m_upperTranslation,\n      maxMotorForce: this.m_maxMotorForce,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PrismaticJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.localAxisA = Vec2.clone(data.localAxisA);\n    const joint = new PrismaticJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const d = Vec2.sub(pB, pA);\n    const axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n\n    const translation = Vec2.dot(d, axis);\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2\n    const rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2\n    const p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2\n    const p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2\n    const d = Vec2.sub(p2, p1); // Vec2\n    const axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2\n\n    const vA = bA.m_linearVelocity; // Vec2\n    const vB = bB.m_linearVelocity; // Vec2\n    const wA = bA.m_angularVelocity; // float\n    const wB = bB.m_angularVelocity; // float\n\n    const speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis))\n        + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA))); // float\n    return speed;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit, usually in meters.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerTranslation;\n  }\n\n  /**\n   * Get the upper joint limit, usually in meters.\n   */\n  getUpperLimit(): number {\n    return this.m_upperTranslation;\n  }\n\n  /**\n   * Set the joint limits, usually in meters.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && common.assert(lower <= upper);\n    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_lowerTranslation = lower;\n      this.m_upperTranslation = upper;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in meters per second.\n   */\n  setMotorSpeed(speed: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Set the maximum motor force, usually in N.\n   */\n  setMaxMotorForce(force: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorForce = force;\n  }\n\n  getMaxMotorForce(): number {\n    return this.m_maxMotorForce;\n  }\n\n  /**\n   * Get the motor speed, usually in meters per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Get the current motor force given the inverse time step, usually in N.\n   */\n  getMotorForce(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.y;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute motor Jacobian and effective mass.\n    {\n      this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n      this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n\n      this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2\n          * this.m_a2;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    }\n\n    // Prismatic constraint.\n    {\n      this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n\n      this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n      this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n\n      const s1test = Vec2.crossVec2Vec2(rA, this.m_perp);\n\n      const k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n      const k12 = iA * this.m_s1 + iB * this.m_s2;\n      const k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n      let k22 = iA + iB;\n      if (k22 == 0.0) {\n        // For bodies with fixed rotation.\n        k22 = 1.0;\n      }\n      const k23 = iA * this.m_a1 + iB * this.m_a2;\n      const k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n\n      this.m_K.ex.set(k11, k12, k13);\n      this.m_K.ey.set(k12, k22, k23);\n      this.m_K.ez.set(k13, k23, k33);\n    }\n\n    // Compute motor and limit terms.\n    if (this.m_enableLimit) {\n\n      const jointTranslation = Vec2.dot(this.m_axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {\n        this.m_limitState = equalLimits;\n\n      } else if (jointTranslation <= this.m_lowerTranslation) {\n        if (this.m_limitState != atLowerLimit) {\n          this.m_limitState = atLowerLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else if (jointTranslation >= this.m_upperTranslation) {\n        if (this.m_limitState != atUpperLimit) {\n          this.m_limitState = atUpperLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else {\n        this.m_limitState = inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = inactiveLimit;\n      this.m_impulse.z = 0.0;\n    }\n\n    if (this.m_enableMotor == false) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse\n          + this.m_impulse.z, this.m_axis);\n      const LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n      const LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Solve linear motor constraint.\n    if (this.m_enableMotor && this.m_limitState != equalLimits) {\n      const Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB\n          - this.m_a1 * wA;\n      let impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n      const oldImpulse = this.m_motorImpulse;\n      const maxImpulse = step.dt * this.m_maxMotorForce;\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_axis);\n      const LA = impulse * this.m_a1;\n      const LB = impulse * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    const Cdot1 = Vec2.zero();\n    Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n    Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n    Cdot1.y = wB - wA;\n\n    if (this.m_enableLimit && this.m_limitState != inactiveLimit) {\n      // Solve prismatic and limit constraint in block form.\n      let Cdot2 = 0;\n      Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n      Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const f1 = Vec3.clone(this.m_impulse);\n      let df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3\n      this.m_impulse.add(df);\n\n      if (this.m_limitState == atLowerLimit) {\n        this.m_impulse.z = Math.max(this.m_impulse.z, 0.0);\n      } else if (this.m_limitState == atUpperLimit) {\n        this.m_impulse.z = Math.min(this.m_impulse.z, 0.0);\n      }\n\n      // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n      // f1(1:2)\n      const b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2\n      const f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2\n      this.m_impulse.x = f2r.x;\n      this.m_impulse.y = f2r.y;\n\n      df = Vec3.sub(this.m_impulse, f1);\n\n      const P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2\n      const LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float\n      const LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      // Limit is inactive, just solve the prismatic constraint in block form.\n      const df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2\n      this.m_impulse.x += df.x;\n      this.m_impulse.y += df.y;\n\n      const P = Vec2.mulNumVec2(df.x, this.m_perp); // Vec2\n      const LA = df.x * this.m_s1 + df.y; // float\n      const LB = df.x * this.m_s2 + df.y; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute fresh Jacobians\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2\n    const d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2\n\n    const axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2\n    const a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis); // float\n    const a2 = Vec2.crossVec2Vec2(rB, axis); // float\n    const perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2\n\n    const s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp); // float\n    const s2 = Vec2.crossVec2Vec2(rB, perp); // float\n\n    let impulse = new Vec3();\n    const C1 = Vec2.zero(); // Vec2\n    C1.x = Vec2.dot(perp, d);\n    C1.y = aB - aA - this.m_referenceAngle;\n\n    let linearError = Math.abs(C1.x); // float\n    const angularError = Math.abs(C1.y); // float\n\n    const linearSlop = Settings.linearSlop;\n    const maxLinearCorrection = Settings.maxLinearCorrection;\n\n    let active = false; // bool\n    let C2 = 0.0; // float\n    if (this.m_enableLimit) {\n\n      const translation = Vec2.dot(axis, d); // float\n      if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n        // Prevent large angular corrections\n        C2 = Math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n        linearError = Math.max(linearError, Math.abs(translation));\n        active = true;\n\n      } else if (translation <= this.m_lowerTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_lowerTranslation + linearSlop,\n            -maxLinearCorrection, 0.0);\n        linearError = Math\n            .max(linearError, this.m_lowerTranslation - translation);\n        active = true;\n\n      } else if (translation >= this.m_upperTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = Math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0,\n            maxLinearCorrection);\n        linearError = Math\n            .max(linearError, translation - this.m_upperTranslation);\n        active = true;\n      }\n    }\n\n    if (active) {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      const k13 = iA * s1 * a1 + iB * s2 * a2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        // For fixed rotation\n        k22 = 1.0;\n      }\n      const k23 = iA * a1 + iB * a2; // float\n      const k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float\n\n      const K = new Mat33();\n      K.ex.set(k11, k12, k13);\n      K.ey.set(k12, k22, k23);\n      K.ez.set(k13, k23, k33);\n\n      const C = new Vec3();\n      C.x = C1.x;\n      C.y = C1.y;\n      C.z = C2;\n\n      impulse = K.solve33(Vec3.neg(C));\n    } else {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float\n      const k12 = iA * s1 + iB * s2; // float\n      let k22 = iA + iB; // float\n      if (k22 == 0.0) {\n        k22 = 1.0;\n      }\n\n      const K = new Mat22();\n      K.ex.setNum(k11, k12);\n      K.ey.setNum(k12, k22);\n\n      const impulse1 = K.solve(Vec2.neg(C1)); // Vec2\n      impulse.x = impulse1.x;\n      impulse.y = impulse1.y;\n      impulse.z = 0.0;\n    }\n\n    const P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2\n    const LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float\n    const LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float\n\n    cA.subMul(mA, P);\n    aA -= iA * LA;\n    cB.addMul(mB, P);\n    aB += iB * LB;\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport RevoluteJoint from './RevoluteJoint';\nimport PrismaticJoint from './PrismaticJoint';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Gear joint definition.\n */\nexport interface GearJointOpt extends JointOpt {\n  /**\n   * The gear ratio. See {@link GearJoint} for explanation.\n   */\n  ratio?: number;\n}\n/**\n * Gear joint definition.\n */\nexport interface GearJointDef extends JointDef, GearJointOpt {\n  /**\n   * The first revolute/prismatic joint attached to the gear joint.\n   */\n  joint1: RevoluteJoint | PrismaticJoint;\n  /**\n   * The second prismatic/revolute joint attached to the gear joint.\n   */\n  joint2: RevoluteJoint | PrismaticJoint;\n}\n\nconst DEFAULTS = {\n  ratio : 1.0\n};\n\n/**\n * A gear joint is used to connect two joints together. Either joint can be a\n * revolute or prismatic joint. You specify a gear ratio to bind the motions\n * together: coordinate1 + ratio * coordinate2 = constant\n *\n * The ratio can be negative or positive. If one joint is a revolute joint and\n * the other joint is a prismatic joint, then the ratio will have units of\n * length or units of 1/length. Warning: You have to manually destroy the gear\n * joint if joint1 or joint2 is destroyed.\n *\n * This definition requires two existing revolute or prismatic joints (any\n * combination will work).\n */\nexport default class GearJoint extends Joint {\n  static TYPE = 'gear-joint' as const;\n\n  /** @internal */ m_type: 'gear-joint';\n  /** @internal */ m_joint1: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_joint2: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_type1: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_type2: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_bodyC: Body;\n  /** @internal */ m_localAnchorC: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_referenceAngleA: number;\n  /** @internal */ m_localAxisC: Vec2;\n  /** @internal */ m_bodyD: Body;\n  /** @internal */ m_localAnchorD: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngleB: number;\n  /** @internal */ m_localAxisD: Vec2;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_lcA: Vec2;\n  /** @internal */ m_lcB: Vec2;\n  /** @internal */ m_lcC: Vec2;\n  /** @internal */ m_lcD: Vec2;\n  /** @internal */ m_mA: number;\n  /** @internal */ m_mB: number;\n  /** @internal */ m_mC: number;\n  /** @internal */ m_mD: number;\n  /** @internal */ m_iA: number;\n  /** @internal */ m_iB: number;\n  /** @internal */ m_iC: number;\n  /** @internal */ m_iD: number;\n  /** @internal */ m_JvAC: Vec2;\n  /** @internal */ m_JvBD: Vec2;\n  /** @internal */ m_JwA: number;\n  /** @internal */ m_JwB: number;\n  /** @internal */ m_JwC: number;\n  /** @internal */ m_JwD: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: GearJointDef);\n  constructor(def: GearJointOpt, bodyA: Body, bodyB: Body, joint1: RevoluteJoint | PrismaticJoint, joint2: RevoluteJoint | PrismaticJoint, ratio?: number);\n  constructor(def: GearJointDef, bodyA?: Body, bodyB?: Body, joint1?: RevoluteJoint | PrismaticJoint, joint2?: RevoluteJoint | PrismaticJoint, ratio?: number) {\n    // @ts-ignore\n    if (!(this instanceof GearJoint)) {\n      return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = GearJoint.TYPE;\n\n    _ASSERT && common.assert(joint1.m_type === RevoluteJoint.TYPE\n        || joint1.m_type === PrismaticJoint.TYPE);\n    _ASSERT && common.assert(joint2.m_type === RevoluteJoint.TYPE\n        || joint2.m_type === PrismaticJoint.TYPE);\n\n    this.m_joint1 = joint1 ? joint1 : def.joint1;\n    this.m_joint2 = joint2 ? joint2 : def.joint2;\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    this.m_type1 = this.m_joint1.getType() as 'revolute-joint' | 'prismatic-joint';\n    this.m_type2 = this.m_joint2.getType() as 'revolute-joint' | 'prismatic-joint';\n\n    // joint1 connects body A to body C\n    // joint2 connects body B to body D\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    // TODO_ERIN there might be some problem with the joint edges in Joint.\n\n    this.m_bodyC = this.m_joint1.getBodyA();\n    this.m_bodyA = this.m_joint1.getBodyB();\n\n    // Get geometry of joint1\n    const xfA = this.m_bodyA.m_xf;\n    const aA = this.m_bodyA.m_sweep.a;\n    const xfC = this.m_bodyC.m_xf;\n    const aC = this.m_bodyC.m_sweep.a;\n\n    if (this.m_type1 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint1 as RevoluteJoint;\n      this.m_localAnchorC = revolute.m_localAnchorA;\n      this.m_localAnchorA = revolute.m_localAnchorB;\n      this.m_referenceAngleA = revolute.m_referenceAngle;\n      this.m_localAxisC = Vec2.zero();\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const prismatic = this.m_joint1 as PrismaticJoint;\n      this.m_localAnchorC = prismatic.m_localAnchorA;\n      this.m_localAnchorA = prismatic.m_localAnchorB;\n      this.m_referenceAngleA = prismatic.m_referenceAngle;\n      this.m_localAxisC = prismatic.m_localXAxisA;\n\n      const pC = this.m_localAnchorC;\n      const pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n      coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);\n    }\n\n    this.m_bodyD = this.m_joint2.getBodyA();\n    this.m_bodyB = this.m_joint2.getBodyB();\n\n    // Get geometry of joint2\n    const xfB = this.m_bodyB.m_xf;\n    const aB = this.m_bodyB.m_sweep.a;\n    const xfD = this.m_bodyD.m_xf;\n    const aD = this.m_bodyD.m_sweep.a;\n\n    if (this.m_type2 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint2 as RevoluteJoint;\n      this.m_localAnchorD = revolute.m_localAnchorA;\n      this.m_localAnchorB = revolute.m_localAnchorB;\n      this.m_referenceAngleB = revolute.m_referenceAngle;\n      this.m_localAxisD = Vec2.zero();\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const prismatic = this.m_joint2 as PrismaticJoint;\n      this.m_localAnchorD = prismatic.m_localAnchorA;\n      this.m_localAnchorB = prismatic.m_localAnchorB;\n      this.m_referenceAngleB = prismatic.m_referenceAngle;\n      this.m_localAxisD = prismatic.m_localXAxisA;\n\n      const pD = this.m_localAnchorD;\n      const pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n      coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    this.m_constant = coordinateA + this.m_ratio * coordinateB;\n\n    this.m_impulse = 0.0;\n\n    // Gear Joint:\n    // C0 = (coordinate1 + ratio * coordinate2)_initial\n    // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n    // J = [J1 ratio * J2]\n    // K = J * invM * JT\n    // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n    //\n    // Revolute:\n    // coordinate = rotation\n    // Cdot = angularVelocity\n    // J = [0 0 1]\n    // K = J * invM * JT = invI\n    //\n    // Prismatic:\n    // coordinate = dot(p - pg, ug)\n    // Cdot = dot(v + cross(w, r), ug)\n    // J = [ug cross(r, ug)]\n    // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      joint1: this.m_joint1,\n      joint2: this.m_joint2,\n      ratio: this.m_ratio,\n\n      // _constant: this.m_constant,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): GearJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.joint1 = restore(Joint, data.joint1, world);\n    data.joint2 = restore(Joint, data.joint2, world);\n    const joint = new GearJoint(data);\n    // if (data._constant) joint.m_constant = data._constant;\n    return joint;\n  }\n\n  /**\n   * Get the first joint.\n   */\n  getJoint1(): Joint {\n    return this.m_joint1;\n  }\n\n  /**\n   * Get the second joint.\n   */\n  getJoint2(): Joint {\n    return this.m_joint2;\n  }\n\n  /**\n   * Set the gear ratio.\n   */\n  setRatio(ratio: number): void {\n    _ASSERT && common.assert(Math.isFinite(ratio));\n    this.m_ratio = ratio;\n  }\n\n  /**\n   * Get the gear ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    const L = this.m_impulse * this.m_JwA; // float\n    return inv_dt * L;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n    this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n    this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n    this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n    this.m_mA = this.m_bodyA.m_invMass;\n    this.m_mB = this.m_bodyB.m_invMass;\n    this.m_mC = this.m_bodyC.m_invMass;\n    this.m_mD = this.m_bodyD.m_invMass;\n    this.m_iA = this.m_bodyA.m_invI;\n    this.m_iB = this.m_bodyB.m_invI;\n    this.m_iC = this.m_bodyC.m_invI;\n    this.m_iD = this.m_bodyD.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const aC = this.m_bodyC.c_position.a;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n\n    const aD = this.m_bodyD.c_position.a;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    this.m_mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      this.m_JvAC = Vec2.zero();\n      this.m_JwA = 1.0;\n      this.m_JwC = 1.0;\n      this.m_mass += this.m_iA + this.m_iC;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      this.m_JvAC = u;\n      this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n      this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n      this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      this.m_JvBD = Vec2.zero();\n      this.m_JwB = this.m_ratio;\n      this.m_JwD = this.m_ratio;\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2\n      this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n    }\n\n    // Compute effective mass.\n    this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n\n    if (step.warmStarting) {\n      vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n      wA += this.m_iA * this.m_impulse * this.m_JwA;\n\n      vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n      wB += this.m_iB * this.m_impulse * this.m_JwB;\n\n      vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n      wC -= this.m_iC * this.m_impulse * this.m_JwC;\n\n      vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n      wD -= this.m_iD * this.m_impulse * this.m_JwD;\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    let Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC)\n        + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float\n    Cdot += (this.m_JwA * wA - this.m_JwC * wC)\n        + (this.m_JwB * wB - this.m_JwD * wD);\n\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    vA.addMul(this.m_mA * impulse, this.m_JvAC);\n    wA += this.m_iA * impulse * this.m_JwA;\n    vB.addMul(this.m_mB * impulse, this.m_JvBD);\n    wB += this.m_iB * impulse * this.m_JwB;\n    vC.subMul(this.m_mC * impulse, this.m_JvAC);\n    wC -= this.m_iC * impulse * this.m_JwC;\n    vD.subMul(this.m_mD * impulse, this.m_JvBD);\n    wD -= this.m_iD * impulse * this.m_JwD;\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n    const cC = this.m_bodyC.c_position.c;\n    let aC = this.m_bodyC.c_position.a;\n    const cD = this.m_bodyD.c_position.c;\n    let aD = this.m_bodyD.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    const linearError = 0.0;\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    let JvAC: Vec2;\n    let JvBD: Vec2;\n    let JwA: number;\n    let JwB: number;\n    let JwC: number;\n    let JwD: number;\n    let mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      JvAC = Vec2.zero();\n      JwA = 1.0;\n      JwC = 1.0;\n      mass += this.m_iA + this.m_iC;\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2\n      JvAC = u;\n      JwC = Vec2.crossVec2Vec2(rC, u);\n      JwA = Vec2.crossVec2Vec2(rA, u);\n      mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n\n      const pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2\n      const pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2\n      coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      JvBD = Vec2.zero();\n      JwB = this.m_ratio;\n      JwD = this.m_ratio;\n      mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD);\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n      JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD\n          * JwD * JwD + this.m_iB * JwB * JwB;\n\n      const pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2\n      const pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2\n      coordinateB = Vec2.dot(pB, this.m_localAxisD)\n          - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    const C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float\n\n    let impulse = 0.0; // float\n    if (mass > 0.0) {\n      impulse = -C / mass;\n    }\n\n    cA.addMul(this.m_mA * impulse, JvAC);\n    aA += this.m_iA * impulse * JwA;\n    cB.addMul(this.m_mB * impulse, JvBD);\n    aB += this.m_iB * impulse * JwB;\n    cC.subMul(this.m_mC * impulse, JvAC);\n    aC -= this.m_iC * impulse * JwC;\n    cD.subMul(this.m_mD * impulse, JvBD);\n    aD -= this.m_iD * impulse * JwD;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n    this.m_bodyC.c_position.c.setVec2(cC);\n    this.m_bodyC.c_position.a = aC;\n    this.m_bodyD.c_position.c.setVec2(cD);\n    this.m_bodyD.c_position.a = aD;\n\n    // TODO_ERIN not implemented\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport options from '../../util/options';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Mat22 from '../../common/Mat22';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Motor joint definition.\n */\nexport interface MotorJointOpt extends JointOpt {\n  /**\n   * The bodyB angle minus bodyA angle in radians.\n   */\n  angularOffset?: number;\n  /**\n   * The maximum motor force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum motor torque in N-m.\n   */\n  maxTorque?: number;\n  /**\n   * Position correction factor in the range [0,1].\n   */\n  correctionFactor?: number;\n  /**\n   * Position of bodyB minus the position of bodyA, in bodyA's frame, in meters.\n   */\n  linearOffset?: Vec2;\n}\n/**\n * Motor joint definition.\n */\nexport interface MotorJointDef extends JointDef, MotorJointOpt {\n}\n\nconst DEFAULTS = {\n  maxForce : 1.0,\n  maxTorque : 1.0,\n  correctionFactor : 0.3\n};\n\n/**\n * A motor joint is used to control the relative motion between two bodies. A\n * typical usage is to control the movement of a dynamic body with respect to\n * the ground.\n */\nexport default class MotorJoint extends Joint {\n  static TYPE = 'motor-joint' as const;\n\n  /** @internal */ m_type: 'motor-joint';\n  /** @internal */ m_linearOffset: Vec2;\n  /** @internal */ m_angularOffset: number;\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n  /** @internal */ m_correctionFactor: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_linearError: Vec2;\n  /** @internal */ m_angularError: number;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: MotorJointDef);\n  constructor(def: MotorJointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: MotorJointDef | MotorJointOpt, bodyA?: Body, bodyB?: Body) {\n    // @ts-ignore\n    if (!(this instanceof MotorJoint)) {\n      return new MotorJoint(def, bodyA, bodyB);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MotorJoint.TYPE;\n\n    this.m_linearOffset = Math.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());\n    this.m_angularOffset = Math.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n    this.m_correctionFactor = def.correctionFactor;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n      correctionFactor: this.m_correctionFactor,\n\n      linearOffset: this.m_linearOffset,\n      angularOffset: this.m_angularOffset,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MotorJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new MotorJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {}): void {\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && common.assert(Math.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && common.assert(Math.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Set the position correction factor in the range [0,1].\n   */\n  setCorrectionFactor(factor: number): void {\n    _ASSERT && common.assert(Math.isFinite(factor) && 0.0 <= factor && factor <= 1.0);\n    this.m_correctionFactor = factor;\n  }\n\n  /**\n   * Get the position correction factor in the range [0,1].\n   */\n  getCorrectionFactor(): number {\n    return this.m_correctionFactor;\n  }\n\n  /**\n   * Set/get the target linear offset, in frame A, in meters.\n   */\n  setLinearOffset(linearOffset: Vec2): void {\n    if (linearOffset.x != this.m_linearOffset.x\n        || linearOffset.y != this.m_linearOffset.y) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_linearOffset = linearOffset;\n    }\n  }\n\n  getLinearOffset(): Vec2 {\n    return this.m_linearOffset;\n  }\n\n  /**\n   * Set/get the target angular offset, in radians.\n   */\n  setAngularOffset(angularOffset: number): void {\n    if (angularOffset != this.m_angularOffset) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_angularOffset = angularOffset;\n    }\n  }\n\n  getAngularOffset(): number {\n    return this.m_angularOffset;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getPosition();\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getPosition();\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.neg(this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    this.m_linearError = Vec2.zero();\n    this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n    this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n    this.m_linearError.sub(Rot.mulVec2(qA, this.m_linearOffset));\n\n    this.m_angularError = aB - aA - this.m_angularOffset;\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt;\n    const inv_h = step.inv_dt;\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n      let impulse = -this.m_angularMass * Cdot;\n\n      const oldImpulse = this.m_angularImpulse;\n      const maxImpulse = h * this.m_maxTorque;\n      this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n      const oldImpulse = Vec2.clone(this.m_linearImpulse);\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce;\n\n      this.m_linearImpulse.clamp(maxImpulse);\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport options from '../../util/options';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Mat22 from '../../common/Mat22';\nimport Rot from '../../common/Rot';\nimport Transform from '../../common/Transform';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointOpt extends JointOpt {\n  /**\n   * [maxForce = 0.0] The maximum constraint force that can be exerted to move\n   * the candidate body. Usually you will express as some multiple of the\n   * weight (multiplier * mass * gravity).\n   */\n  maxForce?: number;\n  /**\n   * [frequencyHz = 5.0] The response speed.\n   */\n  frequencyHz?: number;\n  /**\n   * [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical\n   * damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointDef extends JointDef, MouseJointOpt {\n  /**\n   * The initial world target point. This is assumed to coincide with the body\n   * anchor initially.\n   */\n  target: Vec2;\n}\n\nconst DEFAULTS = {\n  maxForce : 0.0,\n  frequencyHz : 5.0,\n  dampingRatio : 0.7\n};\n\n/**\n * A mouse joint is used to make a point on a body track a specified world\n * point. This a soft constraint with a maximum force. This allows the\n * constraint to stretch and without applying huge forces.\n *\n * NOTE: this joint is not documented in the manual because it was developed to\n * be used in the testbed. If you want to learn how to use the mouse joint, look\n * at the testbed.\n */\nexport default class MouseJoint extends Joint {\n  static TYPE = 'mouse-joint' as const;\n\n  /** @internal */ m_type: 'mouse-joint';\n  /** @internal */ m_targetA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_impulse: Vec2;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_beta: number;\n  /** @internal */ m_gamma: number;\n  // Solver temp\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat22;\n  /** @internal */ m_C: Vec2;\n\n  constructor(def: MouseJointDef);\n  constructor(def: MouseJointOpt, bodyA: Body, bodyB: Body, target: Vec2);\n  constructor(def: MouseJointDef, bodyA?: Body, bodyB?: Body, target?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof MouseJoint)) {\n      return new MouseJoint(def, bodyA, bodyB, target);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MouseJoint.TYPE;\n\n    _ASSERT && common.assert(Math.isFinite(def.maxForce) && def.maxForce >= 0.0);\n    _ASSERT && common.assert(Math.isFinite(def.frequencyHz) && def.frequencyHz >= 0.0);\n    _ASSERT && common.assert(Math.isFinite(def.dampingRatio) && def.dampingRatio >= 0.0);\n\n    this.m_targetA = target ? Vec2.clone(target) : def.target || Vec2.zero();\n    this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), this.m_targetA);\n\n    this.m_maxForce = def.maxForce;\n    this.m_impulse = Vec2.zero();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_beta = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rB = Vec2.zero();\n    this.m_localCenterB = Vec2.zero();\n    this.m_invMassB = 0.0;\n    this.m_invIB = 0.0;\n    this.m_mass = new Mat22();\n    this.m_C = Vec2.zero();\n\n    // p = attached point, m = mouse point\n    // C = p - m\n    // Cdot = v\n    // = v + cross(w, r)\n    // J = [I r_skew]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      target: this.m_targetA,\n      maxForce: this.m_maxForce,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      _localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MouseJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.target = Vec2.clone(data.target);\n    const joint = new MouseJoint(data);\n    if (data._localAnchorB) {\n      joint.m_localAnchorB = data._localAnchorB;\n    }\n    return joint;\n  }\n\n  /**\n   * Use this to update the target point.\n   */\n  setTarget(target: Vec2): void {\n    if (this.m_bodyB.isAwake() == false) {\n      this.m_bodyB.setAwake(true);\n    }\n    this.m_targetA = Vec2.clone(target);\n  }\n\n  getTarget(): Vec2 {\n    return this.m_targetA;\n  }\n\n  /**\n   * Set the maximum force in Newtons.\n   */\n  setMaxForce(force: number): void {\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum force in Newtons.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the frequency in Hertz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get the frequency in Hertz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set the damping ratio (dimensionless).\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get the damping ratio (dimensionless).\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return Vec2.clone(this.m_targetA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * 0.0;\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_targetA.sub(newOrigin);\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const position = this.m_bodyB.c_position;\n    const velocity = this.m_bodyB.c_velocity;\n\n    const cB = position.c;\n    const aB = position.a;\n    const vB = velocity.v;\n    let wB = velocity.w;\n\n    const qB = Rot.neo(aB);\n\n    const mass = this.m_bodyB.getMass();\n\n    // Frequency\n    const omega = 2.0 * Math.PI * this.m_frequencyHz;\n\n    // Damping coefficient\n    const d = 2.0 * mass * this.m_dampingRatio * omega;\n\n    // Spring stiffness\n    const k = mass * (omega * omega);\n\n    // magic formulas\n    // gamma has units of inverse mass.\n    // beta has units of inverse time.\n    const h = step.dt;\n    _ASSERT && common.assert(d + h * k > Math.EPSILON);\n    this.m_gamma = h * (d + h * k);\n    if (this.m_gamma != 0.0) {\n      this.m_gamma = 1.0 / this.m_gamma;\n    }\n    this.m_beta = h * k * this.m_gamma;\n\n    // Compute the effective mass matrix.\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n    // invI2 * skew(r2)]\n    // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n    // -r1.x*r1.y]\n    // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n    const K = new Mat22();\n    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y\n        + this.m_gamma;\n    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x\n        + this.m_gamma;\n\n    this.m_mass = K.getInverse();\n\n    this.m_C.setVec2(cB);\n    this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n    this.m_C.mul(this.m_beta);\n\n    // Cheat with some damping\n    wB *= 0.98;\n\n    if (step.warmStarting) {\n      this.m_impulse.mul(step.dtRatio);\n      vB.addMul(this.m_invMassB, this.m_impulse);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const velocity = this.m_bodyB.c_velocity;\n    const vB = Vec2.clone(velocity.v);\n    let wB = velocity.w;\n\n    // Cdot = v + cross(w, r)\n\n    const Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n    Cdot.add(vB);\n\n    Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n    Cdot.neg();\n\n    let impulse = Mat22.mulVec2(this.m_mass, Cdot);\n\n    const oldImpulse = Vec2.clone(this.m_impulse);\n    this.m_impulse.add(impulse);\n    const maxImpulse = step.dt * this.m_maxForce;\n    this.m_impulse.clamp(maxImpulse);\n    impulse = Vec2.sub(this.m_impulse, oldImpulse);\n\n    vB.addMul(this.m_invMassB, impulse);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\n// tslint:disable-next-line:no-empty-interface\nexport interface PulleyJointOpt extends JointOpt {\n}\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\nexport interface PulleyJointDef extends JointDef, PulleyJointOpt {\n  /**\n   * The first ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorA: Vec2;\n  /**\n   * The second ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorB: Vec2;\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The reference length for the segment attached to bodyA.\n   */\n  lengthA: number;\n  /**\n   * The reference length for the segment attached to bodyB.\n   */\n  lengthB: number;\n  /**\n   * The pulley ratio, used to simulate a block-and-tackle.\n   */\n  ratio: number;\n}\n\nconst DEFAULTS = {\n  collideConnected : true\n};\n\n/**\n * The pulley joint is connected to two bodies and two fixed ground points. The\n * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n *\n * Yes, the force transmitted is scaled by the ratio.\n *\n * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n * better when combined with prismatic joints. You should also cover the the\n * anchor points with static shapes to prevent one side from going to zero\n * length.\n */\nexport default class PulleyJoint extends Joint {\n  static TYPE = 'pulley-joint' as const;\n  // static MIN_PULLEY_LENGTH: number = 2.0; // TODO where this is used?\n\n  /** @internal */ m_type: 'pulley-joint';\n  /** @internal */ m_groundAnchorA: Vec2;\n  /** @internal */ m_groundAnchorB: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_lengthA: number;\n  /** @internal */ m_lengthB: number;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_uA: Vec2;\n  /** @internal */ m_uB: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: PulleyJointDef);\n  constructor(def: PulleyJointOpt, bodyA: Body, bodyB: Body, groundA: Vec2, groundB: Vec2, anchorA: Vec2, anchorB: Vec2, ratio: number);\n  constructor(def: PulleyJointDef, bodyA?: Body, bodyB?: Body, groundA?: Vec2, groundB?: Vec2, anchorA?: Vec2, anchorB?: Vec2, ratio?: number) {\n    // @ts-ignore\n    if (!(this instanceof PulleyJoint)) {\n      return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PulleyJoint.TYPE;\n    this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0);\n    this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);\n    this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n    this.m_lengthA = Math.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n    this.m_lengthB = Math.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n    this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;\n\n    _ASSERT && common.assert(ratio > Math.EPSILON);\n\n    this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;\n\n    this.m_impulse = 0.0;\n\n    // Pulley:\n    // length1 = norm(p1 - s1)\n    // length2 = norm(p2 - s2)\n    // C0 = (length1 + ratio * length2)_initial\n    // C = C0 - (length1 + ratio * length2)\n    // u1 = (p1 - s1) / norm(p1 - s1)\n    // u2 = (p2 - s2) / norm(p2 - s2)\n    // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n    // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n    // cross(r2, u2)^2)\n  }\n\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      groundAnchorA: this.m_groundAnchorA,\n      groundAnchorB: this.m_groundAnchorB,\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      lengthA: this.m_lengthA,\n      lengthB: this.m_lengthB,\n      ratio: this.m_ratio,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PulleyJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new PulleyJoint(data);\n    return joint;\n  }\n\n  /**\n   * Get the first ground anchor.\n   */\n  getGroundAnchorA(): Vec2 {\n    return this.m_groundAnchorA;\n  }\n\n  /**\n   * Get the second ground anchor.\n   */\n  getGroundAnchorB(): Vec2 {\n    return this.m_groundAnchorB;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getLengthA(): number {\n    return this.m_lengthA;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getLengthB(): number {\n    return this.m_lengthB;\n  }\n\n  /**\n   * Get the pulley ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getCurrentLengthA(): number {\n    const p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const s = this.m_groundAnchorA;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getCurrentLengthB(): number {\n    const p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const s = this.m_groundAnchorB;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   *\n   * @param newOrigin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    this.m_groundAnchorA.sub(newOrigin);\n    this.m_groundAnchorB.sub(newOrigin);\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = this.m_uA.length();\n    const lengthB = this.m_uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      this.m_uA.mul(1.0 / lengthA);\n    } else {\n      this.m_uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      this.m_uB.mul(1.0 / lengthB);\n    } else {\n      this.m_uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA); // float\n    const ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB); // float\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n\n    if (this.m_mass > 0.0) {\n      this.m_mass = 1.0 / this.m_mass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support variable time steps.\n      this.m_impulse *= step.dtRatio;\n\n      // Warm starting.\n      const PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n      const PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n\n      vA.addMul(this.m_invMassA, PA);\n      wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n\n      vB.addMul(this.m_invMassB, PB);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n\n    const Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio\n        * Vec2.dot(this.m_uB, vpB); // float\n    const impulse = -this.m_mass * Cdot; // float\n    this.m_impulse += impulse;\n\n    const PA = Vec2.mulNumVec2(-impulse, this.m_uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB); // Vec2\n    vA.addMul(this.m_invMassA, PA);\n    wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n    vB.addMul(this.m_invMassB, PB);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    const uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    const uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = uA.length();\n    const lengthB = uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      uA.mul(1.0 / lengthA);\n    } else {\n      uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      uB.mul(1.0 / lengthB);\n    } else {\n      uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(rA, uA);\n    const ruB = Vec2.crossVec2Vec2(rB, uB);\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float\n\n    let mass = mA + this.m_ratio * this.m_ratio * mB; // float\n\n    if (mass > 0.0) {\n      mass = 1.0 / mass;\n    }\n\n    const C = this.m_constant - lengthA - this.m_ratio * lengthB; // float\n    const linearError = Math.abs(C); // float\n\n    const impulse = -mass * C; // float\n\n    const PA = Vec2.mulNumVec2(-impulse, uA); // Vec2\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB); // Vec2\n\n    cA.addMul(this.m_invMassA, PA);\n    aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n    cB.addMul(this.m_invMassB, PB);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\nconst inactiveLimit = 0;\nconst atLowerLimit = 1;\nconst atUpperLimit = 2;\nconst equalLimits = 3;\n\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointOpt extends JointOpt {\n  /**\n   * The maximum length of the rope.\n   * Warning: this must be larger than linearSlop or the joint will have no effect.\n   */\n  maxLength?: number;\n}\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointDef extends JointDef, RopeJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  maxLength : 0.0,\n};\n\n/**\n * A rope joint enforces a maximum distance between two points on two bodies. It\n * has no other effect.\n *\n * Warning: if you attempt to change the maximum length during the simulation\n * you will get some non-physical behavior.\n *\n * A model that would allow you to dynamically modify the length would have some\n * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n * want to dynamically control length.\n */\nexport default class RopeJoint extends Joint {\n  static TYPE = 'rope-joint' as const;\n\n  /** @internal */ m_type: 'rope-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  /** @internal */ m_maxLength: number;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_length: number;\n  /** @internal */ m_state: number; // TODO enum\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  constructor(def: RopeJointDef);\n  constructor(def: RopeJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: RopeJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof RopeJoint)) {\n      return new RopeJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RopeJoint.TYPE;\n    this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);\n    this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);\n\n    this.m_maxLength = def.maxLength;\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_length = 0.0;\n    this.m_state = inactiveLimit;\n\n    // Limit:\n    // C = norm(pB - pA) - L\n    // u = (pB - pA) / norm(pB - pA)\n    // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n    // J = [-u -cross(rA, u) u cross(rB, u)]\n    // K = J * invM * JT\n    // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      maxLength: this.m_maxLength,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): RopeJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RopeJoint(data);\n    return joint;\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum length of the rope.\n   */\n  setMaxLength(length: number): void {\n    this.m_maxLength = length;\n  }\n\n  /**\n   * Get the maximum length of the rope.\n   */\n  getMaxLength(): number {\n    return this.m_maxLength;\n  }\n\n  getLimitState(): number {\n    // TODO LimitState\n    return this.m_state;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    this.m_u = Vec2.zero();\n    this.m_u.addCombine(1, cB, 1, this.m_rB);\n    this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2\n\n    this.m_length = this.m_u.length();\n\n    const C = this.m_length - this.m_maxLength; // float\n    if (C > 0.0) {\n      this.m_state = atUpperLimit;\n    } else {\n      this.m_state = inactiveLimit;\n    }\n\n    if (this.m_length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / this.m_length);\n    } else {\n      this.m_u.setZero();\n      this.m_mass = 0.0;\n      this.m_impulse = 0.0;\n      return;\n    }\n\n    // Compute effective mass.\n    const crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u); // float\n    const crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u); // float\n    const invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB\n        + this.m_invIB * crB * crB; // float\n\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA); // Vec2\n    const vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB); // Vec2\n    const C = this.m_length - this.m_maxLength; // float\n    let Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float\n\n    // Predictive constraint.\n    if (C < 0.0) {\n      Cdot += step.inv_dt * C;\n    }\n\n    let impulse = -this.m_mass * Cdot; // float\n    const oldImpulse = this.m_impulse; // float\n    this.m_impulse = Math.min(0.0, this.m_impulse + impulse);\n    impulse = this.m_impulse - oldImpulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u); // Vec2\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c; // Vec2\n    let aA = this.m_bodyA.c_position.a; // float\n    const cB = this.m_bodyB.c_position.c; // Vec2\n    let aB = this.m_bodyB.c_position.a; // float\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.zero();\n    u.addCombine(1, cB, 1, rB);\n    u.subCombine(1, cA, 1, rA); // Vec2\n\n    const length = u.normalize(); // float\n    let C = length - this.m_maxLength; // float\n\n    C = Math.clamp(C, 0.0, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C; // float\n    const P = Vec2.mulNumVec2(impulse, u); // Vec2\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return length - this.m_maxLength < Settings.linearSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Vec3 from '../../common/Vec3';\nimport Mat33 from '../../common/Mat33';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n *\n * @prop {float} frequencyHz\n * @prop {float} dampingRatio\n *\n * @prop {Vec2} localAnchorA\n * @prop {Vec2} localAnchorB\n * @prop {float} referenceAngle\n */\nexport interface WeldJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. Rotation only. Disable softness\n   * with a value of 0.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle?: number;\n}\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n */\nexport interface WeldJointDef extends JointDef, WeldJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\nconst DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0,\n};\n\n/**\n * A weld joint essentially glues two bodies together. A weld joint may distort\n * somewhat because the island constraint solver is approximate.\n */\nexport default class WeldJoint extends Joint {\n  static TYPE = 'weld-joint' as const\n\n  /** @internal */ m_type: 'weld-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_impulse: Vec3;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat33;\n\n  constructor(def: WeldJointDef);\n  constructor(def: WeldJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2);\n  constructor(def: WeldJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof WeldJoint)) {\n      return new WeldJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WeldJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_impulse = new Vec3();\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rA; // Vec2\n    this.m_rB; // Vec2\n    this.m_localCenterA; // Vec2\n    this.m_localCenterB; // Vec2\n    this.m_invMassA; // float\n    this.m_invMassB; // float\n    this.m_invIA; // float\n    this.m_invIB; // float\n    this.m_mass = new Mat33();\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // C = angle2 - angle1 - referenceAngle\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WeldJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WeldJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Set frequency in Hz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get frequency in Hz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set damping ratio.\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get damping ratio.\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y\n        * iB;\n    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x\n        * iB;\n    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      K.getInverse22(this.m_mass);\n\n      let invM = iA + iB; // float\n      const m = invM > 0.0 ? 1.0 / invM : 0.0; // float\n\n      const C = aB - aA - this.m_referenceAngle; // float\n\n      // Frequency\n      const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n      // Damping coefficient\n      const d = 2.0 * m * this.m_dampingRatio * omega; // float\n\n      // Spring stiffness\n      const k = m * omega * omega; // float\n\n      // magic formulas\n      const h = step.dt; // float\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invM += this.m_gamma;\n      this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n    } else if (K.ez.z == 0.0) {\n      K.getInverse22(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    } else {\n      K.getSymInverse33(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    if (this.m_frequencyHz > 0.0) {\n      const Cdot2 = wB - wA; // float\n\n      const impulse2 = -this.m_mass.ez.z\n          * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float\n      this.m_impulse.z += impulse2;\n\n      wA -= iA * impulse2;\n      wB += iB * impulse2;\n\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n\n      const impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2\n      this.m_impulse.x += impulse1.x;\n      this.m_impulse.y += impulse1.y;\n\n      const P = Vec2.clone(impulse1); // Vec2\n\n      vA.subMul(mA, P);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(mB, P);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n    } else {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA)); // Vec2\n      const Cdot2 = wB - wA; // float\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3\n\n      const impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3\n      this.m_impulse.add(impulse);\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    let positionError: number;\n    let angularError: number;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n    K.ez.x = -rA.y * iA - rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n    K.ez.y = rA.x * iA + rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA); // Vec2\n\n      positionError = C1.length();\n      angularError = 0.0;\n\n      const P = Vec2.neg(K.solve22(C1)); // Vec2\n\n      cA.subMul(mA, P);\n      aA -= iA * Vec2.crossVec2Vec2(rA, P);\n\n      cB.addMul(mB, P);\n      aB += iB * Vec2.crossVec2Vec2(rB, P);\n    } else {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA);\n\n      const C2 = aB - aA - this.m_referenceAngle; // float\n\n      positionError = C1.length();\n      angularError = Math.abs(C2);\n\n      const C = new Vec3(C1.x, C1.y, C2);\n\n      let impulse = new Vec3();\n      if (K.ez.z > 0.0) {\n        impulse = Vec3.neg(K.solve33(C));\n      } else {\n        const impulse2 = Vec2.neg(K.solve22(C1));\n        impulse.set(impulse2.x, impulse2.y, 0.0);\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      cA.subMul(mA, P);\n      aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n\n      cB.addMul(mB, P);\n      aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n  }\n\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport options from '../../util/options';\nimport Settings from '../../Settings';\nimport Math from '../../common/Math';\nimport Vec2 from '../../common/Vec2';\nimport Rot from '../../common/Rot';\nimport Joint, { JointOpt, JointDef } from '../Joint';\nimport Body from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * Suspension frequency, zero indicates no suspension.\n   */\n  frequencyHz?: number;\n  /**\n   * Suspension damping ratio, one indicates critical damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointDef extends JointDef, WheelJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n  /**\n   * The local translation axis in bodyA.\n   */\n  localAxisA: Vec2;\n}\n\nconst DEFAULTS = {\n  enableMotor : false,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  frequencyHz : 2.0,\n  dampingRatio : 0.7,\n};\n\n/**\n * A wheel joint. This joint provides two degrees of freedom: translation along\n * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n * point to line constraint with a rotational motor and a linear spring/damper.\n * This joint is designed for vehicle suspensions.\n */\nexport default class WheelJoint extends Joint {\n  static TYPE = 'wheel-joint' as const;\n\n  /** @internal */ m_type: 'wheel-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_springMass: number;\n  /** @internal */ m_springImpulse: number;\n\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableMotor: boolean;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  /** @internal */ m_ax: Vec2 = Vec2.zero();\n  /** @internal */ m_ay: Vec2 = Vec2.zero();\n  /** @internal */ m_sAx: number;\n  /** @internal */ m_sBx: number;\n  /** @internal */ m_sAy: number;\n  /** @internal */ m_sBy: number;\n\n  constructor(def: WheelJointDef);\n  constructor(def: WheelJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2, axis: Vec2);\n  // @ts-ignore\n  constructor(def: WheelJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2, axis?: Vec2) {\n    // @ts-ignore\n    if (!(this instanceof WheelJoint)) {\n      return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WheelJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    // @ts-ignore localAxis\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n    this.m_springMass = 0.0;\n    this.m_springImpulse = 0.0;\n\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableMotor = def.enableMotor;\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Linear constraint (point-to-line)\n    // d = pB - pA = xB + rB - xA - rA\n    // C = dot(ay, d)\n    // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n    // rA))\n    // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n    // ay), vB)\n    // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n\n    // Spring linear constraint\n    // C = dot(ax, d)\n    // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n    // dot(cross(rB, ax), vB)\n    // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n\n    // Motor rotational constraint\n    // Cdot = wB - wA\n    // J = [0 0 -1 0 0 1]\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      enableMotor: this.m_enableMotor,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WheelJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WheelJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2,\n    localAnchorA?: Vec2,\n    anchorB?: Vec2,\n    localAnchorB?: Vec2,\n    localAxisA?: Vec2,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2\n    const pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2\n    const d = Vec2.sub(pB, pA); // Vec2\n    const axis = bA.getWorldVector(this.m_localXAxisA); // Vec2\n\n    const translation = Vec2.dot(d, axis); // float\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const wA = this.m_bodyA.m_angularVelocity;\n    const wB = this.m_bodyB.m_angularVelocity;\n    return wB - wA;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed, usually in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set/Get the maximum motor force, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step, usually in N-m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n   * the spring.\n   */\n  setSpringFrequencyHz(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getSpringFrequencyHz(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set/Get the spring damping ratio\n   */\n  setSpringDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getSpringDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA); // Vec2\n\n    // Point to line constraint\n    {\n      this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n      this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n      this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n\n      this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy\n          * this.m_sBy;\n\n      if (this.m_mass > 0.0) {\n        this.m_mass = 1.0 / this.m_mass;\n      }\n    }\n\n    // Spring constraint\n    this.m_springMass = 0.0;\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n    if (this.m_frequencyHz > 0.0) {\n      this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n      this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n\n      const invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx\n          * this.m_sBx; // float\n\n      if (invMass > 0.0) {\n        this.m_springMass = 1.0 / invMass;\n\n        const C = Vec2.dot(d, this.m_ax); // float\n\n        // Frequency\n        const omega = 2.0 * Math.PI * this.m_frequencyHz; // float\n\n        // Damping coefficient\n        const damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float\n\n        // Spring stiffness\n        const k = this.m_springMass * omega * omega; // float\n\n        // magic formulas\n        const h = step.dt; // float\n        this.m_gamma = h * (damp + h * k);\n        if (this.m_gamma > 0.0) {\n          this.m_gamma = 1.0 / this.m_gamma;\n        }\n\n        this.m_bias = C * h * k * this.m_gamma;\n\n        this.m_springMass = invMass + this.m_gamma;\n        if (this.m_springMass > 0.0) {\n          this.m_springMass = 1.0 / this.m_springMass;\n        }\n      }\n    } else {\n      this.m_springImpulse = 0.0;\n    }\n\n    // Rotational motor\n    if (this.m_enableMotor) {\n      this.m_motorMass = iA + iB;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    } else {\n      this.m_motorMass = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse *= step.dtRatio;\n      this.m_springImpulse *= step.dtRatio;\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n      const LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n      const LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * LA;\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * LB;\n\n    } else {\n      this.m_impulse = 0.0;\n      this.m_springImpulse = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB; // float\n    const iA = this.m_invIA;\n    const iB = this.m_invIB; // float\n\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Solve spring constraint\n    {\n      const Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx\n          * wB - this.m_sAx * wA; // float\n      const impulse = -this.m_springMass\n          * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float\n      this.m_springImpulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ax); // Vec2\n      const LA = impulse * this.m_sAx; // float\n      const LB = impulse * this.m_sBx; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    // Solve rotational motor constraint\n    {\n      const Cdot = wB - wA - this.m_motorSpeed; // float\n      let impulse = -this.m_motorMass * Cdot; // float\n\n      const oldImpulse = this.m_motorImpulse; // float\n      const maxImpulse = step.dt * this.m_maxMotorTorque; // float\n      this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve point to line constraint\n    {\n      const Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy\n          * wB - this.m_sAy * wA; // float\n      const impulse = -this.m_mass * Cdot; // float\n      this.m_impulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ay); // Vec2\n      const LA = impulse * this.m_sAy; // float\n      const LB = impulse * this.m_sBy; // float\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const ay = Rot.mulVec2(qA, this.m_localYAxisA);\n\n    const sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay); // float\n    const sBy = Vec2.crossVec2Vec2(rB, ay); // float\n\n    const C = Vec2.dot(d, ay); // float\n\n    const k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy\n        * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float\n\n    let impulse; // float\n    if (k != 0.0) {\n      impulse = -C / k;\n    } else {\n      impulse = 0.0;\n    }\n\n    const P = Vec2.mulNumVec2(impulse, ay); // Vec2\n    const LA = impulse * sAy; // float\n    const LB = impulse * sBy; // float\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * LA;\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * LB;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return Math.abs(C) <= Settings.linearSlop;\n  }\n\n}\n","// tslint:disable:typedef\nimport World from '../dynamics/World';\nimport Body from '../dynamics/Body';\nimport Joint from '../dynamics/Joint';\nimport Fixture from '../dynamics/Fixture';\nimport Shape from '../collision/Shape';\nimport Vec2 from '../common/Vec2';\nimport Vec3 from '../common/Vec3';\nimport ChainShape from \"../collision/shape/ChainShape\";\nimport BoxShape from \"../collision/shape/BoxShape\";\nimport EdgeShape from \"../collision/shape/EdgeShape\";\nimport PolygonShape from \"../collision/shape/PolygonShape\";\nimport CircleShape from \"../collision/shape/CircleShape\";\nimport DistanceJoint from \"../dynamics/joint/DistanceJoint\";\nimport FrictionJoint from \"../dynamics/joint/FrictionJoint\";\nimport GearJoint from \"../dynamics/joint/GearJoint\";\nimport MotorJoint from \"../dynamics/joint/MotorJoint\";\nimport MouseJoint from \"../dynamics/joint/MouseJoint\";\nimport PrismaticJoint from \"../dynamics/joint/PrismaticJoint\";\nimport PulleyJoint from \"../dynamics/joint/PulleyJoint\";\nimport RevoluteJoint from \"../dynamics/joint/RevoluteJoint\";\nimport RopeJoint from \"../dynamics/joint/RopeJoint\";\nimport WeldJoint from \"../dynamics/joint/WeldJoint\";\nimport WheelJoint from \"../dynamics/joint/WheelJoint\";\n\nlet SID = 0;\n\nfunction Serializer(opts?) {\n  opts = opts || {};\n\n  const rootClass = opts.rootClass || World;\n\n  const preSerialize = opts.preSerialize || function(obj) { return obj; };\n  const postSerialize = opts.postSerialize || function(data, obj) { return data; };\n\n  const preDeserialize = opts.preDeserialize || function(data) { return data; };\n  const postDeserialize = opts.postDeserialize || function(obj, data) { return obj; };\n\n  // This is used to create ref objects during serialize\n  const refTypes = {\n    World,\n    Body,\n    Joint,\n    Fixture,\n    Shape,\n  };\n\n  // This is used by restore to deserialize objects and refs\n  const restoreTypes = {\n    Vec2,\n    Vec3,\n    ...refTypes\n  };\n\n  const CLASS_BY_TYPE_PROP = {\n    [Body.STATIC]: Body,\n    [Body.DYNAMIC]: Body,\n    [Body.KINEMATIC]: Body,\n    [ChainShape.TYPE]: ChainShape,\n    [BoxShape.TYPE]: BoxShape,\n    [EdgeShape.TYPE]: EdgeShape,\n    [PolygonShape.TYPE]: PolygonShape,\n    [CircleShape.TYPE]: CircleShape,\n    [DistanceJoint.TYPE]: DistanceJoint,\n    [FrictionJoint.TYPE]: FrictionJoint,\n    [GearJoint.TYPE]: GearJoint,\n    [MotorJoint.TYPE]: MotorJoint,\n    [MouseJoint.TYPE]: MouseJoint,\n    [PrismaticJoint.TYPE]: PrismaticJoint,\n    [PulleyJoint.TYPE]: PulleyJoint,\n    [RevoluteJoint.TYPE]: RevoluteJoint,\n    [RopeJoint.TYPE]: RopeJoint,\n    [WeldJoint.TYPE]: WeldJoint,\n    [WheelJoint.TYPE]: WheelJoint,\n  }\n\n  this.toJson = function(root) {\n    const json = [];\n\n    const queue = [root];\n    const refMap = {};\n\n    function storeRef(value, typeName) {\n      value.__sid = value.__sid || ++SID;\n      if (!refMap[value.__sid]) {\n        queue.push(value);\n        const index = json.length + queue.length;\n        const ref = {\n          refIndex: index,\n          refType: typeName\n        };\n        refMap[value.__sid] = ref;\n      }\n      return refMap[value.__sid];\n    }\n\n    function serialize(obj) {\n      obj = preSerialize(obj);\n      let data = obj._serialize();\n      data = postSerialize(data, obj);\n      return data;\n    }\n\n    function toJson(value, top?) {\n      if (typeof value !== 'object' || value === null) {\n        return value;\n      }\n      if (typeof value._serialize === 'function') {\n        if (value !== top) {\n          // tslint:disable-next-line:no-for-in\n          for (const typeName in refTypes) {\n            if (value instanceof refTypes[typeName]) {\n              return storeRef(value, typeName);\n            }\n          }\n        }\n        value = serialize(value);\n      }\n      if (Array.isArray(value)) {\n        const newValue = [];\n        for (let key = 0; key < value.length; key++) {\n          newValue[key] = toJson(value[key]);\n        }\n        value = newValue;\n\n      } else {\n        const newValue = {};\n        // tslint:disable-next-line:no-for-in\n        for (const key in value) {\n          if (value.hasOwnProperty(key)) {\n            newValue[key] = toJson(value[key]);\n          }\n        }\n        value = newValue;\n      }\n      return value;\n    }\n\n    while (queue.length) {\n      const obj = queue.shift();\n      const str = toJson(obj, obj);\n      json.push(str);\n    }\n\n    return json;\n  };\n\n  this.fromJson = function(json: object) {\n    const refMap = {};\n\n    function findDeserilizer(data, cls) {\n      if (!cls || !cls._deserialize) {\n        cls = CLASS_BY_TYPE_PROP[data.type]\n      }\n      return cls && cls._deserialize;\n    }\n\n    /**\n     * Deserialize a data object.\n     */\n    function deserialize(cls, data, ctx) {\n      const deserializer = findDeserilizer(data, cls);\n      if (!deserializer) {\n        return;\n      }\n      data = preDeserialize(data);\n      let obj = deserializer(data, ctx, restoreRef);\n      obj = postDeserialize(obj, data);\n      return obj;\n    }\n\n    /**\n     * Restore a ref object or deserialize a data object.\n     *\n     * This is passed as callback to class deserializers.\n     */\n    function restoreRef(cls, ref, ctx) {\n      if (!ref.refIndex) {\n        return cls && cls._deserialize && deserialize(cls, ref, ctx);\n      }\n      cls = restoreTypes[ref.refType] || cls;\n      const index = ref.refIndex;\n      if (!refMap[index]) {\n        const data = json[index];\n        const obj = deserialize(cls, data, ctx);\n        refMap[index] = obj;\n      }\n      return refMap[index];\n    }\n\n    const root = rootClass._deserialize(json[0], null, restoreRef);\n\n    return root;\n  };\n}\n\nconst serializer = new Serializer();\n\nSerializer.toJson = serializer.toJson;\nSerializer.fromJson = serializer.fromJson;\n\nexport default Serializer;\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nimport common from '../../util/common';\nimport Transform from '../../common/Transform';\nimport Vec2 from '../../common/Vec2';\nimport Contact from '../../dynamics/Contact';\nimport CircleShape from './CircleShape';\nimport Manifold, { ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport Fixture from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n\nfunction CircleCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == CircleShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollideCircles(manifold, fixtureA.getShape() as CircleShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nexport function CollideCircles(manifold: Manifold, circleA: CircleShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  const pA = Transform.mulVec2(xfA, circleA.m_p);\n  const pB = Transform.mulVec2(xfB, circleB.m_p);\n\n  const distSqr = Vec2.distanceSquared(pB, pA);\n  const rA = circleA.m_radius;\n  const rB = circleB.m_radius;\n  const radius = rA + rB;\n  if (distSqr > radius * radius) {\n    return;\n  }\n\n  manifold.type = ManifoldType.e_circles;\n  manifold.localPoint.setVec2(circleA.m_p);\n  manifold.localNormal.setZero();\n  manifold.pointCount = 1;\n  manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.cf.indexA = 0;\n  manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n  manifold.points[0].id.cf.indexB = 0;\n  manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport Transform from '../../common/Transform';\nimport Vec2 from '../../common/Vec2';\nimport Contact from '../../dynamics/Contact';\nimport EdgeShape from './EdgeShape';\nimport ChainShape from './ChainShape';\nimport CircleShape from './CircleShape';\nimport Manifold, { ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport Fixture from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\nContact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n\nfunction EdgeCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == EdgeShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const shapeA = fixtureA.getShape() as EdgeShape;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\nfunction ChainCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == ChainShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const chain = fixtureA.getShape() as ChainShape;\n  const edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n\n  const shapeA = edge;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\n// Compute contact points for edge versus circle.\n// This accounts for edge connectivity.\nexport function CollideEdgeCircle(manifold: Manifold, edgeA: EdgeShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  // Compute circle in frame of edge\n  const Q = Transform.mulTVec2(xfA, Transform.mulVec2(xfB, circleB.m_p));\n\n  const A = edgeA.m_vertex1;\n  const B = edgeA.m_vertex2;\n  const e = Vec2.sub(B, A);\n\n  // Barycentric coordinates\n  const u = Vec2.dot(e, Vec2.sub(B, Q));\n  const v = Vec2.dot(e, Vec2.sub(Q, A));\n\n  const radius = edgeA.m_radius + circleB.m_radius;\n\n  // Region A\n  if (v <= 0.0) {\n    const P = Vec2.clone(A);\n    const d = Vec2.sub(Q, P);\n    const dd = Vec2.dot(d, d);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to A?\n    if (edgeA.m_hasVertex0) {\n      const A1 = edgeA.m_vertex0;\n      const B1 = A;\n      const e1 = Vec2.sub(B1, A1);\n      const u1 = Vec2.dot(e1, Vec2.sub(B1, Q));\n\n      // Is the circle in Region AB of the previous edge?\n      if (u1 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    manifold.localNormal.setZero();\n    manifold.localPoint.setVec2(P);\n    manifold.pointCount = 1;\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    return;\n  }\n\n  // Region B\n  if (u <= 0.0) {\n    const P = Vec2.clone(B);\n    const d = Vec2.sub(Q, P);\n    const dd = Vec2.dot(d, d);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to B?\n    if (edgeA.m_hasVertex3) {\n      const B2 = edgeA.m_vertex3;\n      const A2 = B;\n      const e2 = Vec2.sub(B2, A2);\n      const v2 = Vec2.dot(e2, Vec2.sub(Q, A2));\n\n      // Is the circle in Region AB of the next edge?\n      if (v2 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    manifold.localNormal.setZero();\n    manifold.localPoint.setVec2(P);\n    manifold.pointCount = 1;\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 1;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    return;\n  }\n\n  // Region AB\n  const den = Vec2.dot(e, e);\n  _ASSERT && common.assert(den > 0.0);\n  const P = Vec2.combine(u / den, A, v / den, B);\n  const d = Vec2.sub(Q, P);\n  const dd = Vec2.dot(d, d);\n  if (dd > radius * radius) {\n    return;\n  }\n\n  const n = Vec2.neo(-e.y, e.x);\n  if (Vec2.dot(n, Vec2.sub(Q, A)) < 0.0) {\n    n.setNum(-n.x, -n.y);\n  }\n  n.normalize();\n\n  manifold.type = ManifoldType.e_faceA;\n  manifold.localNormal = n;\n  manifold.localPoint.setVec2(A);\n  manifold.pointCount = 1;\n  manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.cf.indexA = 0;\n  manifold.points[0].id.cf.typeA = ContactFeatureType.e_face;\n  manifold.points[0].id.cf.indexB = 0;\n  manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport Transform from '../../common/Transform';\nimport Rot from '../../common/Rot';\nimport Vec2 from '../../common/Vec2';\nimport Settings from '../../Settings';\nimport Manifold, { clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport Contact from '../../dynamics/Contact';\nimport PolygonShape from './PolygonShape';\nimport Fixture from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n\nfunction PolygonContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == PolygonShape.TYPE);\n  CollidePolygons(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as PolygonShape, xfB);\n}\n\ninterface MaxSeparation {\n  maxSeparation: number;\n  bestIndex: number;\n}\n\n/**\n * Find the max separation between poly1 and poly2 using edge normals from\n * poly1.\n */\nfunction findMaxSeparation(poly1: PolygonShape, xf1: Transform, poly2: PolygonShape, xf2: Transform, output: MaxSeparation): void {\n  const count1 = poly1.m_count;\n  const count2 = poly2.m_count;\n  const n1s = poly1.m_normals;\n  const v1s = poly1.m_vertices;\n  const v2s = poly2.m_vertices;\n  const xf = Transform.mulTXf(xf2, xf1);\n\n  let bestIndex = 0;\n  let maxSeparation = -Infinity;\n  for (let i = 0; i < count1; ++i) {\n    // Get poly1 normal in frame2.\n    const n = Rot.mulVec2(xf.q, n1s[i]);\n    const v1 = Transform.mulVec2(xf, v1s[i]);\n\n    // Find deepest point for normal i.\n    let si = Infinity;\n    for (let j = 0; j < count2; ++j) {\n      const sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);\n      if (sij < si) {\n        si = sij;\n      }\n    }\n\n    if (si > maxSeparation) {\n      maxSeparation = si;\n      bestIndex = i;\n    }\n  }\n\n  // used to keep last FindMaxSeparation call values\n  output.maxSeparation = maxSeparation;\n  output.bestIndex = bestIndex;\n}\n\nfunction findIncidentEdge(c: ClipVertex[], poly1: PolygonShape, xf1: Transform, edge1: number, poly2: PolygonShape, xf2: Transform): void {\n  const normals1 = poly1.m_normals;\n\n  const count2 = poly2.m_count;\n  const vertices2 = poly2.m_vertices;\n  const normals2 = poly2.m_normals;\n\n  _ASSERT && common.assert(0 <= edge1 && edge1 < poly1.m_count);\n\n  // Get the normal of the reference edge in poly2's frame.\n  const normal1 = Rot.mulTVec2(xf2.q, Rot.mulVec2(xf1.q, normals1[edge1]));\n\n  // Find the incident edge on poly2.\n  let index = 0;\n  let minDot = Infinity;\n  for (let i = 0; i < count2; ++i) {\n    const dot = Vec2.dot(normal1, normals2[i]);\n    if (dot < minDot) {\n      minDot = dot;\n      index = i;\n    }\n  }\n\n  // Build the clip vertices for the incident edge.\n  const i1 = index;\n  const i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n\n  c[0].v = Transform.mulVec2(xf2, vertices2[i1]);\n  c[0].id.cf.indexA = edge1;\n  c[0].id.cf.indexB = i1;\n  c[0].id.cf.typeA = ContactFeatureType.e_face;\n  c[0].id.cf.typeB = ContactFeatureType.e_vertex;\n\n  c[1].v = Transform.mulVec2(xf2, vertices2[i2]);\n  c[1].id.cf.indexA = edge1;\n  c[1].id.cf.indexB = i2;\n  c[1].id.cf.typeA = ContactFeatureType.e_face;\n  c[1].id.cf.typeB = ContactFeatureType.e_vertex;\n}\n\nconst maxSeparation = {\n  maxSeparation: 0,\n  bestIndex: 0,\n};\n\n/**\n *\n * Find edge normal of max separation on A - return if separating axis is found<br>\n * Find edge normal of max separation on B - return if separation axis is found<br>\n * Choose reference edge as min(minA, minB)<br>\n * Find incident edge<br>\n * Clip\n *\n * The normal points from 1 to 2\n */\nexport function CollidePolygons(manifold: Manifold, polyA: PolygonShape, xfA: Transform, polyB: PolygonShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n  const totalRadius = polyA.m_radius + polyB.m_radius;\n\n  findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n  const edgeA = maxSeparation.bestIndex;\n  const separationA = maxSeparation.maxSeparation;\n  if (separationA > totalRadius)\n    return;\n\n  findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n  const edgeB = maxSeparation.bestIndex;\n  const separationB = maxSeparation.maxSeparation;\n  if (separationB > totalRadius)\n    return;\n\n  let poly1; // reference polygon\n  let poly2; // incident polygon\n  let xf1;\n  let xf2;\n  let edge1; // reference edge\n  let flip;\n  const k_tol = 0.1 * Settings.linearSlop;\n\n  if (separationB > separationA + k_tol) {\n    poly1 = polyB;\n    poly2 = polyA;\n    xf1 = xfB;\n    xf2 = xfA;\n    edge1 = edgeB;\n    manifold.type = ManifoldType.e_faceB;\n    flip = 1;\n  } else {\n    poly1 = polyA;\n    poly2 = polyB;\n    xf1 = xfA;\n    xf2 = xfB;\n    edge1 = edgeA;\n    manifold.type = ManifoldType.e_faceA;\n    flip = 0;\n  }\n\n  const incidentEdge = [ new ClipVertex(), new ClipVertex() ];\n  findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n\n  const count1 = poly1.m_count;\n  const vertices1 = poly1.m_vertices;\n\n  const iv1 = edge1;\n  const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n\n  let v11 = vertices1[iv1];\n  let v12 = vertices1[iv2];\n\n  const localTangent = Vec2.sub(v12, v11);\n  localTangent.normalize();\n\n  const localNormal = Vec2.crossVec2Num(localTangent, 1.0);\n  const planePoint = Vec2.combine(0.5, v11, 0.5, v12);\n\n  const tangent = Rot.mulVec2(xf1.q, localTangent);\n  const normal = Vec2.crossVec2Num(tangent, 1.0);\n\n  v11 = Transform.mulVec2(xf1, v11);\n  v12 = Transform.mulVec2(xf1, v12);\n\n  // Face offset.\n  const frontOffset = Vec2.dot(normal, v11);\n\n  // Side offsets, extended by polytope skin thickness.\n  const sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;\n  const sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;\n\n  // Clip incident edge against extruded edge1 side edges.\n  const clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\n  const clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\n  let np;\n\n  // Clip to box side 1\n  np = clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg(tangent), sideOffset1, iv1);\n\n  if (np < 2) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  np = clipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\n\n  if (np < 2) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  manifold.localNormal = localNormal;\n  manifold.localPoint = planePoint;\n\n  let pointCount = 0;\n  for (let i = 0; i < clipPoints2.length/* maxManifoldPoints */; ++i) {\n    const separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;\n\n    if (separation <= totalRadius) {\n      const cp = manifold.points[pointCount];\n      cp.localPoint.setVec2(Transform.mulTVec2(xf2, clipPoints2[i].v));\n      cp.id = clipPoints2[i].id;\n      if (flip) {\n        // Swap features\n        const cf = cp.id.cf;\n        const indexA = cf.indexA;\n        const indexB = cf.indexB;\n        const typeA = cf.typeA;\n        const typeB = cf.typeB;\n        cf.indexA = indexB;\n        cf.indexB = indexA;\n        cf.typeA = typeB;\n        cf.typeB = typeA;\n      }\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport Math from '../../common/Math';\nimport Transform from '../../common/Transform';\nimport Vec2 from '../../common/Vec2';\nimport Contact from '../../dynamics/Contact';\nimport CircleShape from './CircleShape';\nimport PolygonShape from './PolygonShape';\nimport Manifold, { ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport Fixture from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n\nfunction PolygonCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollidePolygonCircle(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\nexport function CollidePolygonCircle(manifold: Manifold, polygonA: PolygonShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  // Compute circle position in the frame of the polygon.\n  const c = Transform.mulVec2(xfB, circleB.m_p);\n  const cLocal = Transform.mulTVec2(xfA, c);\n\n  // Find the min separating edge.\n  let normalIndex = 0;\n  let separation = -Infinity;\n  const radius = polygonA.m_radius + circleB.m_radius;\n  const vertexCount = polygonA.m_count;\n  const vertices = polygonA.m_vertices;\n  const normals = polygonA.m_normals;\n\n  for (let i = 0; i < vertexCount; ++i) {\n    const s = Vec2.dot(normals[i], Vec2.sub(cLocal, vertices[i]));\n\n    if (s > radius) {\n      // Early out.\n      return;\n    }\n\n    if (s > separation) {\n      separation = s;\n      normalIndex = i;\n    }\n  }\n\n  // Vertices that subtend the incident face.\n  const vertIndex1 = normalIndex;\n  const vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n  const v1 = vertices[vertIndex1];\n  const v2 = vertices[vertIndex2];\n\n  // If the center is inside the polygon ...\n  if (separation < Math.EPSILON) {\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setVec2(normals[normalIndex]);\n    manifold.localPoint.setCombine(0.5, v1, 0.5, v2);\n    manifold.points[0].localPoint = circleB.m_p;\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n    return;\n  }\n\n  // Compute barycentric coordinates\n  const u1 = Vec2.dot(Vec2.sub(cLocal, v1), Vec2.sub(v2, v1));\n  const u2 = Vec2.dot(Vec2.sub(cLocal, v2), Vec2.sub(v1, v2));\n  if (u1 <= 0.0) {\n    if (Vec2.distanceSquared(cLocal, v1) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setCombine(1, cLocal, -1, v1);\n    manifold.localNormal.normalize();\n    manifold.localPoint = v1;\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n  } else if (u2 <= 0.0) {\n    if (Vec2.distanceSquared(cLocal, v2) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setCombine(1, cLocal, -1, v2);\n    manifold.localNormal.normalize();\n    manifold.localPoint.setVec2(v2);\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n  } else {\n    const faceCenter = Vec2.mid(v1, v2);\n    const separation = Vec2.dot(cLocal, normals[vertIndex1]) - Vec2.dot(faceCenter, normals[vertIndex1]);\n    if (separation > radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    manifold.localNormal.setVec2(normals[vertIndex1]);\n    manifold.localPoint.setVec2(faceCenter);\n    manifold.points[0].localPoint.setVec2(circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.cf.indexA = 0;\n    manifold.points[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    manifold.points[0].id.cf.indexB = 0;\n    manifold.points[0].id.cf.typeB = ContactFeatureType.e_vertex;\n  }\n}\n","/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport common from '../../util/common';\nimport Math from '../../common/Math';\nimport Transform from '../../common/Transform';\nimport Vec2 from '../../common/Vec2';\nimport Rot from '../../common/Rot';\nimport Settings from '../../Settings';\nimport Contact from '../../dynamics/Contact';\nimport Manifold, { clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport EdgeShape from './EdgeShape';\nimport ChainShape from './ChainShape';\nimport PolygonShape from './PolygonShape';\nimport Fixture from \"../../dynamics/Fixture\";\n\n\nconst _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\nContact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n\nfunction EdgePolygonContact(manifold: Manifold, xfA: Transform, fA: Fixture, indexA: number, xfB: Transform, fB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fA.getType() == EdgeShape.TYPE);\n  _ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);\n\n  CollideEdgePolygon(manifold, fA.getShape() as EdgeShape, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\nfunction ChainPolygonContact(manifold: Manifold, xfA: Transform, fA: Fixture, indexA: number, xfB: Transform, fB: Fixture, indexB: number): void {\n  _ASSERT && common.assert(fA.getType() == ChainShape.TYPE);\n  _ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);\n\n  const chain = fA.getShape() as ChainShape;\n  const edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n\n  CollideEdgePolygon(manifold, edge, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\nenum EPAxisType {\n  e_unknown = -1,\n  e_edgeA = 1,\n  e_edgeB = 2,\n}\n\n// unused?\nenum VertexType {\n e_isolated = 0,\n e_concave = 1,\n e_convex = 2,\n}\n\n/**\n * This structure is used to keep track of the best separating axis.\n */\nclass EPAxis {\n  type: EPAxisType;\n  index: number;\n  separation: number;\n}\n\n/**\n * This holds polygon B expressed in frame A.\n */\nclass TempPolygon {\n  vertices: Vec2[] = []; // [Settings.maxPolygonVertices]\n  normals: Vec2[] = []; // [Settings.maxPolygonVertices];\n  count: number = 0;\n}\n\n/**\n * Reference face used for clipping\n */\nclass ReferenceFace {\n  i1: number;\n  i2: number;\n  v1: Vec2;\n  v2: Vec2;\n  normal: Vec2 = Vec2.zero();\n  sideNormal1: Vec2 = Vec2.zero();\n  sideOffset1: number;\n  sideNormal2: Vec2 = Vec2.zero();\n  sideOffset2: number;\n}\n\n// reused\nconst edgeAxis = new EPAxis();\nconst polygonAxis = new EPAxis();\nconst polygonBA = new TempPolygon();\nconst rf = new ReferenceFace();\n\n/**\n * This function collides and edge and a polygon, taking into account edge\n * adjacency.\n */\nexport function CollideEdgePolygon(manifold: Manifold, edgeA: EdgeShape, xfA: Transform, polygonB: PolygonShape, xfB: Transform): void {\n  // Algorithm:\n  // 1. Classify v1 and v2\n  // 2. Classify polygon centroid as front or back\n  // 3. Flip normal if necessary\n  // 4. Initialize normal range to [-pi, pi] about face normal\n  // 5. Adjust normal range according to adjacent edges\n  // 6. Visit each separating axes, only accept axes within the range\n  // 7. Return if _any_ axis indicates separation\n  // 8. Clip\n\n  // let m_type1: VertexType;\n  // let m_type2: VertexType;\n\n  const xf = Transform.mulTXf(xfA, xfB);\n\n  const centroidB = Transform.mulVec2(xf, polygonB.m_centroid);\n\n  const v0 = edgeA.m_vertex0;\n  const v1 = edgeA.m_vertex1;\n  const v2 = edgeA.m_vertex2;\n  const v3 = edgeA.m_vertex3;\n\n  const hasVertex0 = edgeA.m_hasVertex0;\n  const hasVertex3 = edgeA.m_hasVertex3;\n\n  const edge1 = Vec2.sub(v2, v1);\n  edge1.normalize();\n  const normal1 = Vec2.neo(edge1.y, -edge1.x);\n  const offset1 = Vec2.dot(normal1, Vec2.sub(centroidB, v1));\n  let offset0 = 0.0;\n  let offset2 = 0.0;\n  let convex1 = false;\n  let convex2 = false;\n\n  let normal0;\n  let normal2;\n\n  // Is there a preceding edge?\n  if (hasVertex0) {\n    const edge0 = Vec2.sub(v1, v0);\n    edge0.normalize();\n    normal0 = Vec2.neo(edge0.y, -edge0.x);\n    convex1 = Vec2.crossVec2Vec2(edge0, edge1) >= 0.0;\n    offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n  }\n\n  // Is there a following edge?\n  if (hasVertex3) {\n    const edge2 = Vec2.sub(v3, v2);\n    edge2.normalize();\n    normal2 = Vec2.neo(edge2.y, -edge2.x);\n    convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n    offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n  }\n\n  let front;\n  const normal = Vec2.zero();\n  const lowerLimit = Vec2.zero();\n  const upperLimit = Vec2.zero();\n\n  // Determine front or back collision. Determine collision normal limits.\n  if (hasVertex0 && hasVertex3) {\n    if (convex1 && convex2) {\n      front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal0);\n        upperLimit.setVec2(normal2);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setMul(-1, normal1);\n      }\n    } else if (convex1) {\n      front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal0);\n        upperLimit.setVec2(normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal2);\n        upperLimit.setMul(-1, normal1);\n      }\n    } else if (convex2) {\n      front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setVec2(normal2);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setMul(-1, normal0);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setVec2(normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal2);\n        upperLimit.setMul(-1, normal0);\n      }\n    }\n  } else if (hasVertex0) {\n    if (convex1) {\n      front = offset0 >= 0.0 || offset1 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal0);\n        upperLimit.setMul(-1, normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setMul(-1, normal1);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setMul(-1, normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setVec2(normal1);\n        upperLimit.setMul(-1, normal0);\n      }\n    }\n  } else if (hasVertex3) {\n    if (convex2) {\n      front = offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setVec2(normal2);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setVec2(normal1);\n      }\n    } else {\n      front = offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        normal.setVec2(normal1);\n        lowerLimit.setMul(-1, normal1);\n        upperLimit.setVec2(normal1);\n      } else {\n        normal.setMul(-1, normal1);\n        lowerLimit.setMul(-1, normal2);\n        upperLimit.setVec2(normal1);\n      }\n    }\n  } else {\n    front = offset1 >= 0.0;\n    if (front) {\n      normal.setVec2(normal1);\n      lowerLimit.setMul(-1, normal1);\n      upperLimit.setMul(-1, normal1);\n    } else {\n      normal.setMul(-1, normal1);\n      lowerLimit.setVec2(normal1);\n      upperLimit.setVec2(normal1);\n    }\n  }\n\n  // Get polygonB in frameA\n  polygonBA.count = polygonB.m_count;\n  for (let i = 0; i < polygonB.m_count; ++i) {\n    polygonBA.vertices[i] = Transform.mulVec2(xf, polygonB.m_vertices[i]);\n    polygonBA.normals[i] = Rot.mulVec2(xf.q, polygonB.m_normals[i]);\n  }\n\n  const radius = 2.0 * Settings.polygonRadius;\n\n  manifold.pointCount = 0;\n\n  { // ComputeEdgeSeparation\n    edgeAxis.type = EPAxisType.e_edgeA;\n    edgeAxis.index = front ? 0 : 1;\n    edgeAxis.separation = Infinity;\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      const s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1));\n      if (s < edgeAxis.separation) {\n        edgeAxis.separation = s;\n      }\n    }\n  }\n\n  // If no valid normal can be found than this edge should not collide.\n  // @ts-ignore\n  if (edgeAxis.type == EPAxisType.e_unknown) {\n    return;\n  }\n\n  if (edgeAxis.separation > radius) {\n    return;\n  }\n\n  { // ComputePolygonSeparation\n    polygonAxis.type = EPAxisType.e_unknown;\n    polygonAxis.index = -1;\n    polygonAxis.separation = -Infinity;\n\n    const perp = Vec2.neo(-normal.y, normal.x);\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      const n = Vec2.neg(polygonBA.normals[i]);\n\n      const s1 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v1));\n      const s2 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v2));\n      const s = Math.min(s1, s2);\n\n      if (s > radius) {\n        // No collision\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n        break;\n      }\n\n      // Adjacency\n      if (Vec2.dot(n, perp) >= 0.0) {\n        if (Vec2.dot(Vec2.sub(n, upperLimit), normal) < -Settings.angularSlop) {\n          continue;\n        }\n      } else {\n        if (Vec2.dot(Vec2.sub(n, lowerLimit), normal) < -Settings.angularSlop) {\n          continue;\n        }\n      }\n\n      if (s > polygonAxis.separation) {\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n      }\n    }\n  }\n\n  if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n    return;\n  }\n\n  // Use hysteresis for jitter reduction.\n  const k_relativeTol = 0.98;\n  const k_absoluteTol = 0.001;\n\n  let primaryAxis;\n  if (polygonAxis.type == EPAxisType.e_unknown) {\n    primaryAxis = edgeAxis;\n  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n    primaryAxis = polygonAxis;\n  } else {\n    primaryAxis = edgeAxis;\n  }\n\n  const ie = [ new ClipVertex(), new ClipVertex() ];\n\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.type = ManifoldType.e_faceA;\n\n    // Search for the polygon normal that is most anti-parallel to the edge\n    // normal.\n    let bestIndex = 0;\n    let bestValue = Vec2.dot(normal, polygonBA.normals[0]);\n    for (let i = 1; i < polygonBA.count; ++i) {\n      const value = Vec2.dot(normal, polygonBA.normals[i]);\n      if (value < bestValue) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n\n    const i1 = bestIndex;\n    const i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n\n    ie[0].v = polygonBA.vertices[i1];\n    ie[0].id.cf.indexA = 0;\n    ie[0].id.cf.indexB = i1;\n    ie[0].id.cf.typeA = ContactFeatureType.e_face;\n    ie[0].id.cf.typeB = ContactFeatureType.e_vertex;\n\n    ie[1].v = polygonBA.vertices[i2];\n    ie[1].id.cf.indexA = 0;\n    ie[1].id.cf.indexB = i2;\n    ie[1].id.cf.typeA = ContactFeatureType.e_face;\n    ie[1].id.cf.typeB = ContactFeatureType.e_vertex;\n\n    if (front) {\n      rf.i1 = 0;\n      rf.i2 = 1;\n      rf.v1 = v1;\n      rf.v2 = v2;\n      rf.normal.setVec2(normal1);\n    } else {\n      rf.i1 = 1;\n      rf.i2 = 0;\n      rf.v1 = v2;\n      rf.v2 = v1;\n      rf.normal.setMul(-1, normal1);\n    }\n  } else {\n    manifold.type = ManifoldType.e_faceB;\n\n    ie[0].v = v1;\n    ie[0].id.cf.indexA = 0;\n    ie[0].id.cf.indexB = primaryAxis.index;\n    ie[0].id.cf.typeA = ContactFeatureType.e_vertex;\n    ie[0].id.cf.typeB = ContactFeatureType.e_face;\n\n    ie[1].v = v2;\n    ie[1].id.cf.indexA = 0;\n    ie[1].id.cf.indexB = primaryAxis.index;\n    ie[1].id.cf.typeA = ContactFeatureType.e_vertex;\n    ie[1].id.cf.typeB = ContactFeatureType.e_face;\n\n    rf.i1 = primaryAxis.index;\n    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n    rf.v1 = polygonBA.vertices[rf.i1];\n    rf.v2 = polygonBA.vertices[rf.i2];\n    rf.normal.setVec2(polygonBA.normals[rf.i1]);\n  }\n\n  rf.sideNormal1.setNum(rf.normal.y, -rf.normal.x);\n  rf.sideNormal2.setMul(-1, rf.sideNormal1);\n  rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);\n  rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);\n\n  // Clip incident edge against extruded edge1 side edges.\n  const clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\n  const clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\n\n  let np;\n\n  // Clip to box side 1\n  np = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n\n  if (np < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  np = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n\n  if (np < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.localNormal = Vec2.clone(rf.normal);\n    manifold.localPoint = Vec2.clone(rf.v1);\n  } else {\n    manifold.localNormal = Vec2.clone(polygonB.m_normals[rf.i1]);\n    manifold.localPoint = Vec2.clone(polygonB.m_vertices[rf.i1]);\n  }\n\n  let pointCount = 0;\n  for (let i = 0; i < Settings.maxManifoldPoints; ++i) {\n    const separation = Vec2.dot(rf.normal, Vec2.sub(clipPoints2[i].v, rf.v1));\n\n    if (separation <= radius) {\n      const cp = manifold.points[pointCount]; // ManifoldPoint\n\n      if (primaryAxis.type == EPAxisType.e_edgeA) {\n        cp.localPoint = Transform.mulTVec2(xf, clipPoints2[i].v);\n        cp.id = clipPoints2[i].id;\n      } else {\n        cp.localPoint = clipPoints2[i].v;\n        cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\n        cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\n        cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\n        cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\n      }\n\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n","export { default as Serializer } from './serializer/index';\n\nexport { default as Math } from './common/Math';\nexport { default as Vec2 } from './common/Vec2';\nexport { default as Vec3 } from './common/Vec3';\nexport { default as Mat22 } from './common/Mat22';\nexport { default as Mat33 } from './common/Mat33';\nexport { default as Transform } from './common/Transform';\nexport { default as Rot } from './common/Rot';\n\nexport { default as AABB } from './collision/AABB';\n\nexport { default as Shape } from './collision/Shape';\nexport { default as Fixture } from './dynamics/Fixture';\nexport { default as Body } from './dynamics/Body';\nexport { default as Contact } from './dynamics/Contact';\nexport { default as Joint } from './dynamics/Joint';\nexport { default as World } from './dynamics/World';\n\nexport { default as Circle } from './collision/shape/CircleShape';\nexport { default as Edge } from './collision/shape/EdgeShape';\nexport { default as Polygon } from './collision/shape/PolygonShape';\nexport { default as Chain } from './collision/shape/ChainShape';\nexport { default as Box } from './collision/shape/BoxShape';\n\nexport { CollideCircles } from './collision/shape/CollideCircle';\nexport { CollideEdgeCircle } from './collision/shape/CollideEdgeCircle';\nexport { CollidePolygons } from './collision/shape/CollidePolygon';\nexport { CollidePolygonCircle } from './collision/shape/CollideCirclePolygone';\nexport { CollideEdgePolygon } from './collision/shape/CollideEdgePolygon';\n\nexport { default as DistanceJoint } from './dynamics/joint/DistanceJoint';\nexport { default as FrictionJoint } from './dynamics/joint/FrictionJoint';\nexport { default as GearJoint } from './dynamics/joint/GearJoint';\nexport { default as MotorJoint } from './dynamics/joint/MotorJoint';\nexport { default as MouseJoint } from './dynamics/joint/MouseJoint';\nexport { default as PrismaticJoint } from './dynamics/joint/PrismaticJoint';\nexport { default as PulleyJoint } from './dynamics/joint/PulleyJoint';\nexport { default as RevoluteJoint } from './dynamics/joint/RevoluteJoint';\nexport { default as RopeJoint } from './dynamics/joint/RopeJoint';\nexport { default as WeldJoint } from './dynamics/joint/WeldJoint';\nexport { default as WheelJoint } from './dynamics/joint/WheelJoint';\n\nexport { default as Settings } from './Settings';\n\nexport { default as Sweep } from './common/Sweep';\nexport { default as Manifold } from './collision/Manifold';\nexport { default as Distance } from './collision/Distance';\nexport { default as TimeOfImpact } from './collision/TimeOfImpact';\nexport { default as DynamicTree } from './collision/DynamicTree';\n\nimport Solver, { TimeStep } from './dynamics/Solver';\nimport { CollidePolygons } from './collision/shape/CollidePolygon';\nimport { default as Settings } from './Settings';\nimport { default as Sweep } from './common/Sweep';\nimport { default as Manifold } from './collision/Manifold';\nimport { default as Distance, DistanceInput, DistanceOutput, DistanceProxy, SimplexCache, testOverlap } from './collision/Distance';\nimport { default as TimeOfImpact, TOIInput, TOIOutput } from './collision/TimeOfImpact';\nimport { default as DynamicTree } from './collision/DynamicTree';\n\nimport { default as stats } from './util/stats'; // todo: what to do with this?\n\nimport { ContactImpulse } from './dynamics/Solver';\ntype _ContactImpulse = InstanceType<typeof ContactImpulse>;\nexport type { _ContactImpulse as ContactImpulse }\n\n/** @deprecated Merged with main namespace */\nexport const internal = {};\n\n// @ts-ignore\ninternal.CollidePolygons = CollidePolygons;\n// @ts-ignore\ninternal.Settings = Settings;\n// @ts-ignore\ninternal.Sweep = Sweep;\n// @ts-ignore\ninternal.Manifold = Manifold;\n// @ts-ignore\ninternal.Distance = Distance;\n// @ts-ignore\ninternal.TimeOfImpact = TimeOfImpact;\n// @ts-ignore\ninternal.DynamicTree = DynamicTree;\n// @ts-ignore\ninternal.stats = stats;\n\n// @ts-ignore\nSolver.TimeStep = TimeStep;\n\n// @ts-ignore\nDistance.testOverlap = testOverlap;\n// @ts-ignore\nDistance.Input = DistanceInput;\n// @ts-ignore\nDistance.Output = DistanceOutput;\n// @ts-ignore\nDistance.Proxy = DistanceProxy;\n// @ts-ignore\nDistance.Cache = SimplexCache;\n\n// @ts-ignore\nTimeOfImpact.Input = TOIInput;\n// @ts-ignore\nTimeOfImpact.Output = TOIOutput;\n","import * as planck from 'planck';\nimport {Skills, STUCK_DELAY} from './data/constants';\nimport {rad} from './utils/utils';\nimport options from './options';\nimport {Vec2} from 'planck';\n\nexport class Marble {\n    type: 'marble' = 'marble';\n    name: string = '';\n    size: number = 0.5;\n    color: string = 'red';\n    hue: number = 0;\n    impact: number = 0;\n    weight: number = 1;\n    skill: Skills = Skills.None;\n\n    private _skillRate = 0.0005;\n    private _coolTime = 5000;\n    private _maxCoolTime = 5000;\n    private _stuckTime = 0;\n    private lastPosition: Vec2 = Vec2(0, 0);\n\n    get position() {\n        return this.body.getPosition();\n    }\n\n    get x() {\n        return this.position.x;\n    }\n\n    set x(v: number) {\n        this.position.x = v;\n    }\n\n    get y() {\n        return this.position.y;\n    }\n\n    set y(v: number) {\n        this.position.y = v;\n    }\n\n    body: planck.Body;\n\n    constructor(world: planck.World, order: number, max: number, name?: string, weight: number = 1) {\n        this.name = name || `M${order}`;\n        this.body = world.createBody({\n            type: 'dynamic',\n            allowSleep: false,\n            awake: true,\n            active: false,\n            linearDamping: 0,\n            angularDamping: 0.01,\n            linearVelocity: new planck.Vec2(0, 0.0),\n        });\n\n        this.weight = weight;\n\n        this._maxCoolTime = 1000 + ((1-this.weight) * 4000);\n        this._coolTime = this._maxCoolTime * Math.random();\n        this._skillRate = 0.2 * this.weight;\n\n        const maxLine = Math.ceil(max / 10);\n        const line = Math.floor(order / 10);\n        const lineDelta = -Math.max(0, Math.ceil(maxLine - 5));\n        this.hue = 360 / max * order;\n        this.color = `hsl(${this.hue} 100% 70%)`;\n\n        const circle = planck.Circle(new planck.Vec2(0, 0), this.size / 2);\n        this.body.createFixture({shape: circle, density: Math.random() + 1, restitution: 0.2});\n        this.body.setPosition(new planck.Vec2(10.25 + ((order % 10) * 0.6), maxLine - line + lineDelta));\n        this.body.setUserData(this);\n    }\n\n    update(deltaTime: number) {\n        if (this.body.isActive() && this.lastPosition.sub(this.position).length() < 0.001) {\n            this._stuckTime += deltaTime;\n\n            if (this._stuckTime > STUCK_DELAY) {\n                this.body.applyForceToCenter(Vec2(Math.random() * 10 - 5, Math.random() * 10 - 5), true);\n            }\n        } else {\n            this._stuckTime = 0;\n        }\n        this.lastPosition = this.position.clone();\n\n        this.skill = Skills.None;\n        if (this.impact) {\n            this.impact = Math.max(0, this.impact - deltaTime);\n        }\n        if (!this.body.isActive()) return;\n        if (options.useSkills) {\n            this._updateSkillInformation(deltaTime);\n        }\n    }\n\n    private _updateSkillInformation(deltaTime: number) {\n        if (this._coolTime > 0) {\n            this._coolTime -= deltaTime;\n        }\n\n        if (this._coolTime <= 0 ) {\n            this.skill = Math.random() < this._skillRate ? Skills.Impact : Skills.None;\n            this._coolTime = this._maxCoolTime;\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D, zoom: number, outline: boolean, isMinimap: boolean = false) {\n        ctx.save();\n        if (isMinimap) {\n            this._renderMinimap(ctx);\n        } else {\n            this._renderNormal(ctx, zoom, outline)\n        }\n        ctx.restore();\n    }\n\n    private _renderMinimap(ctx: CanvasRenderingContext2D) {\n        ctx.fillStyle = this.color;\n        this._drawMarbleBody(ctx, true);\n    }\n\n    private _drawMarbleBody(ctx: CanvasRenderingContext2D, isMinimap: boolean) {\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, isMinimap ? this.size : this.size / 2, 0, Math.PI * 2);\n        ctx.fill();\n    }\n\n    private _renderNormal(ctx: CanvasRenderingContext2D, zoom: number, outline: boolean) {\n        ctx.shadowColor = this.color;\n        ctx.shadowBlur = zoom / 2;\n        ctx.fillStyle = `hsl(${this.hue} 100% ${70 + (25 * Math.min(1, this.impact / 500))}%`;\n\n        this._drawMarbleBody(ctx, false);\n        this._drawName(ctx, zoom);\n\n        if (outline) {\n            this._drawOutline(ctx, 2 / zoom);\n        }\n\n        if (options.useSkills) {\n            this._renderCooltime(ctx, zoom);\n        }\n    }\n\n    private _drawName(ctx: CanvasRenderingContext2D, zoom: number) {\n        ctx.save();\n        ctx.translate(this.x, this.y+0.25);\n        ctx.scale(1/zoom, 1/zoom);\n        ctx.font = `12pt sans-serif`;\n        ctx.strokeStyle = 'black';\n        ctx.lineWidth = 2;\n        ctx.fillStyle = this.color;\n        ctx.shadowBlur = 0;\n        ctx.strokeText(this.name, 0, 0);\n        ctx.fillText(this.name, 0, 0);\n        ctx.restore();\n    }\n\n    private _drawOutline(ctx: CanvasRenderingContext2D, lineWidth: number) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = lineWidth;\n        ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.restore();\n    }\n\n    private _renderCooltime(ctx: CanvasRenderingContext2D, zoom: number) {\n        ctx.strokeStyle = 'red';\n        ctx.lineWidth = 1 / zoom;\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, this.size / 2 + (2 / zoom), rad(270), rad(270 + 360 * this._coolTime / this._maxCoolTime));\n        ctx.stroke();\n    }\n}\n","export const initialZoom = 30;\nexport const canvasWidth = 1600;\nexport const canvasHeight = 900;\nexport const zoomThreshold = 5;\nexport const STUCK_DELAY = 1000;\n\nexport enum Skills {\n    None,\n    Impact,\n}\n","import * as planck from 'planck';\nimport {Vec2} from 'planck';\n\nexport function createMover(world: planck.World, pos: planck.Vec2, power: number, center?: planck.Vec2, size?: number) {\n    const mover = world.createKinematicBody({position: pos });\n    mover.createFixture({\n        shape: new planck.Box(size ? size : 2, 0.1, center ? center : new planck.Vec2()),\n        restitution: 0.7,\n    });\n    mover.setAngularVelocity(power);\n    return mover;\n}\n\nexport function createJumper(world: planck.World, pos: planck.Vec2, size: number, isTemporary: boolean = false) {\n    const jumper = world.createBody({ position: pos });\n    jumper.createFixture({\n        shape: new planck.Circle(new Vec2(), size),\n        restitution: 1.5,\n    });\n    jumper.setUserData({ isTemporary });\n    return jumper;\n}\n\nexport function createBox(world: planck.World, pos: planck.Vec2, rotation: number, width: number = 0.5, height: number = 0.25) {\n    const boxBody = world.createBody({\n        type: 'static',\n        position: pos,\n    });\n\n    boxBody.createFixture({\n        shape: new planck.Box(width, height),\n    });\n\n    boxBody.setAngle(rotation);\n    return boxBody;\n}\n\nexport function rad(degree: number) {\n    return Math.PI * degree / 180;\n}\n\nfunction getRegexValue(regex: RegExp, str: string) {\n    const result = regex.exec(str);\n    return result ? result[1] : '';\n}\n\nexport function parseName(nameStr: string) {\n    const weightRegex = /(\\/\\d+)/;\n    const countRegex = /(\\*\\d+)/;\n    const hasWeight = weightRegex.test(nameStr);\n    const hasCount = countRegex.test(nameStr);\n    const name = getRegexValue(/^\\s*([^\\/*]+)?/, nameStr);\n    if (!name) return null;\n    const weight = hasWeight ? parseInt(getRegexValue(weightRegex, nameStr).replace('/', '')) : 1;\n    const count = hasCount ? parseInt(getRegexValue(countRegex, nameStr).replace('*', '')) : 1;\n    return {\n        name,\n        weight,\n        count,\n    };\n}\n\nexport function pad(v: number) {\n    return v.toString().padStart(2, '0');\n}\n","class Options {\n    useSkills: boolean = true;\n    winningRank: number = 0;\n    autoRecording: boolean = true;\n}\n\nconst options = new Options();\nexport default options;\n","import {Particle} from './particle';\n\nexport class ParticleManager {\n    private _particles: Particle[] = [];\n\n    update(deltaTime: number) {\n        this._particles.forEach(particle => {\n            particle.update(deltaTime);\n        });\n        this._particles = this._particles.filter(particle => !particle.isDestroy);\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        this._particles.forEach(particle => particle.render(ctx));\n    }\n\n    shot(x: number, y: number) {\n        for (let i = 0; i < 200; i++) {\n            this._particles.push(new Particle(x, y));\n        }\n    }\n}\n","import * as planck from 'planck';\nimport {rad} from './utils/utils';\n\nconst lifetime = 3000;\n\nexport class Particle {\n    private _elapsed: number = 0;\n    position: planck.Vec2 = new planck.Vec2();\n    force: planck.Vec2 = new planck.Vec2();\n    color: string = '';\n    isDestroy: boolean = false;\n\n    constructor(x: number, y: number) {\n        this.position = new planck.Vec2(x, y);\n\n        const force = Math.random() * 250;\n        const ang = rad((90 * Math.random()) - 180);\n        const fx = Math.cos(ang) * force;\n        const fy = Math.sin(ang) * force;\n        this.color = `hsl(${Math.random() * 360} 50% 50%)`;\n        this.force.set(fx, fy);\n    }\n\n    update(deltaTime: number) {\n        this._elapsed += deltaTime;\n        const delta = this.force.clone().mul(deltaTime / 100);\n        this.position.add(delta);\n        this.force.y += 10 * deltaTime / 100;\n        if (this._elapsed > lifetime) {\n            this.isDestroy = true;\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        ctx.globalAlpha = 1 - Math.pow(this._elapsed / lifetime, 2);\n        ctx.fillStyle = this.color;\n        ctx.fillRect(this.position.x, this.position.y, 20, 20);\n        ctx.restore();\n    }\n}\n","import {rad} from '../utils/utils';\n\ntype WallDef = [x: number, y: number];\ntype BoxDef = [x: number, y: number, angle: number, width: number, height: number];\ntype WheelDef = [x: number, y: number, power: number, centerX?: number, centerY?: number, size?: number];\ntype JumperDef = [x: number, y: number, size: number, temporary?: boolean];\n\nexport type StageDef = {\n    title: string;\n    walls: WallDef[][];\n    boxes: BoxDef[];\n    wheels: WheelDef[];\n    jumpers?: JumperDef[];\n    goalY: number;\n    zoomY: number;\n}\n\nexport const stages: StageDef[] = [\n    {\n        title: 'Wheel of fortune',\n        goalY: 111,\n        zoomY: 106.75,\n        walls: [\n            [\n                [16.5, -300],\n                [9.25, -300],\n                [9.25, 8.5],\n                [2, 19.25],\n                [2, 26],\n                [9.75, 30],\n                [9.75, 33.5],\n                [1.25, 41],\n                [1.25, 53.75],\n                [8.25, 58.75],\n                [8.25, 63],\n                [9.25, 64],\n                [8.25, 65],\n                [8.25, 99.25],\n                [15.1, 106.75],\n                [15.1, 111.75]\n            ],\n\n            [\n                [16.5, -300],\n                [16.5, 9.25],\n                [9.5, 20],\n                [9.5, 22.5],\n                [17.5, 26],\n                [17.5, 33.5],\n                [24, 38.5],\n                [19, 45.5],\n                [19, 55.5],\n                [24, 59.25],\n                [24, 63],\n                [23, 64],\n                [24, 65],\n                [24, 100.5],\n                [16, 106.75],\n                [16, 111.75]\n            ],\n            [\n                [12.75, 37.5],\n                [7, 43.5],\n                [7, 49.75],\n                [12.75, 53.75],\n                [12.75, 37.5]\n            ],\n            [\n                [14.75, 37.5],\n                [14.75, 43],\n                [17.5, 40.25],\n                [14.75, 37.5]\n            ]\n        ],\n        boxes: [\n            // x, y, angle, width, height\n            [15.5, 30.0, -45, 0.2, 0.2],\n            [15.5, 32.0, -45, 0.2, 0.2],\n            [15.5, 28.0, -45, 0.2, 0.2],\n            [12.5, 30.0, -45, 0.2, 0.2],\n            [12.5, 32.0, -45, 0.2, 0.2],\n            [12.5, 28.0, -45, 0.2, 0.2],\n\n            [9.4, 66.6, 45, 0.6, 0.1],\n            [11.3, 66.6, 45, 0.6, 0.1],\n            [13.2, 66.6, 45, 0.6, 0.1],\n            [15.1, 66.6, 45, 0.6, 0.1],\n            [17, 66.6, 45, 0.6, 0.1],\n            [18.9, 66.6, 45, 0.6, 0.1],\n            [20.699999999999997, 66.6, 45, 0.6, 0.1],\n            [22.7, 66.6, 45, 0.6, 0.1],\n\n            [9.4, 69.1, -45, 0.6, 0.1],\n            [11.3, 69.1, -45, 0.6, 0.1],\n            [13.2, 69.1, -45, 0.6, 0.1],\n            [15.1, 69.1, -45, 0.6, 0.1],\n            [17, 69.1, -45, 0.6, 0.1],\n            [18.9, 69.1, -45, 0.6, 0.1],\n            [20.699999999999997, 69.1, -45, 0.6, 0.1],\n            [22.7, 69.1, -45, 0.6, 0.1],\n\n            [9.5, 92, rad(45), 0.25, 0.25],\n            [12.75, 92, rad(45), 0.25, 0.25],\n            [16, 92, rad(45), 0.25, 0.25],\n            [19.25, 92, rad(45), 0.25, 0.25],\n            [22.5, 92, rad(45), 0.25, 0.25],\n\n            [11, 95, rad(45), 0.25, 0.25],\n            [14.25, 95, rad(45), 0.25, 0.25],\n            [17.5, 95, rad(45), 0.25, 0.25],\n            [20.75, 95, rad(45), 0.25, 0.25],\n\n            [9.5, 98, rad(45), 0.25, 0.25],\n            [12.75, 98, rad(45), 0.25, 0.25],\n            [16, 98, rad(45), 0.25, 0.25],\n            [19.25, 98, rad(45), 0.25, 0.25],\n            [22.5, 98, rad(45), 0.25, 0.25],\n\n        ],\n        wheels: [\n            // x, y, power, centerx, centery\n            [8, 75, 3.5],\n            [12, 75, -3.5],\n            [16, 75, 3.5],\n            [20, 75, -3.5],\n            [24, 75, 3.5],\n\n            [14.0, 106.75, -1.2],\n        ]\n    },\n    {\n        title: 'BubblePop',\n        goalY: 83,\n        zoomY: 78,\n        walls: [\n            [ // left\n                [16.5, -300],\n                [9.25, -300],\n                [9.25, 0],\n                [9.25, 43],\n                [4.25, 50],\n                [9.25, 53],\n                [9.25, 75],\n                [12, 80],\n                [12, 83],\n            ],\n            [ // right\n                [16.5, -300],\n                [16.5, 50],\n                [19.5, 54],\n                [18.5, 56],\n                [19.5, 58],\n                [16.5, 61],\n                [16.5, 75],\n                [13, 80],\n                [13, 83],\n            ],\n            [\n                [16.5, 52.5],\n                [17.5, 54],\n                [16.5, 56],\n                [17.5, 58],\n                [16.5, 59],\n                [15.5, 56],\n                [16.5, 52.5],\n            ],\n            [\n                [9.25, 45.5],\n                [6.25, 49.5],\n                [9.25, 51],\n                [14.5, 50.5],\n                [9.25, 45.5],\n            ],\n            [\n                [9.25, 26], [11.0625, 27.5]\n            ],\n            [\n                [16.5, 26], [14.6875, 27.5]\n            ],\n            [\n                [11.0625, 30], [12.875, 28.5], [14.6875, 30]\n            ],\n            [\n                [9.25, 31], [11.0625, 32.5]\n            ],\n            [\n                [16.5, 31], [14.6875, 32.5]\n            ],\n            [\n                [11.0625, 35], [12.875, 33.5], [14.6875, 35]\n            ],\n\n        ],\n        wheels: [\n            [10.7, 10, 10, 0, 0, 0.5],\n            [14.7, 10, -10, 0, 0, 0.5],\n            [12.7, 10, 10, 0, 0, 0.5],\n\n            [10.7, 14, -3],\n            [14.7, 14, 3],\n\n            [11.20, 44, -5, 0, 0, 0.5],\n\n            [10.3, 75, 8, 0, 0, 1],\n            [15.2, 75, -8, 0, 0, 1],\n\n            // [12.175, 80, 2.5, 0, 0, 0.75],\n        ],\n        boxes: [\n            // x, y, angle, width, height\n            [9.25, 18, rad(45), 0.15, 0.15],\n            [11.25, 18, rad(45), 0.15, 0.15],\n            [13.25, 18, rad(45), 0.15, 0.15],\n            [15.25, 18, rad(45), 0.15, 0.15],\n\n            [10.5, 19, rad(45), 0.15, 0.15],\n            [12.5, 19, rad(45), 0.15, 0.15],\n            [14.5, 19, rad(45), 0.15, 0.15],\n            [16.5, 19, rad(45), 0.15, 0.15],\n\n            [9.25, 20, rad(45), 0.15, 0.15],\n            [11.25, 20, rad(45), 0.15, 0.15],\n            [13.25, 20, rad(45), 0.15, 0.15],\n            [15.25, 20, rad(45), 0.15, 0.15],\n\n            [10.5, 21, rad(45), 0.15, 0.15],\n            [12.5, 21, rad(45), 0.15, 0.15],\n            [14.5, 21, rad(45), 0.15, 0.15],\n            [16.5, 21, rad(45), 0.15, 0.15],\n\n            [9.25, 22, rad(45), 0.15, 0.15],\n            [11.25, 22, rad(45), 0.15, 0.15],\n            [13.25, 22, rad(45), 0.15, 0.15],\n            [15.25, 22, rad(45), 0.15, 0.15],\n\n            [10.5, 23, rad(45), 0.15, 0.15],\n            [12.5, 23, rad(45), 0.15, 0.15],\n            [14.5, 23, rad(45), 0.15, 0.15],\n            [16.5, 23, rad(45), 0.15, 0.15],\n\n            [9.4, 39, rad(45), 3, 3],\n            [16.5, 43, rad(45), 3, 3],\n        ],\n        jumpers: [\n            [11, 65, 0.5, true],\n            [13, 65, 0.5, true],\n            [15, 65, 0.5, true],\n\n            [12, 67.5, 0.5, true],\n            [14, 67.5, 0.5, true],\n\n            [13, 71, 0.8, true],\n\n            [10.7, 77.5, 0.8, true],\n            [14.7, 77.5, 0.8, true],\n\n            [12.625, 80, 1.5, true],\n            [12.625, 80, 1.2, true],\n        ]\n    },\n    {\n        title: 'Pot of greed',\n        goalY: 111,\n        zoomY: 110,\n        walls: [\n            [\n                [17, -300],\n                [9, -300],\n                [9, 8.5],\n                [2, 15],\n                [6, 61.5],\n            ],\n            [\n                [7, 71],\n                [9, 101],\n                [8, 100.5],\n                [6, 100],\n                [5, 90],\n                [4, 70],\n                [7, 71],\n            ],\n            [\n                [17, -300],\n                [17, 8.5],\n                [24, 15],\n                [20, 61.5],\n            ],\n            [\n                [19, 71],\n                [17, 101],\n                [18, 100.5],\n                [20, 100],\n                [21, 90],\n                [22, 70],\n                [19, 71],\n            ],\n            [\n                [11, 88],\n                [12, 90],\n                [12, 112],\n            ],\n            [\n                [15, 88],\n                [14, 90],\n                [14, 112],\n            ],\n            [\n                [12, 102],\n                [11, 103],\n                [9, 104],\n                [8, 104],\n                [6, 103],\n                [5, 102],\n                [4, 100],\n                [3, 90],\n                [2, 70],\n                [3, 65],\n                [4, 63],\n                [5, 62],\n                [6, 61.5],\n            ],\n            [\n                [14, 102],\n                [15, 103],\n                [17, 104],\n                [18, 104],\n                [20, 103],\n                [21, 102],\n                [22, 100],\n                [23, 90],\n                [24, 70],\n                [23, 65],\n                [22, 63],\n                [21, 62],\n                [20, 61.5],\n            ],\n        ],\n        boxes: [\n            // x, y, angle, width, height\n            [13, 20, rad(45), 3, 3],\n            [13, 55, rad(45), 3, 3],\n\n            [8, 37, rad(45), 2, 2],\n            [18, 37, rad(45), 2, 2],\n        ],\n        jumpers: [],\n        wheels: [\n            [11, 12, -3],\n            [15, 12, 3],\n\n            [   8, 104, -10, 0, 0, 1],\n            [   6, 103, -10, 0, 0, 1.5],\n            [   4, 100, -10, 0, 0, 1.5],\n            [ 3.5,  95, -10],\n            [   3,  90, -10],\n            [2.75,  85, -10],\n            [ 2.5,  80, -10],\n            [2.25,  75, -10],\n            [   2,  70, -10],\n\n            [  18, 104, 10, 0, 0, 1],\n            [  20, 103, 10, 0, 0, 1.5],\n            [  22, 100, 10, 0, 0, 1.5],\n            [22.5,  95, 10],\n            [  23,  90, 10],\n            [23.25,  85, 10],\n            [23.5,  80, 10],\n            [23.75,  75, 10],\n            [  24,  70, 10],\n        ],\n    },\n\n];\n","import {Marble} from './marble';\nimport {StageDef} from './data/maps';\nimport {Vec2} from 'planck';\nimport {initialZoom, zoomThreshold} from './data/constants';\n\nexport class Camera {\n    private _position: Vec2 = new Vec2();\n    private _targetPosition: Vec2 = new Vec2();\n    private _zoom: number = 1;\n    private _targetZoom: number = 1;\n    private _locked = false;\n\n    get zoom() {\n        return this._zoom;\n    }\n    set zoom(v: number) {\n        this._targetZoom = v;\n    }\n\n    get x() {\n        return this._position.x;\n    }\n    set x(v: number) {\n        this._targetPosition.x = v;\n    }\n    get y() {\n        return this._position.y;\n    }\n    set y(v: number) {\n        this._targetPosition.y = v;\n    }\n\n    get position() {\n        return this._position;\n    }\n\n    setPosition(v: Vec2, force: boolean = false) {\n        if (force) {\n            return this._position.set(v);\n        }\n        return this._targetPosition.set(v);\n    }\n\n    lock(v: boolean) {\n        this._locked = v;\n    }\n\n    update({marbles, stage, needToZoom, targetIndex}: {marbles: Marble[], stage: StageDef, needToZoom: boolean, targetIndex: number}) {\n        // set target position\n        if (!this._locked) {\n            this._calcTargetPositionAndZoom(marbles, stage, needToZoom, targetIndex);\n        }\n\n        // interpolate position\n        this._position.x = this._interpolation(this.x, this._targetPosition.x);\n        this._position.y = this._interpolation(this.y, this._targetPosition.y);\n\n        // interpolate zoom\n        this._zoom = this._interpolation(this._zoom, this._targetZoom);\n    }\n\n    private _calcTargetPositionAndZoom(marbles: Marble[], stage: StageDef, needToZoom: boolean, targetIndex: number) {\n        if (marbles.length > 0) {\n            const targetMarble = marbles[targetIndex] ? marbles[targetIndex] : marbles[0];\n            this.setPosition(targetMarble.position);\n            if (needToZoom) {\n                const goalDist = Math.abs(stage.zoomY - this._position.y);\n                this.zoom = Math.max(1, (1 - (goalDist / zoomThreshold)) * 4);\n            } else {\n                this.zoom = 1;\n            }\n        } else {\n            this.setPosition(new Vec2(0,0));\n            this.zoom = 1;\n        }\n    }\n\n    private _interpolation(current: number, target: number) {\n        const d = target - current;\n        if (Math.abs(d) < (1 / initialZoom)) {\n            return target;\n        }\n\n        return current + (d / 10);\n    }\n\n    renderScene(ctx: CanvasRenderingContext2D, callback: (ctx: CanvasRenderingContext2D) => void) {\n        const zoomFactor = initialZoom * 2 * this._zoom;\n        ctx.save();\n        ctx.translate(-this.x * this._zoom, -this.y * this._zoom);\n        ctx.scale(this.zoom, this.zoom);\n        ctx.translate(ctx.canvas.width / zoomFactor, ctx.canvas.height / zoomFactor)\n        callback(ctx);\n        ctx.restore();\n    }\n}\n","import {canvasHeight, canvasWidth, initialZoom} from './data/constants';\nimport {Camera} from './camera';\nimport {StageDef} from './data/maps';\nimport {Body, Vec2} from 'planck';\nimport {Marble} from './marble';\nimport {ParticleManager} from './particleManager';\nimport {GameObject} from './gameObject';\nimport { UIObject } from './UIObject';\n\nexport type RenderParameters = {\n    camera: Camera,\n    stage: StageDef,\n    objects: Body[],\n    marbles: Marble[],\n    winners: Marble[],\n    particleManager: ParticleManager,\n    effects: GameObject[],\n    winnerRank: number,\n    winner: Marble | null,\n    size: Vec2,\n};\n\nexport class RouletteRenderer {\n    private _canvas!: HTMLCanvasElement;\n    private _ctx!: CanvasRenderingContext2D;\n    public sizeFactor = 1;\n\n    constructor() {\n    }\n\n    get width() {\n        return this._canvas.width;\n    }\n\n    get height() {\n        return this._canvas.height;\n    }\n\n    get canvas() {\n        return this._canvas;\n    }\n\n    init() {\n        this._canvas = document.createElement('canvas');\n        this._canvas.width = canvasWidth;\n        this._canvas.height = canvasHeight;\n        this._ctx = this._canvas.getContext('2d', {alpha: false}) as CanvasRenderingContext2D;\n\n\n        document.body.appendChild(this._canvas);\n\n        const resizing = (entries?: ResizeObserverEntry[]) => {\n            const realSize = entries ? entries[0].contentRect : this._canvas.getBoundingClientRect();\n            const width = Math.max(realSize.width / 2, 640);\n            const height = (width / realSize.width) * realSize.height;\n            this._canvas.width = width;\n            this._canvas.height = height;\n            this.sizeFactor = (width / realSize.width);\n        }\n\n        const resizeObserver = new ResizeObserver(resizing);\n\n        resizeObserver.observe(this._canvas);\n        resizing();\n    }\n\n    render(renderParameters: RenderParameters, uiObjects: UIObject[]) {\n        this._ctx.fillStyle = 'black';\n        this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n\n        this._ctx.save();\n        this._ctx.scale(initialZoom, initialZoom);\n        this._ctx.textAlign = 'left';\n        this._ctx.textBaseline = 'top';\n        this._ctx.font = '0.4pt sans-serif';\n        renderParameters.camera.renderScene(this._ctx, () => {\n            this._renderWalls({...renderParameters});\n            this._renderObjects({\n                ...renderParameters,\n            });\n            this._renderEffects(renderParameters);\n            this._renderMarbles(renderParameters);\n        });\n        this._ctx.restore();\n\n        uiObjects.forEach(obj => obj.render(this._ctx, renderParameters, this._canvas.width, this._canvas.height));\n        renderParameters.particleManager.render(this._ctx);\n        this._renderWinner(renderParameters);\n    }\n\n    private _renderWalls({stage, camera}: { stage: StageDef, camera: Camera}) {\n        if (!stage) return;\n        this._ctx.save();\n        this._ctx.strokeStyle = 'white';\n        this._ctx.lineWidth = 5 / (camera.zoom + initialZoom);\n        this._ctx.beginPath();\n        stage.walls.forEach((wallDef) => {\n            this._ctx.moveTo(wallDef[0][0], wallDef[0][1]);\n            for (let i = 1; i < wallDef.length; i++) {\n                this._ctx.lineTo(wallDef[i][0], wallDef[i][1]);\n            }\n        });\n        this._ctx.shadowColor = 'cyan';\n        this._ctx.shadowBlur = 15;\n        this._ctx.stroke();\n        this._ctx.closePath();\n        this._ctx.restore();\n    }\n\n    private _renderObjects({\n                               objects,\n                               camera,\n                           }: { objects: Body[], camera: Camera }) {\n        this._ctx.save();\n        this._ctx.fillStyle = 'black';\n        this._ctx.lineWidth = 3 / (camera.zoom + initialZoom);\n        objects.forEach(obj => {\n            this._ctx.save();\n            const pos = obj.getPosition();\n            const ang = obj.getAngle();\n            this._ctx.translate(pos.x, pos.y);\n            this._ctx.rotate(ang);\n            for (let fixture = obj.getFixtureList(); fixture; fixture = fixture.getNext()) {\n                const shape = fixture.getShape() as planck.Polygon;\n                this._ctx.beginPath();\n                switch(shape.getType()) {\n                    case 'circle':\n                        this._ctx.strokeStyle = 'yellow';\n                        this._ctx.arc(0, 0, shape.m_radius, 0, Math.PI * 2);\n                        break;\n                    default:\n                        this._ctx.strokeStyle = '#94d5ed';\n                        const vertices = shape.m_vertices;\n                        this._ctx.moveTo(vertices[0].x, vertices[0].y);\n                        for (let i = 1; i < vertices.length; i++) {\n                            const vert = vertices[i];\n                            this._ctx.lineTo(vert.x, vert.y);\n                        }\n                        this._ctx.closePath();\n                        break;\n                }\n                this._ctx.fill();\n\n                this._ctx.save();\n                this._ctx.shadowBlur = 15;\n                this._ctx.shadowColor = 'cyan';\n                this._ctx.stroke();\n                this._ctx.restore();\n\n                this._ctx.closePath();\n            }\n            this._ctx.restore();\n        });\n        this._ctx.restore();\n    }\n\n    private _renderEffects({effects, camera}: RenderParameters) {\n        effects.forEach(effect => effect.render(this._ctx, camera.zoom * initialZoom));\n    }\n\n    private _renderMarbles({marbles, camera, winnerRank, winners}: RenderParameters) {\n        const winnerIndex = winnerRank - winners.length;\n        marbles.forEach((marble, i) => {\n            marble.render(this._ctx, camera.zoom * initialZoom, i === winnerIndex, false);\n        });\n    }\n\n    private _renderWinner({winner}: RenderParameters) {\n        if (!winner) return;\n        this._ctx.save();\n        this._ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n        this._ctx.fillRect(this._canvas.width / 2, this._canvas.height - 168, this._canvas.width / 2, 168);\n        this._ctx.fillStyle = 'white';\n        this._ctx.font = 'bold 48px sans-serif';\n        this._ctx.textAlign = 'right';\n        this._ctx.fillText('Winner', this._canvas.width - 10, this._canvas.height - 120);\n        this._ctx.font = 'bold 72px sans-serif';\n        this._ctx.fillStyle = winner.color;\n        this._ctx.fillText(winner.name, this._canvas.width - 10, this._canvas.height - 55);\n        this._ctx.restore();\n    }\n}\n","import * as planck from 'planck';\nimport {GameObject} from './gameObject';\nimport {Vec2} from 'planck';\n\nconst lifetime = 500;\n\nexport class SkillEffect implements GameObject {\n    private _size: number = 0;\n    position: Vec2;\n    private _elapsed: number = 0;\n    isDestroy: boolean = false;\n\n    constructor(x: number, y: number) {\n        this.position = new planck.Vec2(x, y);\n    }\n\n    update(deltaTime: number) {\n        this._elapsed += deltaTime;\n        this._size = (this._elapsed / lifetime) * 10;\n        if (this._elapsed > lifetime) {\n            this.isDestroy = true;\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D, zoom: number) {\n        ctx.save();\n        const rate = this._elapsed / lifetime;\n        ctx.globalAlpha = 1 - (rate * rate);\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = 1 / zoom;\n        ctx.beginPath();\n        ctx.arc(this.position.x, this.position.y, this._size, 0, Math.PI*2);\n        ctx.stroke();\n        ctx.restore();\n    }\n}\n","export function bound<T extends Function>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> {\n  return {\n    configurable: true,\n    get(this: T): T {\n      const boundMethod = descriptor.value!.bind(this);\n      Object.defineProperty(this, propertyKey, {\n        value: boundMethod,\n        configurable: true,\n        writable: true,\n      });\n      return boundMethod;\n    }\n  };\n}","import { RenderParameters } from './rouletteRenderer';\nimport { UIObject } from './UIObject';\nimport { bound } from './utils/bound.decorator';\nimport {Rect} from './types/rect.type';\n\nexport class RankRenderer implements UIObject {\n  private _currentY = 0;\n  private _targetY = 0;\n  private fontHeight = 16;\n  private _userMoved = 0;\n  private _currentWinner = -1;\n  private maxY = 0;\n  constructor() {\n  }\n\n  @bound\n  onWheel(e: WheelEvent) {\n    this._targetY += e.deltaY;\n    if (this._targetY > this.maxY) {\n      this._targetY = this.maxY;\n    }\n    this._userMoved = 2000;\n  }\n\n  render(ctx: CanvasRenderingContext2D, {winners, marbles, winnerRank}: RenderParameters, width: number, height: number) {\n    const startX = width - 5;\n    const startY = Math.max(0, this._currentY - (height/2));\n    this.maxY = Math.max(0, (marbles.length + winners.length) * this.fontHeight);\n    this._currentWinner = winners.length;\n\n    ctx.save();\n    ctx.translate(0, -startY);\n    ctx.font = 'bold 11pt sans-serif';\n    ctx.textAlign = 'right';\n    winners.forEach((marble: { color: any; name: any; }, rank: number) => {\n      const y = rank * this.fontHeight;\n      if (y >= startY) {\n        ctx.fillStyle = marble.color;\n        ctx.fillText(`${rank === winnerRank ? '':'\\u2714'} ${marble.name} #${rank + 1}`, startX, 20 + y);\n      }\n    });\n    ctx.font = '10pt sans-serif';\n    marbles.forEach((marble: { color: any; name: any; }, rank: number) => {\n      ctx.fillStyle = marble.color;\n      const y = ((rank + winners.length)) * this.fontHeight;\n      ctx.fillText(`${marble.name} #${rank + 1 + winners.length}`, startX, 20 + y);\n    });\n    ctx.restore();\n  }\n\n  update(deltaTime: number) {\n    if (this._currentWinner === -1) {\n      return;\n    }\n    if (this._userMoved > 0) {\n      this._userMoved -= deltaTime;\n    } else {\n      this._targetY = this._currentWinner * this.fontHeight;\n    }\n    if (this._currentY !== this._targetY) {\n      this._currentY += (this._targetY - this._currentY) * (deltaTime / 250);\n    }\n    if (Math.abs(this._currentY - this._targetY) < 1) {\n      this._currentY = this._targetY;\n    }\n  }\n\n  getBoundingBox(): Rect | null {\n    return null;\n  }\n}\n","import {RenderParameters} from './rouletteRenderer';\nimport {initialZoom} from './data/constants';\nimport {UIObject} from './UIObject';\nimport {bound} from './utils/bound.decorator';\nimport {Vec2} from 'planck';\nimport { Rect } from './types/rect.type';\n\nexport class Minimap implements UIObject {\n    private ctx!: CanvasRenderingContext2D;\n    private lastParams: RenderParameters | null = null;\n\n    private _onViewportChangeHandler: ((pos?: Vec2) => void) | null = null;\n    private boundingBox: Rect;\n    private mousePosition: {x: number, y: number} | null = null;\n\n    constructor() {\n        this.boundingBox = {\n            x: 10,\n            y: 10,\n            w: 26 * 4,\n            h: 0,\n        };\n    }\n\n    getBoundingBox(): Rect | null {\n        return this.boundingBox;\n    }\n\n    onViewportChange(callback: (pos?: Vec2) => void) {\n        this._onViewportChangeHandler = callback;\n    }\n\n    update(deltaTime: number): void {\n        // nothing to do\n    }\n\n    @bound\n    onMouseMove(e?: { x: number; y: number; }) {\n        if (!e) {\n            this.mousePosition = null;\n            if (this._onViewportChangeHandler) {\n                this._onViewportChangeHandler();\n            }\n            return;\n        }\n        if (!this.lastParams) return;\n        this.mousePosition = {\n            x: e.x,\n            y: e.y,\n        };\n        if (this._onViewportChangeHandler) {\n            this._onViewportChangeHandler(new Vec2(this.mousePosition.x / 4, this.mousePosition.y / 4));\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D, params: RenderParameters) {\n        if (!ctx) return;\n        const {stage} = params;\n        if (!stage) return;\n        this.boundingBox.h = stage.goalY * 4;\n\n        this.lastParams = params;\n\n        this.ctx = ctx;\n        ctx.save();\n        ctx.fillStyle = '#333';\n        ctx.translate(10, 10);\n        ctx.scale(4, 4);\n        ctx.fillRect(0, 0, 26, stage.goalY);\n\n        this.drawWalls(params);\n        this.drawObjects(params);\n        this.drawMarbles(params);\n        this.drawViewport(params);\n\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'green';\n        ctx.lineWidth = 1;\n        ctx.strokeRect(this.boundingBox.x, this.boundingBox.y, this.boundingBox.w, this.boundingBox.h);\n        ctx.restore();\n    }\n\n    private drawViewport(params: RenderParameters) {\n        this.ctx.save();\n        const {camera, size} = params;\n        const zoom = (camera.zoom * initialZoom);\n        const w = size.x / zoom;\n        const h = size.y / zoom;\n        this.ctx.strokeStyle = 'white';\n        this.ctx.lineWidth = 1 / zoom;\n        this.ctx.strokeRect(camera.x - w/2, camera.y - h/2,  w,  h);\n        this.ctx.restore();\n    }\n\n    private drawWalls(params: RenderParameters) {\n        if (!params.stage) return;\n        this.ctx.save();\n        this.ctx.strokeStyle = 'black';\n        this.ctx.lineWidth = 0.5;\n        this.ctx.beginPath();\n        params.stage.walls.forEach((wallDef) => {\n            this.ctx.moveTo(wallDef[0][0], wallDef[0][1]);\n            for (let i = 1; i < wallDef.length; i++) {\n                this.ctx.lineTo(wallDef[i][0], wallDef[i][1]);\n            }\n        });\n        this.ctx.stroke();\n        this.ctx.closePath();\n        this.ctx.restore();\n    }\n\n    private drawObjects(params: RenderParameters) {\n        const {objects} = params;\n        if (!objects) return;\n        this.ctx.save();\n        this.ctx.fillStyle = 'black';\n        this.ctx.lineWidth = 1;\n        objects.forEach(obj => {\n            this.ctx.save();\n            const pos = obj.getPosition();\n            const ang = obj.getAngle();\n            this.ctx.translate(pos.x, pos.y);\n            this.ctx.rotate(ang);\n            for(let fixture = obj.getFixtureList(); fixture; fixture = fixture.getNext()) {\n                const shape = fixture.getShape() as planck.Polygon;\n                this.ctx.beginPath();\n                if (shape.getType() === 'circle') {\n                    this.ctx.strokeStyle = 'yellow';\n                    this.ctx.arc(0, 0, shape.m_radius, 0, Math.PI * 2);\n                } else {\n                    this.ctx.strokeStyle = '#94d5ed';\n                    const vertices = shape.m_vertices;\n                    this.ctx.moveTo(vertices[0].x, vertices[0].y);\n                    for (let i = 1; i < vertices.length; i++) {\n                        const vertex = vertices[i];\n                        this.ctx.lineTo(vertex.x, vertex.y);\n                    }\n                    this.ctx.closePath();\n                }\n                this.ctx.fill();\n                this.ctx.closePath();\n            }\n            this.ctx.restore();\n        });\n        this.ctx.restore();\n    }\n\n    private drawMarbles(params: RenderParameters) {\n        const {marbles} = params;\n        marbles.forEach((marble) => {\n            marble.render(this.ctx, 1, false, true);\n        });\n    }\n}\n","import {pad} from './utils';\n\nexport class VideoRecorder {\n    private targetCanvas: HTMLCanvasElement;\n    private mediaRecorder: MediaRecorder;\n    private videoStream: MediaStream;\n\n    private chunks: Blob[] = [];\n    private stopping = false;\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.targetCanvas = canvas;\n        this.videoStream = this.targetCanvas.captureStream();\n        this.mediaRecorder = new MediaRecorder(this.videoStream, {\n            videoBitsPerSecond: 6000000,\n        });\n    }\n\n    public async start() {\n        this.stopping = false;\n        return new Promise<void>((rs) => {\n            this.chunks = [];\n            this.mediaRecorder.ondataavailable = (e: BlobEvent) => {\n                this.chunks.push(e.data);\n            }\n            this.mediaRecorder.onstop = () => {\n                const blob = new Blob(this.chunks, {'type': 'video/webm'});\n                const videoUrl = URL.createObjectURL(blob);\n                const downloadLink = document.createElement('a');\n                const d = new Date();\n\n                downloadLink.href = videoUrl;\n                downloadLink.download = `marble_roulette_${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}.webm`;\n                downloadLink.click();\n                downloadLink.remove();\n                URL.revokeObjectURL(videoUrl);\n            };\n            this.mediaRecorder.onstart = () => {\n                rs();\n            }\n            this.mediaRecorder.start();\n        });\n    }\n\n    public stop() {\n        this.stopping = true;\n        if (this.mediaRecorder.state === 'recording') {\n            this.mediaRecorder.stop();\n        }\n    }\n\n}\n"],"names":["$5c96a02c592fcff1$export$29e00dfd3077644b","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","$1d1927fc5b91d8b6$export$bc572fe44976cfbc","Skills","$6f94c7a48e8964a6$exports","$28770b279d7ab5b1$export$29e4e862bebba87f","degree","Math","PI","$28770b279d7ab5b1$var$getRegexValue","regex","str","result","exec","$28770b279d7ab5b1$export$5d04458e2a6c373e","v","toString","padStart","factory","exports1","ManifoldType","ContactFeatureType","PointState","TOIOutputState","SeparationFunctionType","EPAxisType","VertexType","extendStatics","b","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","constructor","create","__assign","assign","t","s","n","apply","options","input","defaults","output","getOwnPropertySymbols","symbols","symbol","propertyIsEnumerable","common","debug","rest","_i","math","EPSILON","isFinite","x","isNaN","assert","invSqrt","sqrt","nextPowerOfTwo","isPowerOfTwo","mod","num","min","max","clamp","random","Vec2","y","_serialize","_deserialize","data","obj","zero","neo","clone","JSON","stringify","isValid","o","setZero","set","setNum","setVec2","value","wSet","a","w","setCombine","setMul","add","wAdd","addCombine","addMul","wSub","subCombine","subMul","sub","mul","m","lengthOf","lengthSquared","normalize","invLength","distance","dx","dy","distanceSquared","areEqual","skew","dot","cross","crossVec2Vec2","crossVec2Num","crossNumVec2","addCross","addCrossVec2Num","addCrossNumVec2","combine","mulNumVec2","mulVec2Num","neg","abs","mid","upper","lower","lengthSqr","scaleFn","translateFn","AABB","lowerBound","upperBound","getCenter","getExtents","getPerimeter","lowerA","upperA","lowerB","upperB","lowerX","lowerY","upperX","upperY","combinePoints","aabb","contains","extend","testOverlap","d1x","d2x","d1y","d2y","diff","wD","hD","wA","wB","rayCast","tmin","Infinity","tmax","p1","p2","absD","normal","f","inv_d","t1","t2","temp","maxFraction","fraction","Settings","get","linearSlop","enumerable","configurable","maxTranslation","maxRotation","pow","linearSleepTolerance","angularSleepTolerance","maxManifoldPoints","maxPolygonVertices","aabbExtension","aabbMultiplier","angularSlop","maxSubSteps","maxTOIContacts","maxTOIIterations","maxDistnceIterations","velocityThreshold","maxLinearCorrection","maxAngularCorrection","baumgarte","toiBaugarte","timeToSleep","Pool","opts","_list","_max","_createCount","_outCount","_inCount","_discardCount","_createFn","_outFn","allocate","_inFn","release","_discardFn","discard","size","item","shift","push","TreeNode","id","userData","parent","child1","child2","height","isLeaf","DynamicTree","inputPool","stack","stackPool","iteratorPool","Iterator","iterator","close","m_root","m_nodes","m_lastProxyId","m_pool","getUserData","node","getFatAABB","allocateNode","freeNode","createProxy","insertLeaf","destroyProxy","removeLeaf","moveProxy","leaf","leafAABB","index","area","combinedAABB","combinedArea","cost","inheritanceCost","cost1","oldArea","newArea","cost2","sibling","oldParent","newParent","balance","grandParent","iA","A","B","C","F","G","D","E","getHeight","getAreaRatio","rootArea","root","totalArea","it","preorder","next","computeHeight","height1","height2","validateStructure","validateMetrics","validate","getMaxBalance","maxBalance","rebuildBottomUp","nodes","count","minCost","iMin","jMin","aabbi","j","aabbj","parent_1","shiftOrigin","newOrigin","query","queryCallback","pop","proceed","rayCastCallback","abs_v","segmentAABB","subInput","h","separation","parents","states","BroadPhase","_this","m_tree","m_proxyCount","m_moveBuffer","proxyId","m_queryProxyId","proxyIdA","proxyIdB","userDataA","userDataB","m_callback","aabbA","aabbB","getProxyCount","getTreeHeight","getTreeBalance","getTreeQuality","bufferMove","unbufferMove","displacement","touchProxy","updatePairs","addPairCallback","fatAABB","Rot","angle","setAngle","setRot","setIdentity","rot","identity","sin","cos","getAngle","atan2","getXAxis","getYAxis","qr","mulRot","mulVec2","mulSub","mulT","mulTRot","mulTVec2","Transform","position","rotation","q","xf","setTransform","isArray","arr","mulXf","mulAll","mulFn","mulTXf","px","py","Sweep","localCenter","alpha0","c0","a0","setLocalCenter","getTransform","beta","advance","alpha","forward","that","Velocity","Position","Shape","_reset","m_type","m_radius","getRadius","getType","FixtureDefDefault","friction","restitution","density","isSensor","filterGroupIndex","filterCategoryBits","filterMaskBits","FixtureProxy","fixture","childIndex","Fixture","body","shape","def","m_body","m_friction","m_restitution","m_density","m_isSensor","m_filterGroupIndex","m_filterCategoryBits","m_filterMaskBits","m_shape","m_next","m_proxies","childCount","getChildCount","m_userData","getBody","broadPhase","m_world","m_broadPhase","destroyProxies","createProxies","m_xf","resetMassData","restore","getShape","setSensor","sensor","setAwake","setUserData","getNext","getDensity","setDensity","getFriction","setFriction","getRestitution","setRestitution","testPoint","getMassData","massData","computeMass","getAABB","proxy","computeAABB","synchronize","xf1","xf2","aabb1","aabb2","setFilterData","filter","groupIndex","categoryBits","maskBits","refilter","getFilterGroupIndex","setFilterGroupIndex","getFilterCategoryBits","setFilterCategoryBits","getFilterMaskBits","setFilterMaskBits","edge","getContactList","contact","fixtureA","getFixtureA","fixtureB","getFixtureB","flagForFiltering","world","getWorld","shouldCollide","collideA","collideB","STATIC","KINEMATIC","DYNAMIC","BodyDefDefault","type","linearVelocity","angularVelocity","linearDamping","angularDamping","fixedRotation","bullet","gravityScale","allowSleep","awake","active","MassData","mass","center","I","Body","m_awakeFlag","m_autoSleepFlag","m_bulletFlag","m_fixedRotationFlag","m_activeFlag","m_islandFlag","m_toiFlag","m_mass","m_invMass","m_I","m_invI","m_sweep","c_velocity","c_position","m_force","m_torque","m_linearVelocity","m_angularVelocity","m_linearDamping","m_angularDamping","m_gravityScale","m_sleepTime","m_jointList","m_contactList","m_fixtureList","m_prev","m_destroyed","fixtures","_addFixture","isWorldLocked","isLocked","getFixtureList","getJointList","isStatic","isDynamic","isKinematic","setStatic","setType","setDynamic","setKinematic","synchronizeFixtures","ce","ce0","destroyContact","proxyCount","isBullet","setBullet","flag","isSleepingAllowed","setSleepingAllowed","isAwake","isActive","setActive","isFixedRotation","setFixedRotation","synchronizeTransform","getPosition","setPosition","getWorldCenter","getLocalCenter","getLinearVelocity","getLinearVelocityFromWorldPoint","worldPoint","getLinearVelocityFromLocalPoint","localPoint","getWorldPoint","setLinearVelocity","getAngularVelocity","setAngularVelocity","getLinearDamping","setLinearDamping","getAngularDamping","setAngularDamping","getGravityScale","setGravityScale","scale","getMass","getInertia","oldCenter","setMassData","applyForce","force","point","wake","applyForceToCenter","applyTorque","torque","applyLinearImpulse","impulse","applyAngularImpulse","jn","other","joint","m_collideConnected","m_newFixture","createFixture","fixdef","destroyFixture","publish","getWorldVector","localVector","getLocalPoint","getLocalVector","worldVector","Mat22","ex","ey","getInverse","det","imx","solve","mx","mulMat22","mulTMat22","mx1","mx2","ClipVertex","ContactID","Manifold","localNormal","points","ManifoldPoint","pointCount","getWorldManifold","wm","xfA","radiusA","xfB","radiusB","WorldManifold","separations","e_circles","pointA","pointB","dist","cA","cB","e_faceA","planePoint","clipPoint","e_faceB","clipSegmentToLine","getPointStates","normalImpulse","tangentImpulse","cf","ContactFeature","indexA","indexB","typeA","typeB","state1","state2","manifold1","manifold2","removeState","persistState","addState","vOut","vIn","offset","vertexIndexA","numOut","distance0","distance1","interp","e_vertex","e_face","stats","gjkCalls","gjkIters","gjkMaxIters","toiTime","toiMaxTime","toiCalls","toiIters","toiMaxIters","toiRootIters","toiMaxRootIters","newline","string","name_1","DistanceInput","proxyA","DistanceProxy","proxyB","transformA","transformB","useRadii","DistanceOutput","SimplexCache","metric","Distance","cache","simplex","Simplex","readCache","vertices","m_v","k_maxIters","saveA","saveB","saveCount","iter","m_count","getClosestPoint","getSearchDirection","vertex","getSupport","getVertex","duplicate","getWitnessPoints","iterations","writeCache","rA","rB","m_buffer","m_vertices","getVertexCount","bestIndex","bestValue","getSupportVertex","computeDistanceProxy","SimplexVertex","m_v1","m_v2","m_v3","wALocal","wBLocal","metric1","metric2","getMetric","e12","sgn","pA","pB","solve2","solve3","w1","w2","d12_2","d12_1","inv_d12","w3","w1e12","w2e12","e13","w1e13","w3e13","d13_2","e23","w2e23","w3e23","d23_2","n123","d123_1","d123_2","d123_3","d13_1","inv_d13","d23_1","inv_d23","inv_d123","shapeA","shapeB","ContactEdge","s_registers","VelocityConstraintPoint","normalMass","tangentMass","velocityBias","Contact","fA","fB","evaluateFcn","friction1","friction2","restitution1","restitution2","m_manifold","m_toi","m_toiCount","m_tangentSpeed","m_enabledFlag","m_touchingFlag","m_filterFlag","m_bulletHitFlag","m_impulse","ContactImpulse","v_points","v_normal","v_normalMass","v_K","p_localPoints","p_localNormal","p_localPoint","p_localCenterA","p_localCenterB","m_nodeA","m_nodeB","m_fixtureA","m_fixtureB","m_indexA","m_indexB","m_evaluateFcn","initConstraint","step","bodyA","bodyB","manifold","getManifold","v_invMassA","v_invMassB","v_invIA","v_invIB","v_friction","v_restitution","v_tangentSpeed","v_pointCount","p_invMassA","p_invMassB","p_invIA","p_invIB","p_radiusA","p_radiusB","p_type","p_pointCount","cp","vcp","warmStarting","dtRatio","worldManifold","setEnabled","isEnabled","isTouching","getChildIndexA","getChildIndexB","resetFriction","resetRestitution","setTangentSpeed","speed","getTangentSpeed","evaluate","update","listener","oldManifold","touching","wasTouching","sensorA","sensorB","nmp","omp","beginContact","endContact","preSolve","solvePositionConstraint","_solvePositionConstraint","solvePositionConstraintTOI","toiA","toiB","toi","positionA","positionB","localCenterA","localCenterB","mA","mB","iB","aA","aB","minSeparation","rnA","rnB","K","P","initVelocityConstraint","velocityA","velocityB","vA","vB","kNormal","tangent","rtA","rtB","kTangent","vRel","blockSolve","vcp1","vcp2","rn1A","rn1B","rn2A","rn2B","k11","k22","k12","k_maxConditionNumber","warmStartConstraint","storeConstraintImpulses","solveVelocityConstraint","dv","vt","lambda","maxFriction","newImpulse","vn","dv1","dv2","vn1","vn2","P1","P2","addType","type1","type2","callback","prev","destroy","JointEdge","Joint","m_edgeA","m_edgeB","m_bodyA","m_bodyB","collideConnected","getBodyA","getBodyB","getCollideConnected","TOIInput","sweepA","sweepB","TOIOutput","TimeOfImpact","timer","Date","now","state","e_unknown","tMax","totalRadius","tolerance","k_maxIterations","distanceInput","distanceOutput","e_overlapped","e_touching","fcn","SeparationFunction","initialize","done","pushBackIter","s2","findMinSeparation","e_separated","s1","e_failed","rootIterCount","a1","a2","time","m_proxyA","m_proxyB","m_localPoint","m_axis","m_sweepA","m_sweepB","e_points","localPointA","localPointB","localPointB1","localPointB2","localPointA1","localPointA2","compute","find","axisA","axisB","sep","TimeStep","dt","inv_dt","velocityIterations","positionIterations","inv_dt0","reset","s_subStep","normals","tangents","Solver","m_stack","m_bodies","m_contacts","m_joints","clear","addBody","addContact","addJoint","solveWorld","m_bodyList","seed","je","solveIsland","gravity","m_gravity","m_allowSleep","initVelocityConstraints","solveVelocityConstraints","translation","maxTranslationSquared","ratio","maxRotationSquared","positionSolved","contactsOkay","jointsOkay","jointOkay","solvePositionConstraints","postSolveIsland","minSleepTime","linTolSqr","linearSleepToleranceSqr","angTolSqr","angularSleepToleranceSqr","printBodies","tag","solveWorldTOI","m_stepComplete","minContact","minAlpha","fA_1","fB_1","bA_1","bB_1","activeA","activeB","bA","bB","backup1","backup2","bodies","backup","solveIslandTOI","findNewContacts","m_subStepping","subStep","postSolve","WorldDefDefault","continuousPhysics","subStepping","World","s_step","createContact","m_contactCount","m_solver","m_bodyCount","m_jointCount","m_clearForces","m_locked","m_warmStarting","m_continuousPhysics","m_blockSolve","m_velocityIterations","m_positionIterations","m_t","joints","getBodyList","context","_addBody","createJoint","getBodyCount","getJointCount","getContactCount","setGravity","getGravity","setAllowSleeping","getAllowSleeping","setWarmStarting","getWarmStarting","setContinuousPhysics","getContinuousPhysics","setSubStepping","getSubStepping","setAutoClearForces","getAutoClearForces","clearForces","queryAABB","point1","point2","createBody","arg1","arg2","createDynamicBody","createKinematicBody","destroyBody","je0","destroyJoint","f0","timeStep","updateContacts","next_c","overlap","on","name","_listeners","off","listeners","indexOf","splice","arg3","l","Vec3","z","EdgeShape","_super","v1","v2","TYPE","polygonRadius","m_vertex1","m_vertex2","m_vertex0","m_vertex3","m_hasVertex0","m_hasVertex3","vertex1","vertex2","vertex0","vertex3","hasVertex0","hasVertex3","setPrevVertex","setNextVertex","setNext","getNextVertex","setPrev","getPrevVertex","_set","_clone","e","numerator","denominator","rr","ChainShape","loop","m_prevVertex","m_nextVertex","m_hasPrevVertex","m_hasNextVertex","m_isLoop","_createLoop","_createChain","isLoop","hasPrevVertex","hasNextVertex","prevVertex","nextVertex","getChildEdge","edgeShape","PolygonShape","m_centroid","m_normals","_setAsBox","ps","unique","linearSlopSquared","i0","x0","hull","ih","ie","i1","i2","ComputeCentroid","vs","pRef","inv3","p3","e1","e2","triangleArea","hx","hy","pLocal","minX","minY","maxX","maxY","k_inv3","ex1","ey1","ex2","ey2","intx2","BoxShape","CircleShape","m_p","radius","sigma","DEFAULTS$a","frequencyHz","dampingRatio","DistanceJoint","anchorA","anchorB","m_localAnchorA","localAnchorA","m_localAnchorB","localAnchorB","m_length","m_frequencyHz","m_dampingRatio","m_gamma","m_bias","gamma","bias","_setAnchors","getLocalAnchorA","getLocalAnchorB","setLength","getLength","setFrequency","hz","getFrequency","setDampingRatio","getDampingRatio","getAnchorA","getAnchorB","getReactionForce","m_u","getReactionTorque","m_localCenterA","m_localCenterB","m_invMassA","m_invMassB","m_invIA","m_invIB","qA","qB","m_rA","m_rB","crAu","crBu","invMass","omega","k","vpA","vpB","Cdot","u","DEFAULTS$9","maxForce","maxTorque","FrictionJoint","anchor","m_linearImpulse","m_angularImpulse","m_maxForce","m_maxTorque","setMaxForce","getMaxForce","setMaxTorque","getMaxTorque","m_linearMass","m_angularMass","oldImpulse","maxImpulse","Mat33","ez","solve33","solve22","a11","a12","a21","a22","getInverse22","M","getSymInverse33","a13","a23","a33","mulVec3","DEFAULTS$8","lowerAngle","upperAngle","maxMotorTorque","motorSpeed","enableLimit","enableMotor","RevoluteJoint","m_limitState","m_referenceAngle","referenceAngle","m_motorImpulse","m_lowerAngle","m_upperAngle","m_maxMotorTorque","m_motorSpeed","m_enableLimit","m_enableMotor","getReferenceAngle","getJointAngle","getJointSpeed","isMotorEnabled","getMotorTorque","setMotorSpeed","getMotorSpeed","setMaxMotorTorque","getMaxMotorTorque","isLimitEnabled","getLowerLimit","getUpperLimit","setLimits","m_motorMass","jointAngle","Cdot1","Cdot2","rhs","reduced","angularError","positionError","limitImpulse","DEFAULTS$7","lowerTranslation","upperTranslation","maxMotorForce","PrismaticJoint","axis","m_localXAxisA","localAxisA","m_localYAxisA","m_lowerTranslation","m_upperTranslation","m_maxMotorForce","m_perp","m_K","getLocalAxisA","getJointTranslation","setMaxMotorForce","getMaxMotorForce","getMotorForce","m_a1","m_a2","m_s1","m_s2","k13","k23","k33","jointTranslation","LA","LB","f1","df","f2r","perp","C1","linearError","C2","impulse1","DEFAULTS$6","GearJoint","joint1","joint2","coordinateA","coordinateB","m_joint1","m_joint2","m_ratio","m_type1","m_type2","m_bodyC","xfC","aC","revolute","m_localAnchorC","m_referenceAngleA","m_localAxisC","prismatic","pC","m_bodyD","xfD","aD","m_localAnchorD","m_referenceAngleB","m_localAxisD","pD","m_constant","getJoint1","getJoint2","setRatio","getRatio","m_JvAC","m_JwA","m_lcA","m_lcB","m_lcC","m_lcD","m_mA","m_mB","m_mC","m_mD","m_iA","m_iB","m_iC","m_iD","vC","wC","vD","qC","qD","m_JwC","rC","m_JvBD","m_JwB","m_JwD","rD","JvAC","JvBD","JwA","JwB","JwC","JwD","cC","cD","DEFAULTS$5","correctionFactor","MotorJoint","m_linearOffset","linearOffset","m_angularOffset","angularOffset","m_correctionFactor","setCorrectionFactor","factor","getCorrectionFactor","setLinearOffset","getLinearOffset","setAngularOffset","getAngularOffset","m_linearError","m_angularError","inv_h","DEFAULTS$4","MouseJoint","m_targetA","m_beta","m_C","_localAnchorB","setTarget","getTarget","velocity","DEFAULTS$3","PulleyJoint","groundA","groundB","m_groundAnchorA","groundAnchorA","m_groundAnchorB","groundAnchorB","m_lengthA","lengthA","m_lengthB","lengthB","getGroundAnchorA","getGroundAnchorB","getLengthA","getLengthB","getCurrentLengthA","getCurrentLengthB","m_uB","m_uA","ruA","ruB","PA","PB","uA","uB","DEFAULTS$2","maxLength","RopeJoint","m_maxLength","m_state","setMaxLength","getMaxLength","getLimitState","crA","crB","DEFAULTS$1","WeldJoint","invM","impulse2","DEFAULTS","WheelJoint","m_ax","m_ay","localAxis","m_springMass","m_springImpulse","setSpringFrequencyHz","getSpringFrequencyHz","setSpringDampingRatio","getSpringDampingRatio","m_sAy","m_sBy","m_sAx","m_sBx","damp","ay","sAy","sBy","SID","Serializer","_a","rootClass","preSerialize","postSerialize","preDeserialize","postDeserialize","refTypes","restoreTypes","CLASS_BY_TYPE_PROP","toJson","json","queue","refMap","top","typeName","storeRef","__sid","refIndex","refType","newValue","fromJson","deserialize","cls","ctx","deserializer","restoreRef","ref","serializer","CollideCircles","circleA","circleB","distSqr","CollideEdgeCircle","edgeA","Q","P_1","d_1","dd_1","A1","u1","P_2","d_2","dd_2","B2","den","dd","findMaxSeparation","poly1","poly2","count1","count2","n1s","v1s","v2s","maxSeparation","si","sij","chain","CollidePolygons","polyA","polyB","edge1","flip","separationA","edgeB","separationB","incidentEdge","findIncidentEdge","normals1","vertices2","normals2","normal1","minDot","vertices1","iv1","iv2","v11","v12","localTangent","frontOffset","sideOffset1","sideOffset2","clipPoints1","clipPoints2","np","CollidePolygonCircle","polygonA","cLocal","normalIndex","vertexCount","vertIndex1","u2","faceCenter","separation_1","CollideEdgePolygon","EPAxis","edgeAxis","polygonAxis","polygonBA","rf","sideNormal1","sideNormal2","polygonB","normal0","normal2","front","primaryAxis","centroidB","v0","v3","offset1","offset0","offset2","convex1","convex2","edge0","edge2","lowerLimit","upperLimit","e_edgeA","e_edgeB","k_relativeTol","internal","Input","Output","Proxy","Cache","Box","Chain","Circle","Edge","Polygon","$2573268c577c952d$var$options","useSkills","winningRank","autoRecording","$e7b6517817360fee$export$e91dba6fa3f67f68","order","weight","color","hue","impact","skill","None","_skillRate","_coolTime","_maxCoolTime","_stuckTime","lastPosition","maxLine","ceil","line","floor","lineDelta","circle","deltaTime","_updateSkillInformation","Impact","render","zoom","outline","isMinimap","save","_renderMinimap","_renderNormal","fillStyle","_drawMarbleBody","beginPath","arc","fill","shadowColor","shadowBlur","_drawName","_drawOutline","_renderCooltime","translate","font","strokeStyle","lineWidth","strokeText","fillText","stroke","$2139b4f99d5088b5$export$c36c68baa13912a5","_elapsed","isDestroy","ang","fx","fy","delta","globalAlpha","fillRect","$69fffa06e2cc8da9$export$6658904c50100579","_particles","forEach","particle","shot","$b2abafc93d11a512$export$1bfcff8d7c4bf05","title","goalY","zoomY","walls","boxes","wheels","jumpers","$238457a12dbae9c5$export$79f141de891a5fed","_zoom","_targetZoom","_position","_targetPosition","lock","_locked","marbles","stage","needToZoom","targetIndex","_calcTargetPositionAndZoom","_interpolation","targetMarble","goalDist","current","renderScene","zoomFactor","canvas","width","$68facf3481e408fc$export$a1ed140729fa937","sizeFactor","_canvas","init","document","createElement","_ctx","getContext","appendChild","resizing","entries","realSize","contentRect","getBoundingClientRect","resizeObserver","ResizeObserver","observe","renderParameters","uiObjects","textAlign","textBaseline","camera","_renderWalls","_renderObjects","_renderEffects","_renderMarbles","particleManager","_renderWinner","wallDef","moveTo","lineTo","closePath","objects","pos","rotate","vert","effects","effect","winnerRank","winners","winnerIndex","marble","winner","$43c01f2b0f9df660$export$2faf2590ac4901e1","_size","rate","$5d9d2ddcc4e90c63$export$adf7c0fe6059d774","propertyKey","descriptor","boundMethod","bind","writable","$e0350dec16bbe919$export$795f70ffe4ca76fc","_currentY","_targetY","fontHeight","_userMoved","_currentWinner","onWheel","deltaY","startX","startY","rank","getBoundingBox","$c2ea39beabe51779$export$a8b4308ba35ee473","lastParams","_onViewportChangeHandler","mousePosition","boundingBox","onViewportChange","onMouseMove","params","drawWalls","drawObjects","drawMarbles","drawViewport","strokeRect","$ba1c8fec6a2b59e4$export$ec9e02cabe22c790","chunks","stopping","targetCanvas","videoStream","captureStream","mediaRecorder","MediaRecorder","videoBitsPerSecond","start","Promise","rs","ondataavailable","onstop","blob","Blob","videoUrl","URL","createObjectURL","downloadLink","href","download","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","click","remove","revokeObjectURL","onstart","stop","$7c756c59aac10daa$export$4929751e8471403","EventTarget","_marbles","_lastTime","_noMoveDuration","_shakeAvailable","_updateInterval","_timeScale","_speed","_winners","_objects","_stageObjects","_particleManager","_stage","_camera","_renderer","_effects","_winnerRank","_totalMarbleCount","_goalDist","_isRunning","_winner","_uiObjects","_autoRecording","_init","_update","getZoom","addUiObject","addEventListener","currentTime","interval","_world","_updateMarbles","_updateEffects","sort","_changeShakeAvailable","_render","window","requestAnimationFrame","isTemporary","norm","power","dispatchEvent","CustomEvent","detail","setTimeout","_recorder","topY","_calcTimeScale","maximumForce","reduce","renderParams","attachEvent","minimap","_loadMap","offsetX","offsetY","bounds","undefined","Error","wall","map","wheelDef","mover","boxDef","boxBody","jumperDef","jumper","clearMarbles","then","setSpeed","getSpeed","setWinningRank","setAutoRecording","setMarbles","names","slice","maxWeight","minWeight","members","nameString","nameStr","weightRegex","countRegex","hasWeight","test","hasCount","parseInt","replace","member","gap","totalCount","orders","_","_clearMap","getCount","shake","getMaps","setMap","$b4e14b6b8da86996$var$roulette","roullete","inactiveLimit","atLowerLimit","atUpperLimit","equalLimits"],"version":3,"file":"index.8efdd510.js.map"}